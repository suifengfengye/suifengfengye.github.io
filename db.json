{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"source/images/redux-middleware.png","path":"images/redux-middleware.png","modified":1,"renderable":0},{"_id":"themes/anodyne/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1}],"Cache":[{"_id":"themes/anodyne/README.md","hash":"319ba3cb76b53d06fed74971cea546bb1437772b","modified":1545295675004},{"_id":"themes/anodyne/LICENSE","hash":"981e45e987ee55b122225cab1cb17fd433ed011b","modified":1545295675003},{"_id":"themes/anodyne/_config.yml","hash":"b287b9b8a27d370eb7fb6ea0cb7d5939d9d151eb","modified":1546940522204},{"_id":"source/_drafts/redux6.md","hash":"94bbf782e01bc0b3c6948e136169dd4f1106de2b","modified":1546941582209},{"_id":"source/_drafts/redux7.md","hash":"9ca5cdb9dd95704ad35e6edee39d5903aea11b73","modified":1547125673487},{"_id":"source/_drafts/redux8.md","hash":"3bc2b3779a559d22893536dceb5acd3645b53f82","modified":1546941624032},{"_id":"source/_posts/React-001.md","hash":"f49f1e88561b431ff20b09372e2607106664de66","modified":1564462765153},{"_id":"source/_posts/hello-world.md","hash":"e8be852c9fefb4b32f6b0f28b178d6c061e56bb4","modified":1547089214718},{"_id":"source/_posts/hexo-record-20190110.md","hash":"32832c336e4e131af212f471b5cd6c6bfb20d6fb","modified":1547092461799},{"_id":"source/_posts/My-New-Post.md","hash":"465a74011d72075d59b91dea3f0716bbf1bed051","modified":1545295674995},{"_id":"source/_posts/python3-nginx-uwsgi-20190727.md","hash":"355994856011ffa13bec4a90be2fcf7643f61871","modified":1564453083267},{"_id":"source/_posts/react-ace-placeholder-20190329.md","hash":"8b899d152e813c3ab0708333bf6589e7d5b82efa","modified":1554093426576},{"_id":"source/_posts/reactRouter1-fist-acquaintance-20190225.md","hash":"9ccb95eea2b08df325b0f4cc4a2083932dc29c83","modified":1552368363466},{"_id":"source/_posts/reactRouter2-skills-20190320.md","hash":"d965ed5302a56e5e7e6843da8985b65df052765d","modified":1553858021497},{"_id":"source/_posts/redux.md","hash":"3212bc9222056d96865a325c7945075681c810f8","modified":1547089030689},{"_id":"source/_posts/redux2-todo ui-20181220.md","hash":"13cb8a4ac740312e2d7f90b72b2e97557ab5f8e3","modified":1547089181783},{"_id":"source/_posts/redux3-redux+react-20181216.md","hash":"fefa032ef64b3c2ec7404c28ecc08d40c834f8fe","modified":1547089122050},{"_id":"source/_posts/redux6-myRedux-20190110.md","hash":"2738deffef26768c630cd2656c7e2b2bc5e38903","modified":1547094004840},{"_id":"source/_posts/redux4-asyncAction-20181230.md","hash":"e3aba3ee14a4c7368857640b05afef4730791106","modified":1547089136700},{"_id":"source/_posts/redux5-middleware-20190110.md","hash":"3717177ae4374c6b7791ca4b2e1b56cbec1a3636","modified":1550467775658},{"_id":"source/_posts/redux8-vuex-20190113.md","hash":"c9ccb1873339ca05fb10f1a350068367ad330fe7","modified":1547787598780},{"_id":"source/_posts/redux7-vue-20190113.md","hash":"c43234e6c22e1f09945b8762af5dd5d7c28ce0e7","modified":1547787598779},{"_id":"source/_posts/我的第一篇博客文章.md","hash":"f98415e5421859b294f6041dce348a939f8f09c8","modified":1564462765153},{"_id":"source/about/index.md","hash":"4a2c6ace51bec7688a37f357baf2f5eed71c85c5","modified":1545295675000},{"_id":"source/categories/index.md","hash":"5a49fbc477a56a44881fd0569525afbfd61f78ec","modified":1545295675001},{"_id":"source/_posts/前端也来学AI-20181130.md","hash":"4d03cf1c18028a61097df946cbb850351b6e84d2","modified":1562260728110},{"_id":"source/_posts/redux9-test-20190212.md","hash":"b1919b533a20b88baddb64b88a04c2c92ad4bcbc","modified":1550467231803},{"_id":"themes/anodyne/languages/default.yml","hash":"d65ddf96a0fbb71b39652935f40ac79518a708f3","modified":1545295675005},{"_id":"source/tags/index.md","hash":"f56b1df4c08b90ae76d90ade6484e62255849a9b","modified":1545295675002},{"_id":"source/images/redux-middleware.png","hash":"cf49b97ca313e878eb4eb7726b578c182abf0c49","modified":1547087919840},{"_id":"themes/anodyne/languages/en.yml","hash":"d65ddf96a0fbb71b39652935f40ac79518a708f3","modified":1545295675006},{"_id":"themes/anodyne/languages/fr.yml","hash":"7670f9b02f35365d869cde7f610c99466f994e0e","modified":1545295675006},{"_id":"themes/anodyne/languages/ja.yml","hash":"82fa6c8d18d2c61c5d4a80a0d13d7d53d9c10415","modified":1545295675007},{"_id":"themes/anodyne/languages/nl.yml","hash":"a4edf7590033031143c2320ffd296846c3f27098","modified":1545295675007},{"_id":"themes/anodyne/languages/zh-CN.yml","hash":"681e31edea1056ad3bebcdc745322971b5cf54e0","modified":1545295675008},{"_id":"themes/anodyne/layout/index.ejs","hash":"d005713f8551ce06e2e5877c24b1039d572a1aee","modified":1545295675016},{"_id":"themes/anodyne/layout/layout.ejs","hash":"7b8411e28713594496b7ae94d337684779417e4f","modified":1545295675016},{"_id":"themes/anodyne/template/debug.css","hash":"b9e864fe3df47f680082a7333c30a62b443f6d1a","modified":1545295675021},{"_id":"themes/anodyne/layout/page.ejs","hash":"90319ee4742ced4b84ce09b0c4995c2463d756ca","modified":1545295675017},{"_id":"themes/anodyne/layout/archive.ejs","hash":"a9b5fc1bdec50af4d664dc58a62fae1cc8bb59ac","modified":1545295675015},{"_id":"themes/anodyne/layout/post.ejs","hash":"aae67ddf5eb769bbc9110929f6463171242e028a","modified":1545295675017},{"_id":"themes/anodyne/template/index.html","hash":"461f3bb4fcb2425efe5fb6ef1d27812ea6c381a3","modified":1545295675051},{"_id":"themes/anodyne/template/post.html","hash":"1203ec10a07779f1912e95c5973df80782f5fc91","modified":1545295675053},{"_id":"themes/anodyne/template/logo.svg","hash":"2f920701d43c40ce99b5ae85a9d0d0fb6affe66a","modified":1545295675051},{"_id":"themes/anodyne/template/style.css","hash":"f513bd4d7ca53382a6fbcce1cc01b76f612310ea","modified":1545295675053},{"_id":"source/_posts/python3-nginx-uwsgi-20190727/sqlite3.png","hash":"a8dce9ee90ff91ef99ba271ecf72267787731cb4","modified":1564449691411},{"_id":"source/_posts/python3-nginx-uwsgi-20190727/sqlite3-01.png","hash":"5a831e2965a3f637f9f5ac7ba956e3cfd4bf42a0","modified":1564364521375},{"_id":"source/_posts/python3-nginx-uwsgi-20190727/python3-success.png","hash":"b5d152943f0e9f0adf47cbc4bb9488d964016c97","modified":1564364521375},{"_id":"source/_posts/react-ace-placeholder-20190329/react-ace-cursor.png","hash":"f83a473c596f0c9f690669ab49adb1a02f95e9a1","modified":1553936527924},{"_id":"source/_posts/redux5-middleware-20190110/redux-middleware.png","hash":"cf49b97ca313e878eb4eb7726b578c182abf0c49","modified":1547088907303},{"_id":"themes/anodyne/layout/_partial/article-archive.ejs","hash":"5050db10de978ae74f4acf4777574038da903749","modified":1545295675009},{"_id":"themes/anodyne/layout/_partial/footer.ejs","hash":"61479643384e10ddd2713b1b0af33eddedfca9e9","modified":1545295675011},{"_id":"themes/anodyne/layout/_partial/article-short.ejs","hash":"10ae596f7d7bfc0911b30ec9b8e3cb9b22269e19","modified":1545295675010},{"_id":"themes/anodyne/layout/_partial/banner.ejs","hash":"5b652ce4e82366f88947381d7385041e2768ab4a","modified":1545295675011},{"_id":"themes/anodyne/layout/_partial/after-footer.ejs","hash":"56413d195aefdb3f3fb485adbc5948db4e3dfff2","modified":1547091062362},{"_id":"themes/anodyne/layout/_partial/google-analytics.ejs","hash":"b287b7f66a53b51c7cd872ad1b15dfd20fb3e35d","modified":1545295675012},{"_id":"themes/anodyne/layout/_partial/comments.ejs","hash":"d7574d60b08e6d5b0eb9fcf93052c39a800963ca","modified":1545295675011},{"_id":"themes/anodyne/layout/_partial/widget-categories.ejs","hash":"b809841c2cce986aefccfcdaec4c51d52d8820b5","modified":1545295675014},{"_id":"themes/anodyne/layout/_partial/tag-category-index.ejs","hash":"e2e30448279d56f77b39e98fdcdd6da8c72dd6da","modified":1545295675013},{"_id":"themes/anodyne/layout/_partial/widget-about.ejs","hash":"72601cf414aa7679969665cc82ecdb44c60bd6a1","modified":1545295675014},{"_id":"themes/anodyne/layout/_partial/head.ejs","hash":"bcff6db78f103f9031e63e90cf047db8c50429a1","modified":1545295675012},{"_id":"themes/anodyne/layout/_partial/widget-recent-posts.ejs","hash":"b6537acad29d852f78272b393017a7dcf06e3912","modified":1545295675015},{"_id":"themes/anodyne/layout/_partial/pagination.ejs","hash":"01e67da7ba631ee9b64cf1319c78105dead9c25b","modified":1545295675013},{"_id":"themes/anodyne/template/devicon/Read Me.txt","hash":"7cb4baf9bd429bcd3833d2a96f3fbe29a7dd4ce9","modified":1545295675022},{"_id":"themes/anodyne/template/devicon/style.css","hash":"67c3009d5a8210fb439a14729ebd13872501af9e","modified":1545295675050},{"_id":"themes/anodyne/source/css/style.styl","hash":"ab94cf20fba74243a9fba0710954c182c7279d72","modified":1545295675020},{"_id":"source/_posts/python3-nginx-uwsgi-20190727/django-success.png","hash":"dd96f1b105f49018e24adb6624320592f7f5a061","modified":1564452184789},{"_id":"source/_posts/redux/result-20181213.png","hash":"8c62077f8941e1a61f85be954bf970182a643f3c","modified":1545295674998},{"_id":"themes/anodyne/template/devicon/demo-files/demo.js","hash":"e264ca246dbc4c632b053c19f7ca746b95b3f0b3","modified":1545295675023},{"_id":"themes/anodyne/template/devicon/demo-files/demo.css","hash":"376a44d4a24eea8b44641724a7f9864a48038791","modified":1545295675023},{"_id":"themes/anodyne/source/css/partial/_base.styl","hash":"ccdedafe01cf83dfb3bba810c4745d5dd1ebcd57","modified":1545295675019},{"_id":"source/_posts/react-ace-placeholder-20190329/react-ace-placeholder-01.gif","hash":"fd439c3fba4aae12502c07e33b5b94ddeba79889","modified":1553923007528},{"_id":"themes/anodyne/source/css/partial/_content.styl","hash":"9bc7ffe607f0c99946d3cca532ce55d0e8ff5e9e","modified":1545295675019},{"_id":"themes/anodyne/source/css/partial/_highlight.styl","hash":"7ca9752ca150643729b713a59a1a9953b3b7352a","modified":1545295675020},{"_id":"source/_posts/reactRouter2-skills-20190320/router-children.gif","hash":"b2700e4fd0aa9bc8c6774e60a2ed14353f835256","modified":1553144218686},{"_id":"source/_posts/reactRouter2-skills-20190320/router-404.gif","hash":"bb69736bc864e2bf9ec20f8398dd80949508cb15","modified":1553853737675},{"_id":"themes/anodyne/template/devicon/fonts/devicon.eot","hash":"72d1a173e58c7508bb1457a535b67472c6c35cec","modified":1545295675029},{"_id":"themes/anodyne/template/devicon/fonts/devicon.ttf","hash":"3eb76cd8e89f7046a735a7a8bc2de693c7314a07","modified":1545295675038},{"_id":"themes/anodyne/template/devicon/fonts/devicon.woff","hash":"69b887104812d0f246195fc3ee4abcafbbc4e961","modified":1545295675041},{"_id":"themes/anodyne/template/devicon/demo.html","hash":"62cc426875788b907d6e2f6df91c631c4839add8","modified":1545295675025},{"_id":"themes/anodyne/template/devicon/fonts/devicon.svg","hash":"b86b7899f2e717e81286220e982d69939d601688","modified":1545295675035},{"_id":"themes/anodyne/template/devicon/selection.json","hash":"ea12e05500a7eda0158e8e3c3509ad53c9755a3a","modified":1545295675049},{"_id":"source/_posts/react-ace-placeholder-20190329/react-ace-02.gif","hash":"146654c62b8b93b16cd375c3acd7510e2ccc912d","modified":1553927755585}],"Category":[{"name":"Diary","_id":"cjypcvopr00134c4170ppnc7t"},{"name":"Life","parent":"cjypcvopr00134c4170ppnc7t","_id":"cjypcvopt00184c41irdzh8cj"},{"name":"redux","_id":"cjypcvoq2001k4c41grm2uzmr"}],"Data":[],"Page":[{"title":"about","_content":"","source":"about/index.md","raw":"---\ntitle: about\n---\n","date":"2018-12-20T08:47:55.000Z","updated":"2018-12-20T08:47:55.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjypcvop3000j4c41888wwt8p","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"All tags","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: All tags\ntype: \"categories\"\n---\n","date":"2018-12-20T08:47:55.001Z","updated":"2018-12-20T08:47:55.001Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjypcvop8000l4c41xm670nsj","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"All tags","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: All tags\ntype: \"tags\"\n---\n","date":"2018-12-20T08:47:55.002Z","updated":"2018-12-20T08:47:55.002Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjypcvopb000o4c41r3yu268e","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"redux(六)-redux原理","_content":"","source":"_drafts/redux6.md","raw":"---\ntitle: redux(六)-redux原理\ntags: redux\n---\n","slug":"redux6","published":0,"date":"2019-07-30T05:02:21.632Z","updated":"2019-01-08T09:59:42.209Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvooa00004c41saj091f6","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"redux(七)-redux+vue","_content":" ","source":"_drafts/redux7.md","raw":"---\ntitle: redux(七)-redux+vue\ntags: redux\n---\n ","slug":"redux7","published":0,"date":"2019-07-30T05:02:21.632Z","updated":"2019-01-10T13:07:53.487Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvooe00014c41f8mmvls9","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Hello World","date":"2018-01-01T05:32:47.000Z","_content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","source":"_posts/hello-world.md","raw":"---\ntitle: Hello World\ndate: 2018-1-1 13:32:47\ntags: []\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","slug":"hello-world","published":1,"updated":"2019-01-10T03:00:14.718Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvook00044c41k16sxh3b","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><pre><code class=\"bash\">$ hexo new &quot;My New Post&quot;\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><pre><code class=\"bash\">$ hexo server\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><pre><code class=\"bash\">$ hexo generate\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><pre><code class=\"bash\">$ hexo deploy\n</code></pre>\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n"},{"title":"redux(八)-redux与vuex","_content":"","source":"_drafts/redux8.md","raw":"---\ntitle: redux(八)-redux与vuex\ntags: redux\n---\n","slug":"redux8","published":0,"date":"2019-07-30T05:02:21.632Z","updated":"2019-01-08T10:00:24.032Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvool00054c41rltpt5ar","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"d3 树图、封闭图","date":"2018-11-28T05:28:54.000Z","icon":"fa-handshake-o","_content":"# 1、树图\n\n## 1.1、简介\n能够展现不同数据元素之间的依赖。树图中，两个节点之间只有一条路径相互连接彼此。\n\n## 1.2 构建树图\n\n- 数据\n\n树图的数据，仍然使用d3.hierarchy()或者d3.stratify()生成的数据。（见9-1）\n\n- 布局\n\n树图的布局，使用d3.tree()这个方法。d3.tree()是一个工厂方法，根据设置生成一个可以用于布局的方法（假设为 *_tree* ）。 \n\n*_tree()* 方法接收一个参数，即d3.hierarchy()或者d3.stratify()生成的数据座位参数。方法执行后，就往参数对象中回填x/y坐标数据。\n\n```\nvar _tree = d3.tree()\n        .size([w, h - 80]);\n// root为d3.hierarchy()或者d3.stratify()方法生成的树状结构数据\n_tree(root);\n```\n\n\n- 画圆圈、文本\n\n由于树状结构数据不是一个数组，而我们在画圆圈、或者现实文本的时候需要一个数组，所以需要将root转化为数组。使用 *root.descendants()* 方法转化。\n\n画圆圈、添加文本按正常的d3添加circle、text元素即可。\n\n```\nconst nodes = root.descendants();\n```\n\n- 画连线\n\n画竖线使用 *d3.linkVertical()* 方法，画横线使用 *d3.linkHorizonal()* 方法。这两个方法的返回值，都有x、y两个属性方法，把上一步中的树状结构节点中生存的x、y值传入即可。（x、y值已经使用d3.tree()(root)计算出来）。\n\n而连线的数据需要调用 *_tree(root).links()* 方法获取。\n\n具体代码如下：\n\n```\n// 画线\nconst linkFn = isVertical ? d3.linkVertical()\n        .x(function (d) { return d.x; })\n        .y(function (d) { return d.y; })\n        : d3.linkHorizontal()\n            .x(function (d) { return d.y; })\n            .y(function (d) { return d.x; })\n\n_bodyG.selectAll('.link')\n        .data(_tree(root).links())\n        .enter()\n        .append('path')\n        .attr('class', 'link')\n        .attr('d', linkFn);\n```\n\n2、封闭图\n\n封闭图跟创建树图的步骤基本一致。下面只总结一下封闭图的不同知识点。\n\n- 布局\n\n布局使用 *d3.pack()* 方法，这是一个工厂方法。根据设置可以生成一个可以用于布局封闭图的方法（假设生成的方法为 *_pack* ）.\n\n```\nvar _pack = d3.pack()\n    .size([w, h])\n    .padding(3);\n```\n\n调用 *_pack()* 方法，可以为树状结构数据计算出坐标值（包括x／y/r这些属性值）。\n\n```\n// root为树状结构数据，由d3.hierarchy()或者d3.stratify()方法生成。\n_pack(root);\n```\n\n- 背景色\n\n```\nvar _colors = d3.scaleSequential(d3.interpolateMagma)\n    .domain([-4, 4]);\n```\n\n- 剪切\n\n由于圆圈内的text文本可能超出范围，为避免这种情况出现，就可以使用svg的剪切功能。\n\n```\ncircle-id\nclipPath\n    - use('xlink:href', '#circle-id')\n    - id: pack-clip-id\ntext\n    - attr('clip-path', 'url(#pack-clip-id)')\n```\n\n- hover\n\nd3支持svg的事件。使用 *mouseover* 和 *mouseout* 来模拟hover。\n\n```\npackEnters.each(function (d) {\n        d.node = this;\n    }).on('mouseover', hovered(true))\n        .on('mouseout', hovered(false));\n    function hovered (hover) {\n        return (d) => {\n            d3.selectAll(d.ancestors().map(function (d) {\n                return d.node;\n            })).classed('pack-node-hover', hover);\n        }\n    };\n```","source":"_posts/My-New-Post.md","raw":"---\ntitle: d3 树图、封闭图\ndate: 2018-11-28 13:28:54\ntags: [\"d3\", \"charts\"]\nicon: fa-handshake-o\n---\n# 1、树图\n\n## 1.1、简介\n能够展现不同数据元素之间的依赖。树图中，两个节点之间只有一条路径相互连接彼此。\n\n## 1.2 构建树图\n\n- 数据\n\n树图的数据，仍然使用d3.hierarchy()或者d3.stratify()生成的数据。（见9-1）\n\n- 布局\n\n树图的布局，使用d3.tree()这个方法。d3.tree()是一个工厂方法，根据设置生成一个可以用于布局的方法（假设为 *_tree* ）。 \n\n*_tree()* 方法接收一个参数，即d3.hierarchy()或者d3.stratify()生成的数据座位参数。方法执行后，就往参数对象中回填x/y坐标数据。\n\n```\nvar _tree = d3.tree()\n        .size([w, h - 80]);\n// root为d3.hierarchy()或者d3.stratify()方法生成的树状结构数据\n_tree(root);\n```\n\n\n- 画圆圈、文本\n\n由于树状结构数据不是一个数组，而我们在画圆圈、或者现实文本的时候需要一个数组，所以需要将root转化为数组。使用 *root.descendants()* 方法转化。\n\n画圆圈、添加文本按正常的d3添加circle、text元素即可。\n\n```\nconst nodes = root.descendants();\n```\n\n- 画连线\n\n画竖线使用 *d3.linkVertical()* 方法，画横线使用 *d3.linkHorizonal()* 方法。这两个方法的返回值，都有x、y两个属性方法，把上一步中的树状结构节点中生存的x、y值传入即可。（x、y值已经使用d3.tree()(root)计算出来）。\n\n而连线的数据需要调用 *_tree(root).links()* 方法获取。\n\n具体代码如下：\n\n```\n// 画线\nconst linkFn = isVertical ? d3.linkVertical()\n        .x(function (d) { return d.x; })\n        .y(function (d) { return d.y; })\n        : d3.linkHorizontal()\n            .x(function (d) { return d.y; })\n            .y(function (d) { return d.x; })\n\n_bodyG.selectAll('.link')\n        .data(_tree(root).links())\n        .enter()\n        .append('path')\n        .attr('class', 'link')\n        .attr('d', linkFn);\n```\n\n2、封闭图\n\n封闭图跟创建树图的步骤基本一致。下面只总结一下封闭图的不同知识点。\n\n- 布局\n\n布局使用 *d3.pack()* 方法，这是一个工厂方法。根据设置可以生成一个可以用于布局封闭图的方法（假设生成的方法为 *_pack* ）.\n\n```\nvar _pack = d3.pack()\n    .size([w, h])\n    .padding(3);\n```\n\n调用 *_pack()* 方法，可以为树状结构数据计算出坐标值（包括x／y/r这些属性值）。\n\n```\n// root为树状结构数据，由d3.hierarchy()或者d3.stratify()方法生成。\n_pack(root);\n```\n\n- 背景色\n\n```\nvar _colors = d3.scaleSequential(d3.interpolateMagma)\n    .domain([-4, 4]);\n```\n\n- 剪切\n\n由于圆圈内的text文本可能超出范围，为避免这种情况出现，就可以使用svg的剪切功能。\n\n```\ncircle-id\nclipPath\n    - use('xlink:href', '#circle-id')\n    - id: pack-clip-id\ntext\n    - attr('clip-path', 'url(#pack-clip-id)')\n```\n\n- hover\n\nd3支持svg的事件。使用 *mouseover* 和 *mouseout* 来模拟hover。\n\n```\npackEnters.each(function (d) {\n        d.node = this;\n    }).on('mouseover', hovered(true))\n        .on('mouseout', hovered(false));\n    function hovered (hover) {\n        return (d) => {\n            d3.selectAll(d.ancestors().map(function (d) {\n                return d.node;\n            })).classed('pack-node-hover', hover);\n        }\n    };\n```","slug":"My-New-Post","published":1,"updated":"2018-12-20T08:47:54.995Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvooo00084c41qcm73d7n","content":"<h1 id=\"1、树图\"><a href=\"#1、树图\" class=\"headerlink\" title=\"1、树图\"></a>1、树图</h1><h2 id=\"1-1、简介\"><a href=\"#1-1、简介\" class=\"headerlink\" title=\"1.1、简介\"></a>1.1、简介</h2><p>能够展现不同数据元素之间的依赖。树图中，两个节点之间只有一条路径相互连接彼此。</p>\n<h2 id=\"1-2-构建树图\"><a href=\"#1-2-构建树图\" class=\"headerlink\" title=\"1.2 构建树图\"></a>1.2 构建树图</h2><ul>\n<li>数据</li>\n</ul>\n<p>树图的数据，仍然使用d3.hierarchy()或者d3.stratify()生成的数据。（见9-1）</p>\n<ul>\n<li>布局</li>\n</ul>\n<p>树图的布局，使用d3.tree()这个方法。d3.tree()是一个工厂方法，根据设置生成一个可以用于布局的方法（假设为 <em>_tree</em> ）。 </p>\n<p><em>_tree()</em> 方法接收一个参数，即d3.hierarchy()或者d3.stratify()生成的数据座位参数。方法执行后，就往参数对象中回填x/y坐标数据。</p>\n<pre><code>var _tree = d3.tree()\n        .size([w, h - 80]);\n// root为d3.hierarchy()或者d3.stratify()方法生成的树状结构数据\n_tree(root);\n</code></pre><ul>\n<li>画圆圈、文本</li>\n</ul>\n<p>由于树状结构数据不是一个数组，而我们在画圆圈、或者现实文本的时候需要一个数组，所以需要将root转化为数组。使用 <em>root.descendants()</em> 方法转化。</p>\n<p>画圆圈、添加文本按正常的d3添加circle、text元素即可。</p>\n<pre><code>const nodes = root.descendants();\n</code></pre><ul>\n<li>画连线</li>\n</ul>\n<p>画竖线使用 <em>d3.linkVertical()</em> 方法，画横线使用 <em>d3.linkHorizonal()</em> 方法。这两个方法的返回值，都有x、y两个属性方法，把上一步中的树状结构节点中生存的x、y值传入即可。（x、y值已经使用d3.tree()(root)计算出来）。</p>\n<p>而连线的数据需要调用 <em>_tree(root).links()</em> 方法获取。</p>\n<p>具体代码如下：</p>\n<pre><code>// 画线\nconst linkFn = isVertical ? d3.linkVertical()\n        .x(function (d) { return d.x; })\n        .y(function (d) { return d.y; })\n        : d3.linkHorizontal()\n            .x(function (d) { return d.y; })\n            .y(function (d) { return d.x; })\n\n_bodyG.selectAll(&#39;.link&#39;)\n        .data(_tree(root).links())\n        .enter()\n        .append(&#39;path&#39;)\n        .attr(&#39;class&#39;, &#39;link&#39;)\n        .attr(&#39;d&#39;, linkFn);\n</code></pre><p>2、封闭图</p>\n<p>封闭图跟创建树图的步骤基本一致。下面只总结一下封闭图的不同知识点。</p>\n<ul>\n<li>布局</li>\n</ul>\n<p>布局使用 <em>d3.pack()</em> 方法，这是一个工厂方法。根据设置可以生成一个可以用于布局封闭图的方法（假设生成的方法为 <em>_pack</em> ）.</p>\n<pre><code>var _pack = d3.pack()\n    .size([w, h])\n    .padding(3);\n</code></pre><p>调用 <em>_pack()</em> 方法，可以为树状结构数据计算出坐标值（包括x／y/r这些属性值）。</p>\n<pre><code>// root为树状结构数据，由d3.hierarchy()或者d3.stratify()方法生成。\n_pack(root);\n</code></pre><ul>\n<li>背景色</li>\n</ul>\n<pre><code>var _colors = d3.scaleSequential(d3.interpolateMagma)\n    .domain([-4, 4]);\n</code></pre><ul>\n<li>剪切</li>\n</ul>\n<p>由于圆圈内的text文本可能超出范围，为避免这种情况出现，就可以使用svg的剪切功能。</p>\n<pre><code>circle-id\nclipPath\n    - use(&#39;xlink:href&#39;, &#39;#circle-id&#39;)\n    - id: pack-clip-id\ntext\n    - attr(&#39;clip-path&#39;, &#39;url(#pack-clip-id)&#39;)\n</code></pre><ul>\n<li>hover</li>\n</ul>\n<p>d3支持svg的事件。使用 <em>mouseover</em> 和 <em>mouseout</em> 来模拟hover。</p>\n<pre><code>packEnters.each(function (d) {\n        d.node = this;\n    }).on(&#39;mouseover&#39;, hovered(true))\n        .on(&#39;mouseout&#39;, hovered(false));\n    function hovered (hover) {\n        return (d) =&gt; {\n            d3.selectAll(d.ancestors().map(function (d) {\n                return d.node;\n            })).classed(&#39;pack-node-hover&#39;, hover);\n        }\n    };\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1、树图\"><a href=\"#1、树图\" class=\"headerlink\" title=\"1、树图\"></a>1、树图</h1><h2 id=\"1-1、简介\"><a href=\"#1-1、简介\" class=\"headerlink\" title=\"1.1、简介\"></a>1.1、简介</h2><p>能够展现不同数据元素之间的依赖。树图中，两个节点之间只有一条路径相互连接彼此。</p>\n<h2 id=\"1-2-构建树图\"><a href=\"#1-2-构建树图\" class=\"headerlink\" title=\"1.2 构建树图\"></a>1.2 构建树图</h2><ul>\n<li>数据</li>\n</ul>\n<p>树图的数据，仍然使用d3.hierarchy()或者d3.stratify()生成的数据。（见9-1）</p>\n<ul>\n<li>布局</li>\n</ul>\n<p>树图的布局，使用d3.tree()这个方法。d3.tree()是一个工厂方法，根据设置生成一个可以用于布局的方法（假设为 <em>_tree</em> ）。 </p>\n<p><em>_tree()</em> 方法接收一个参数，即d3.hierarchy()或者d3.stratify()生成的数据座位参数。方法执行后，就往参数对象中回填x/y坐标数据。</p>\n<pre><code>var _tree = d3.tree()\n        .size([w, h - 80]);\n// root为d3.hierarchy()或者d3.stratify()方法生成的树状结构数据\n_tree(root);\n</code></pre><ul>\n<li>画圆圈、文本</li>\n</ul>\n<p>由于树状结构数据不是一个数组，而我们在画圆圈、或者现实文本的时候需要一个数组，所以需要将root转化为数组。使用 <em>root.descendants()</em> 方法转化。</p>\n<p>画圆圈、添加文本按正常的d3添加circle、text元素即可。</p>\n<pre><code>const nodes = root.descendants();\n</code></pre><ul>\n<li>画连线</li>\n</ul>\n<p>画竖线使用 <em>d3.linkVertical()</em> 方法，画横线使用 <em>d3.linkHorizonal()</em> 方法。这两个方法的返回值，都有x、y两个属性方法，把上一步中的树状结构节点中生存的x、y值传入即可。（x、y值已经使用d3.tree()(root)计算出来）。</p>\n<p>而连线的数据需要调用 <em>_tree(root).links()</em> 方法获取。</p>\n<p>具体代码如下：</p>\n<pre><code>// 画线\nconst linkFn = isVertical ? d3.linkVertical()\n        .x(function (d) { return d.x; })\n        .y(function (d) { return d.y; })\n        : d3.linkHorizontal()\n            .x(function (d) { return d.y; })\n            .y(function (d) { return d.x; })\n\n_bodyG.selectAll(&#39;.link&#39;)\n        .data(_tree(root).links())\n        .enter()\n        .append(&#39;path&#39;)\n        .attr(&#39;class&#39;, &#39;link&#39;)\n        .attr(&#39;d&#39;, linkFn);\n</code></pre><p>2、封闭图</p>\n<p>封闭图跟创建树图的步骤基本一致。下面只总结一下封闭图的不同知识点。</p>\n<ul>\n<li>布局</li>\n</ul>\n<p>布局使用 <em>d3.pack()</em> 方法，这是一个工厂方法。根据设置可以生成一个可以用于布局封闭图的方法（假设生成的方法为 <em>_pack</em> ）.</p>\n<pre><code>var _pack = d3.pack()\n    .size([w, h])\n    .padding(3);\n</code></pre><p>调用 <em>_pack()</em> 方法，可以为树状结构数据计算出坐标值（包括x／y/r这些属性值）。</p>\n<pre><code>// root为树状结构数据，由d3.hierarchy()或者d3.stratify()方法生成。\n_pack(root);\n</code></pre><ul>\n<li>背景色</li>\n</ul>\n<pre><code>var _colors = d3.scaleSequential(d3.interpolateMagma)\n    .domain([-4, 4]);\n</code></pre><ul>\n<li>剪切</li>\n</ul>\n<p>由于圆圈内的text文本可能超出范围，为避免这种情况出现，就可以使用svg的剪切功能。</p>\n<pre><code>circle-id\nclipPath\n    - use(&#39;xlink:href&#39;, &#39;#circle-id&#39;)\n    - id: pack-clip-id\ntext\n    - attr(&#39;clip-path&#39;, &#39;url(#pack-clip-id)&#39;)\n</code></pre><ul>\n<li>hover</li>\n</ul>\n<p>d3支持svg的事件。使用 <em>mouseover</em> 和 <em>mouseout</em> 来模拟hover。</p>\n<pre><code>packEnters.each(function (d) {\n        d.node = this;\n    }).on(&#39;mouseover&#39;, hovered(true))\n        .on(&#39;mouseout&#39;, hovered(false));\n    function hovered (hover) {\n        return (d) =&gt; {\n            d3.selectAll(d.ancestors().map(function (d) {\n                return d.node;\n            })).classed(&#39;pack-node-hover&#39;, hover);\n        }\n    };\n</code></pre>"},{"title":"hexo-record","date":"2018-01-10T03:01:19.000Z","_content":"\n在使用hexo的过程中，会不断地遇到一些需要解决的问题或者添加一些新特性，发现这是一个持续渐进的过程。所以一一记录在这里，方便查阅。\n\n# 1、图片资源\n\n在官方文档中，要添加资源，给出的使用方式是,先修改_config.yml配置文件post_asset_folder属性，然后使用 asset_img 标签。\n\n{% codeblock %}\n_config.yml\npost_asset_folder: true\n{% endcodeblock %}\n\n&#123;&#37; asset_img slug [title] &#37;&#125;\n\n但是一直没有成功。解决方式是，添加一个hexo-asset-image插件，然后使用markdown的\\!\\[alt\\]\\(path\\)语法来添加。同样，post_asset_folder属性也需要设置为true。\n\n## 1.1 安装插件\n在命令行工具中，进入到hexo项目的根目录，执行如下命令:\n{% codeblock %}\n> npm install -S hexo-asset-image\n{% endcodeblock %}\n\n## 1.2 使用注意\n加入我们使用hexo new \"blog-name\"添加了一篇名字为\"blog-name\"的博客，那么也会生成一个blog-name命名的文件夹，在这个文件夹中添加资源文件即可。在使用\\!\\[alt\\]\\(path\\)引用时，path直接写资源文件名称即可。\n    假如有如下的目录结构：\n{% codeblock %}\n|- _posts\n |- blog-name\n  |- hexo-asset.png\n |- blog-name.md\n{% endcodeblock %}\n那在blog-name.md中引用hexo-asset.png时，直接写名字即可。\n{% codeblock %}\n![alt](hexo-asset.png)\n{% endcodeblock %}\n\n# 2、流程图\n\n使用hexo写博客的时候，会遇到需要添加流程图的地方，简单粗暴的方式就是使用其他的画图软件画好后截图然后通过图片的方式引入。不过，在hexo里面，我们也可以通过编码的方式实现流程图。这就需要用到\"hexo-filter-mermaid-diagrams\"插件。\n\n## 2.1 安装插件\n在命令行工具中，进入到hexo项目的根目录，执行如下命令:\n{% codeblock %}\n> npm install -S hexo-filter-mermaid-diagrams\n{% endcodeblock %}\n\n## 2.2 添加配置\n在_config.yml文件中添加如下配置：\n{% codeblock %}\n# mermaid chart\nmermaid: ## mermaid url https://github.com/knsv/mermaid\n  enable: true  # default true\n  version: \"7.1.2\" # default v7.1.2\n  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js\n    #startOnload: true  // default true\n{% endcodeblock %}\n这段配置就告诉hexo启用hexo-filter-mermaid-diagrams插件。但是这还不行，我们还需要在主题文件中添加加载css和js的代码。以在themes/landscape/layout/_partial/after-footer.ejs中添加为例。\n{% codeblock %}\n// themes/landscape/layout/_partial/after-footer.ejs\n<% if (theme.mermaid.enable) { %>\n    <script src='https://cdn.bootcss.com/mermaid/<%= theme.mermaid.version %>/mermaid.min.js'></script>\n    <script>\n      if (window.mermaid) {\n        mermaid.initialize({theme: 'forest'});\n      }\n    </script>\n  <% } %>\n{% endcodeblock %}\n    hexo模板引擎在解析这段代码的时候，会判断theme.mermaid.enable是否为true（即我们第一步的配置）。如果启用，会将<%= theme.mermaid.version %>替换为配置中的版本号。\n    \n## 2.3 使用流程图\n\n\\`\\`\\`mermaid\ngraph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;\n\\`\\`\\` \n\n结果如下：\n```mermaid\ngraph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;\n``` \n# 3、代码高亮\n\nhexo本身是有代码高亮功能的，如果不喜欢，可以添加其他的高亮方式。添加其他的高亮方式。我们这里以添加highlight.min.js为例。\n首先在_config.yml中将hexo本身的代码高亮关闭。\n\n{% codeblock %}\n// _config.yml\nhighlight:\n  enable: false\n{% endcodeblock %}\n\n然后在主题中添加如下代码：\n\n{% codeblock %}\n// themes/landscape/layout/_partial/after-footer.ejs\n<link rel=\"stylesheet\" href=\"//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css\">\n<script src=\"//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js\"></script>\n<script>\n(function(){\n  hljs.initHighlightingOnLoad();\n}())\n</script>\n{% endcodeblock %}","source":"_posts/hexo-record-20190110.md","raw":"---\ntitle: hexo-record\ndate: 2018-01-10 11:01:19\ntags: hexo \n---\n\n在使用hexo的过程中，会不断地遇到一些需要解决的问题或者添加一些新特性，发现这是一个持续渐进的过程。所以一一记录在这里，方便查阅。\n\n# 1、图片资源\n\n在官方文档中，要添加资源，给出的使用方式是,先修改_config.yml配置文件post_asset_folder属性，然后使用 asset_img 标签。\n\n{% codeblock %}\n_config.yml\npost_asset_folder: true\n{% endcodeblock %}\n\n&#123;&#37; asset_img slug [title] &#37;&#125;\n\n但是一直没有成功。解决方式是，添加一个hexo-asset-image插件，然后使用markdown的\\!\\[alt\\]\\(path\\)语法来添加。同样，post_asset_folder属性也需要设置为true。\n\n## 1.1 安装插件\n在命令行工具中，进入到hexo项目的根目录，执行如下命令:\n{% codeblock %}\n> npm install -S hexo-asset-image\n{% endcodeblock %}\n\n## 1.2 使用注意\n加入我们使用hexo new \"blog-name\"添加了一篇名字为\"blog-name\"的博客，那么也会生成一个blog-name命名的文件夹，在这个文件夹中添加资源文件即可。在使用\\!\\[alt\\]\\(path\\)引用时，path直接写资源文件名称即可。\n    假如有如下的目录结构：\n{% codeblock %}\n|- _posts\n |- blog-name\n  |- hexo-asset.png\n |- blog-name.md\n{% endcodeblock %}\n那在blog-name.md中引用hexo-asset.png时，直接写名字即可。\n{% codeblock %}\n![alt](hexo-asset.png)\n{% endcodeblock %}\n\n# 2、流程图\n\n使用hexo写博客的时候，会遇到需要添加流程图的地方，简单粗暴的方式就是使用其他的画图软件画好后截图然后通过图片的方式引入。不过，在hexo里面，我们也可以通过编码的方式实现流程图。这就需要用到\"hexo-filter-mermaid-diagrams\"插件。\n\n## 2.1 安装插件\n在命令行工具中，进入到hexo项目的根目录，执行如下命令:\n{% codeblock %}\n> npm install -S hexo-filter-mermaid-diagrams\n{% endcodeblock %}\n\n## 2.2 添加配置\n在_config.yml文件中添加如下配置：\n{% codeblock %}\n# mermaid chart\nmermaid: ## mermaid url https://github.com/knsv/mermaid\n  enable: true  # default true\n  version: \"7.1.2\" # default v7.1.2\n  options:  # find more api options from https://github.com/knsv/mermaid/blob/master/src/mermaidAPI.js\n    #startOnload: true  // default true\n{% endcodeblock %}\n这段配置就告诉hexo启用hexo-filter-mermaid-diagrams插件。但是这还不行，我们还需要在主题文件中添加加载css和js的代码。以在themes/landscape/layout/_partial/after-footer.ejs中添加为例。\n{% codeblock %}\n// themes/landscape/layout/_partial/after-footer.ejs\n<% if (theme.mermaid.enable) { %>\n    <script src='https://cdn.bootcss.com/mermaid/<%= theme.mermaid.version %>/mermaid.min.js'></script>\n    <script>\n      if (window.mermaid) {\n        mermaid.initialize({theme: 'forest'});\n      }\n    </script>\n  <% } %>\n{% endcodeblock %}\n    hexo模板引擎在解析这段代码的时候，会判断theme.mermaid.enable是否为true（即我们第一步的配置）。如果启用，会将<%= theme.mermaid.version %>替换为配置中的版本号。\n    \n## 2.3 使用流程图\n\n\\`\\`\\`mermaid\ngraph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;\n\\`\\`\\` \n\n结果如下：\n```mermaid\ngraph TD;\n    A-->B;\n    A-->C;\n    B-->D;\n    C-->D;\n``` \n# 3、代码高亮\n\nhexo本身是有代码高亮功能的，如果不喜欢，可以添加其他的高亮方式。添加其他的高亮方式。我们这里以添加highlight.min.js为例。\n首先在_config.yml中将hexo本身的代码高亮关闭。\n\n{% codeblock %}\n// _config.yml\nhighlight:\n  enable: false\n{% endcodeblock %}\n\n然后在主题中添加如下代码：\n\n{% codeblock %}\n// themes/landscape/layout/_partial/after-footer.ejs\n<link rel=\"stylesheet\" href=\"//cdn.bootcss.com/highlight.js/9.2.0/styles/github.min.css\">\n<script src=\"//cdn.bootcss.com/highlight.js/9.2.0/highlight.min.js\"></script>\n<script>\n(function(){\n  hljs.initHighlightingOnLoad();\n}())\n</script>\n{% endcodeblock %}","slug":"hexo-record","published":1,"updated":"2019-01-10T03:54:21.799Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvoop000a4c410ym7xs62","content":"<p>在使用hexo的过程中，会不断地遇到一些需要解决的问题或者添加一些新特性，发现这是一个持续渐进的过程。所以一一记录在这里，方便查阅。</p>\n<h1 id=\"1、图片资源\"><a href=\"#1、图片资源\" class=\"headerlink\" title=\"1、图片资源\"></a>1、图片资源</h1><p>在官方文档中，要添加资源，给出的使用方式是,先修改_config.yml配置文件post_asset_folder属性，然后使用 asset_img 标签。</p>\n<pre><code>_config.yml\npost_asset_folder: true</code></pre>\n<p>&#123;&#37; asset_img slug [title] &#37;&#125;</p>\n<p>但是一直没有成功。解决方式是，添加一个hexo-asset-image插件，然后使用markdown的![alt](path)语法来添加。同样，post_asset_folder属性也需要设置为true。</p>\n<h2 id=\"1-1-安装插件\"><a href=\"#1-1-安装插件\" class=\"headerlink\" title=\"1.1 安装插件\"></a>1.1 安装插件</h2><p>在命令行工具中，进入到hexo项目的根目录，执行如下命令:<br><pre><code>&gt; npm install -S hexo-asset-image</code></pre></p>\n<h2 id=\"1-2-使用注意\"><a href=\"#1-2-使用注意\" class=\"headerlink\" title=\"1.2 使用注意\"></a>1.2 使用注意</h2><p>加入我们使用hexo new “blog-name”添加了一篇名字为”blog-name”的博客，那么也会生成一个blog-name命名的文件夹，在这个文件夹中添加资源文件即可。在使用![alt](path)引用时，path直接写资源文件名称即可。<br>    假如有如下的目录结构：<br><pre><code>|- _posts\n |- blog-name\n  |- hexo-asset.png\n |- blog-name.md</code></pre><br>那在blog-name.md中引用hexo-asset.png时，直接写名字即可。<br><pre><code>![alt](hexo-asset.png)</code></pre></p>\n<h1 id=\"2、流程图\"><a href=\"#2、流程图\" class=\"headerlink\" title=\"2、流程图\"></a>2、流程图</h1><p>使用hexo写博客的时候，会遇到需要添加流程图的地方，简单粗暴的方式就是使用其他的画图软件画好后截图然后通过图片的方式引入。不过，在hexo里面，我们也可以通过编码的方式实现流程图。这就需要用到”hexo-filter-mermaid-diagrams”插件。</p>\n<h2 id=\"2-1-安装插件\"><a href=\"#2-1-安装插件\" class=\"headerlink\" title=\"2.1 安装插件\"></a>2.1 安装插件</h2><p>在命令行工具中，进入到hexo项目的根目录，执行如下命令:<br><pre><code>&gt; npm install -S hexo-filter-mermaid-diagrams</code></pre></p>\n<h2 id=\"2-2-添加配置\"><a href=\"#2-2-添加配置\" class=\"headerlink\" title=\"2.2 添加配置\"></a>2.2 添加配置</h2><p>在_config.yml文件中添加如下配置：<br><pre><code># mermaid chart\nmermaid: ## mermaid url https:&#x2F;&#x2F;github.com&#x2F;knsv&#x2F;mermaid\n  enable: true  # default true\n  version: &quot;7.1.2&quot; # default v7.1.2\n  options:  # find more api options from https:&#x2F;&#x2F;github.com&#x2F;knsv&#x2F;mermaid&#x2F;blob&#x2F;master&#x2F;src&#x2F;mermaidAPI.js\n    #startOnload: true  &#x2F;&#x2F; default true</code></pre><br>这段配置就告诉hexo启用hexo-filter-mermaid-diagrams插件。但是这还不行，我们还需要在主题文件中添加加载css和js的代码。以在themes/landscape/layout/_partial/after-footer.ejs中添加为例。<br><pre><code>&#x2F;&#x2F; themes&#x2F;landscape&#x2F;layout&#x2F;_partial&#x2F;after-footer.ejs\n&lt;% if (theme.mermaid.enable) { %&gt;\n    &lt;script src=&#39;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;mermaid&#x2F;&lt;%= theme.mermaid.version %&gt;&#x2F;mermaid.min.js&#39;&gt;&lt;&#x2F;script&gt;\n    &lt;script&gt;\n      if (window.mermaid) {\n        mermaid.initialize({theme: &#39;forest&#39;});\n      }\n    &lt;&#x2F;script&gt;\n  &lt;% } %&gt;</code></pre><br>    hexo模板引擎在解析这段代码的时候，会判断theme.mermaid.enable是否为true（即我们第一步的配置）。如果启用，会将&lt;%= theme.mermaid.version %&gt;替换为配置中的版本号。</p>\n<h2 id=\"2-3-使用流程图\"><a href=\"#2-3-使用流程图\" class=\"headerlink\" title=\"2.3 使用流程图\"></a>2.3 使用流程图</h2><p>```mermaid<br>graph TD;<br>    A–&gt;B;<br>    A–&gt;C;<br>    B–&gt;D;<br>    C–&gt;D;<br>``` </p>\n<p>结果如下：</p>\n<pre><code class=\"mermaid\">graph TD;\n    A--&gt;B;\n    A--&gt;C;\n    B--&gt;D;\n    C--&gt;D;\n</code></pre>\n<h1 id=\"3、代码高亮\"><a href=\"#3、代码高亮\" class=\"headerlink\" title=\"3、代码高亮\"></a>3、代码高亮</h1><p>hexo本身是有代码高亮功能的，如果不喜欢，可以添加其他的高亮方式。添加其他的高亮方式。我们这里以添加highlight.min.js为例。<br>首先在_config.yml中将hexo本身的代码高亮关闭。</p>\n<pre><code>&#x2F;&#x2F; _config.yml\nhighlight:\n  enable: false</code></pre>\n<p>然后在主题中添加如下代码：</p>\n<pre><code>&#x2F;&#x2F; themes&#x2F;landscape&#x2F;layout&#x2F;_partial&#x2F;after-footer.ejs\n&lt;link rel=&quot;stylesheet&quot; href=&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;highlight.js&#x2F;9.2.0&#x2F;styles&#x2F;github.min.css&quot;&gt;\n&lt;script src=&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;highlight.js&#x2F;9.2.0&#x2F;highlight.min.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n(function(){\n  hljs.initHighlightingOnLoad();\n}())\n&lt;&#x2F;script&gt;</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>在使用hexo的过程中，会不断地遇到一些需要解决的问题或者添加一些新特性，发现这是一个持续渐进的过程。所以一一记录在这里，方便查阅。</p>\n<h1 id=\"1、图片资源\"><a href=\"#1、图片资源\" class=\"headerlink\" title=\"1、图片资源\"></a>1、图片资源</h1><p>在官方文档中，要添加资源，给出的使用方式是,先修改_config.yml配置文件post_asset_folder属性，然后使用 asset_img 标签。</p>\n<pre><code>_config.yml\npost_asset_folder: true</code></pre>\n<p>&#123;&#37; asset_img slug [title] &#37;&#125;</p>\n<p>但是一直没有成功。解决方式是，添加一个hexo-asset-image插件，然后使用markdown的![alt](path)语法来添加。同样，post_asset_folder属性也需要设置为true。</p>\n<h2 id=\"1-1-安装插件\"><a href=\"#1-1-安装插件\" class=\"headerlink\" title=\"1.1 安装插件\"></a>1.1 安装插件</h2><p>在命令行工具中，进入到hexo项目的根目录，执行如下命令:<br><pre><code>&gt; npm install -S hexo-asset-image</code></pre></p>\n<h2 id=\"1-2-使用注意\"><a href=\"#1-2-使用注意\" class=\"headerlink\" title=\"1.2 使用注意\"></a>1.2 使用注意</h2><p>加入我们使用hexo new “blog-name”添加了一篇名字为”blog-name”的博客，那么也会生成一个blog-name命名的文件夹，在这个文件夹中添加资源文件即可。在使用![alt](path)引用时，path直接写资源文件名称即可。<br>    假如有如下的目录结构：<br><pre><code>|- _posts\n |- blog-name\n  |- hexo-asset.png\n |- blog-name.md</code></pre><br>那在blog-name.md中引用hexo-asset.png时，直接写名字即可。<br><pre><code>![alt](hexo-asset.png)</code></pre></p>\n<h1 id=\"2、流程图\"><a href=\"#2、流程图\" class=\"headerlink\" title=\"2、流程图\"></a>2、流程图</h1><p>使用hexo写博客的时候，会遇到需要添加流程图的地方，简单粗暴的方式就是使用其他的画图软件画好后截图然后通过图片的方式引入。不过，在hexo里面，我们也可以通过编码的方式实现流程图。这就需要用到”hexo-filter-mermaid-diagrams”插件。</p>\n<h2 id=\"2-1-安装插件\"><a href=\"#2-1-安装插件\" class=\"headerlink\" title=\"2.1 安装插件\"></a>2.1 安装插件</h2><p>在命令行工具中，进入到hexo项目的根目录，执行如下命令:<br><pre><code>&gt; npm install -S hexo-filter-mermaid-diagrams</code></pre></p>\n<h2 id=\"2-2-添加配置\"><a href=\"#2-2-添加配置\" class=\"headerlink\" title=\"2.2 添加配置\"></a>2.2 添加配置</h2><p>在_config.yml文件中添加如下配置：<br><pre><code># mermaid chart\nmermaid: ## mermaid url https:&#x2F;&#x2F;github.com&#x2F;knsv&#x2F;mermaid\n  enable: true  # default true\n  version: &quot;7.1.2&quot; # default v7.1.2\n  options:  # find more api options from https:&#x2F;&#x2F;github.com&#x2F;knsv&#x2F;mermaid&#x2F;blob&#x2F;master&#x2F;src&#x2F;mermaidAPI.js\n    #startOnload: true  &#x2F;&#x2F; default true</code></pre><br>这段配置就告诉hexo启用hexo-filter-mermaid-diagrams插件。但是这还不行，我们还需要在主题文件中添加加载css和js的代码。以在themes/landscape/layout/_partial/after-footer.ejs中添加为例。<br><pre><code>&#x2F;&#x2F; themes&#x2F;landscape&#x2F;layout&#x2F;_partial&#x2F;after-footer.ejs\n&lt;% if (theme.mermaid.enable) { %&gt;\n    &lt;script src=&#39;https:&#x2F;&#x2F;cdn.bootcss.com&#x2F;mermaid&#x2F;&lt;%= theme.mermaid.version %&gt;&#x2F;mermaid.min.js&#39;&gt;&lt;&#x2F;script&gt;\n    &lt;script&gt;\n      if (window.mermaid) {\n        mermaid.initialize({theme: &#39;forest&#39;});\n      }\n    &lt;&#x2F;script&gt;\n  &lt;% } %&gt;</code></pre><br>    hexo模板引擎在解析这段代码的时候，会判断theme.mermaid.enable是否为true（即我们第一步的配置）。如果启用，会将&lt;%= theme.mermaid.version %&gt;替换为配置中的版本号。</p>\n<h2 id=\"2-3-使用流程图\"><a href=\"#2-3-使用流程图\" class=\"headerlink\" title=\"2.3 使用流程图\"></a>2.3 使用流程图</h2><p>```mermaid<br>graph TD;<br>    A–&gt;B;<br>    A–&gt;C;<br>    B–&gt;D;<br>    C–&gt;D;<br>``` </p>\n<p>结果如下：</p>\n<pre><code class=\"mermaid\">graph TD;\n    A--&gt;B;\n    A--&gt;C;\n    B--&gt;D;\n    C--&gt;D;\n</code></pre>\n<h1 id=\"3、代码高亮\"><a href=\"#3、代码高亮\" class=\"headerlink\" title=\"3、代码高亮\"></a>3、代码高亮</h1><p>hexo本身是有代码高亮功能的，如果不喜欢，可以添加其他的高亮方式。添加其他的高亮方式。我们这里以添加highlight.min.js为例。<br>首先在_config.yml中将hexo本身的代码高亮关闭。</p>\n<pre><code>&#x2F;&#x2F; _config.yml\nhighlight:\n  enable: false</code></pre>\n<p>然后在主题中添加如下代码：</p>\n<pre><code>&#x2F;&#x2F; themes&#x2F;landscape&#x2F;layout&#x2F;_partial&#x2F;after-footer.ejs\n&lt;link rel=&quot;stylesheet&quot; href=&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;highlight.js&#x2F;9.2.0&#x2F;styles&#x2F;github.min.css&quot;&gt;\n&lt;script src=&quot;&#x2F;&#x2F;cdn.bootcss.com&#x2F;highlight.js&#x2F;9.2.0&#x2F;highlight.min.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;script&gt;\n(function(){\n  hljs.initHighlightingOnLoad();\n}())\n&lt;&#x2F;script&gt;</code></pre>"},{"title":"python3+nginx+uwsgi+django环境搭建（Centos）","date":"2019-07-26T22:49:10.000Z","_content":"\n# 1、python3环境安装\n\n默认的云服务器上安装python版本现在是2.7的版本。如果新开发的应用，使用了python3，由于语法上的不向后兼容，必须得在服务器上安装python3。\n\n## (1)、安装编译环境包\n\n```\nyum install gcc-c++ gcc make cmake zlib-devel bzip2-devel openssl-devel ncurse-devel -y\n```\n\n## (2)、下载3.7源代码\n\n```shell\ncd ~\nwget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz\n```\n\n如果wget命令不存在，使用yum安装：\n```\nyum -y install wget\n```\n\n## (3)、解压、配置、安装\n\n```shell\n# 解压\ntar Jxvf Python-3.7.0.tar.xz\ncd Python-3.7.0\n# 创建安装目录\nmkdir -p /usr/local/python3\n#配置（指定安装目录）\n./configure --prefix=/usr/local/python3 --enable-optimizations\nmake && make install\n```\n\n在make && make install这一步，有可能出现“ModuleNotFoundError: No module named '_ctypes'”的错误。\n此时我们把libffi-devel安装上，然后再执行make && make install即可。\n\n```\nyum install libffi-devel -y\n```\n\n## (4)、创建python3软链接\n\n```\nln -s /usr/local/python3/bin/python3.7 /usr/bin/python3\nln -s /usr/local/python3/bin/pip3.7 /usr/bin/pip3\n```\n\n## (5)、检查\n\n```\npython3 -V\n```\n\n如果出现3.7.0版本，说明安装成功。\n\n![Python3.7-success](python3-success.png)\n\n# 2、uwsgi安装\n\n```shell\npip3 install uwsgi\n#创建uwsgi3的软链接，和python2的区分开来\nln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi3\n#查看 uwsgi 版本\nuwsgi3 --version\n```\n\n检测uwsgi是否正常：\n新建 /www/test.py 文件，输入如下内容：\n```python\ndef application(env, start_response):\n    start_response('200 OK', [('Content-Type','text/html')])\n    return [b\"Hello uwsgi\"]\n```\n\n然后在终端运行：\n```\nuwsgi3 --http :8001 --wsgi-file test.py\n```\n在浏览器中输入 http://127.0.0.1:8001 , 看看是否有”Hello uwsgi“的字样输出。如果没有看看报错信息，据此来查找解决方案。\n\n# 3、django安装\n\n```shell\npip3 install django\n```\n\n测试 django 是否正常，运行：\n\n```shell\nmkdir /www\ncd /www\n# 这里需要注意django-admin.py的位置，当提示命令不存在时，使用find命令全局查找一下\n# find / -name \"*django-admin.py*\"\n/usr/local/python3/bin/django-admin.py startproject demosite\ncd demosite\npython3 manage.py runserver 0.0.0.0:8002\n```\n启动成功，在浏览器内输入：http://127.0.0.1:8002 ,检查django是否运行正常。\n\n不过，如果报错\"ModuleNotFoundError: No module named '_sqlite3'\"。我们还是要忍着处理一下（毕竟这么多步骤下来，挨了不少坑了）。这里网上很多的答案是去\"yum install sqlite-devel\",然后再次编译python3。但是你这么做之后，启动django发现它报错提示说要求3.8及以上的版本。所以这里我们一步到位地解决掉它，我们直接安装高级版本的sqlite3。\n\n```shell\ncd ~\nwget https://www.sqlite.org/2019/sqlite-autoconf-3290000.tar.gz\n# 解压\ntar zxvf sqlite-autoconf-3290000.tar.gz\ncd sqlite-autoconf-3290000\n./configure --prefix=/usr/local/sqlite3 --disable-static --enable-fts5 --enable-json1 CFLAGS=\"-g -O2 -DSQLITE_ENABLE_FTS3=1 -DSQLITE_ENABLE_FTS4=1 -DSQLITE_ENABLE_RTREE=1\"\nmake && make install\n```\n\n对Python3.7再进行编译：\n```\ncd ~/Python-3.7.0\nLD_RUN_PATH=/usr/local/sqlite3/lib ./configure --prefix=/usr/local/python3 --enable-optimizations LDFLAGS=\"-L/usr/local/sqlite3/lib\" CPPFLAGS=\"-I /usr/local/sqlite3/include\" \nLD_RUN_PATH=/usr/local/sqlite3/lib make\nLD_RUN_PATH=/usr/local/sqlite3/lib make install\n```\n\n检查是否安装成功：\n![sqlite3-success](sqlite3.png)\n\n成功后，在去启动demosite，应该就没问题啦。\n\n```\ncd /www/demosite\npython3 manage.py runserver 0.0.0.0:8002\n```\n\n# 4、nginx安装\n\n```shell\ncd ~\nwget http://nginx.org/download/nginx-1.9.9.tar.gz \ntar xzvf nginx-1.9.9.tar.gz \ncd nginx-1.9.9\n# 配置（指定安装目录）\n./configure --prefix=/usr/local/nginx-1.9.9 --with-http_stub_status_module  --with-http_gzip_static_module\nmake && make install\n# 检查是否成功\n/usr/local/nginx-1.9.9/sbin/nginx -V\n# 建立软连接\nln -s /usr/local/nginx-1.9.9/sbin/nginx /usr/bin/nginx\n```\n\n## （1）uwsgi配置\n\n在/etc目录下创建uwsgi9090.ini文件，输入如下内容：\n\n```shell\n[uwsgi]\nsocket = 127.0.0.1:9090\nmaster = true         #主进程\nvhost = true          #多站模式\nno-site = true        #多站模式时不设置入口模块和文件\nworkers = 2           #子进程数\nreload-mercy = 10     \nvacuum = true         #退出、重启时清理文件\nmax-requests = 1000   \nlimit-as = 512\nbuffer-size = 30000\npythonpath = /usr/local/python3/lib/python3.7/site-packages\npidfile = /var/run/uwsgi9090.pid    #pid文件，用于下面的脚本启动、停止该进程\ndaemonize = /www/uwsgi9090.log\n```\n\nPS:注意上面pythonpath的配置，很多网上的文章没有这个，所以我们的环境里面有python2和python3的时候，uwsgi启动就默认找python2下面的django，所以会出现找不到django的问题\"ModuleNotFoundError: No module named 'django'\"。\n\n## (2) Nginx配置\n\n找到nginx的安装目录（如：/usr/local/nginx/），打开conf/nginx.conf文件，修改server配置：\n\n```shell\nserver {\n        listen       80;\n        server_name  localhost;\n        \n        location / {            \n            include  uwsgi_params;\n            uwsgi_pass  127.0.0.1:9090;              #必须和uwsgi中的设置一致\n            uwsgi_param UWSGI_SCRIPT demosite.wsgi;  #入口文件，即wsgi.py相对于项目根目录的位置，“.”相当于一层目录\n            uwsgi_param UWSGI_CHDIR /www/demosite;       #项目根目录\n            index  index.html index.htm;\n            client_max_body_size 35m;\n        }\n    }\n```\n\n设置完成后，在终端运行：\n```shell\nuwsgi --ini /etc/uwsgi9090.ini & /usr/local/nginx/sbin/nginx\n```\n浏览器输入：http://127.0.0.1，你就可以看到 django 的界面了。如下：\n\n![django-success](django-success.png)\n\n\n## (3)、补充\n\n在弄环境的过程中，难免会遇到问题，所以对服务的启动停止也很正常，补充一些命令\n\n```shell\n# nginx 检查配置文件是否正确\nnginx -t\n# 重启nginx\nnginx -s reload\n```\n\n```shell\n# 停止uwsgi\nuwsgi3 --stop /var/run/uwsgi9090.pid\n```\n\n# 5、参考文章\n1. 【Django Nginx+uwsgi 安装配置】 https://www.runoob.com/django/django-nginx-uwsgi.html\n2. 【Centos 7升级原python 2.7.5至Python 3.7】 https://blog.51cto.com/10316297/2134736?from=timeline\n3. 【Python3以上版本安装sqlite3的解决方案】 https://www.jianshu.com/p/4b5ba514e0a4","source":"_posts/python3-nginx-uwsgi-20190727.md","raw":"---\ntitle: python3+nginx+uwsgi+django环境搭建（Centos）\ndate: 2019-07-27 06:49:10\ntags: python, nginx, uwsgi, django\n---\n\n# 1、python3环境安装\n\n默认的云服务器上安装python版本现在是2.7的版本。如果新开发的应用，使用了python3，由于语法上的不向后兼容，必须得在服务器上安装python3。\n\n## (1)、安装编译环境包\n\n```\nyum install gcc-c++ gcc make cmake zlib-devel bzip2-devel openssl-devel ncurse-devel -y\n```\n\n## (2)、下载3.7源代码\n\n```shell\ncd ~\nwget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz\n```\n\n如果wget命令不存在，使用yum安装：\n```\nyum -y install wget\n```\n\n## (3)、解压、配置、安装\n\n```shell\n# 解压\ntar Jxvf Python-3.7.0.tar.xz\ncd Python-3.7.0\n# 创建安装目录\nmkdir -p /usr/local/python3\n#配置（指定安装目录）\n./configure --prefix=/usr/local/python3 --enable-optimizations\nmake && make install\n```\n\n在make && make install这一步，有可能出现“ModuleNotFoundError: No module named '_ctypes'”的错误。\n此时我们把libffi-devel安装上，然后再执行make && make install即可。\n\n```\nyum install libffi-devel -y\n```\n\n## (4)、创建python3软链接\n\n```\nln -s /usr/local/python3/bin/python3.7 /usr/bin/python3\nln -s /usr/local/python3/bin/pip3.7 /usr/bin/pip3\n```\n\n## (5)、检查\n\n```\npython3 -V\n```\n\n如果出现3.7.0版本，说明安装成功。\n\n![Python3.7-success](python3-success.png)\n\n# 2、uwsgi安装\n\n```shell\npip3 install uwsgi\n#创建uwsgi3的软链接，和python2的区分开来\nln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi3\n#查看 uwsgi 版本\nuwsgi3 --version\n```\n\n检测uwsgi是否正常：\n新建 /www/test.py 文件，输入如下内容：\n```python\ndef application(env, start_response):\n    start_response('200 OK', [('Content-Type','text/html')])\n    return [b\"Hello uwsgi\"]\n```\n\n然后在终端运行：\n```\nuwsgi3 --http :8001 --wsgi-file test.py\n```\n在浏览器中输入 http://127.0.0.1:8001 , 看看是否有”Hello uwsgi“的字样输出。如果没有看看报错信息，据此来查找解决方案。\n\n# 3、django安装\n\n```shell\npip3 install django\n```\n\n测试 django 是否正常，运行：\n\n```shell\nmkdir /www\ncd /www\n# 这里需要注意django-admin.py的位置，当提示命令不存在时，使用find命令全局查找一下\n# find / -name \"*django-admin.py*\"\n/usr/local/python3/bin/django-admin.py startproject demosite\ncd demosite\npython3 manage.py runserver 0.0.0.0:8002\n```\n启动成功，在浏览器内输入：http://127.0.0.1:8002 ,检查django是否运行正常。\n\n不过，如果报错\"ModuleNotFoundError: No module named '_sqlite3'\"。我们还是要忍着处理一下（毕竟这么多步骤下来，挨了不少坑了）。这里网上很多的答案是去\"yum install sqlite-devel\",然后再次编译python3。但是你这么做之后，启动django发现它报错提示说要求3.8及以上的版本。所以这里我们一步到位地解决掉它，我们直接安装高级版本的sqlite3。\n\n```shell\ncd ~\nwget https://www.sqlite.org/2019/sqlite-autoconf-3290000.tar.gz\n# 解压\ntar zxvf sqlite-autoconf-3290000.tar.gz\ncd sqlite-autoconf-3290000\n./configure --prefix=/usr/local/sqlite3 --disable-static --enable-fts5 --enable-json1 CFLAGS=\"-g -O2 -DSQLITE_ENABLE_FTS3=1 -DSQLITE_ENABLE_FTS4=1 -DSQLITE_ENABLE_RTREE=1\"\nmake && make install\n```\n\n对Python3.7再进行编译：\n```\ncd ~/Python-3.7.0\nLD_RUN_PATH=/usr/local/sqlite3/lib ./configure --prefix=/usr/local/python3 --enable-optimizations LDFLAGS=\"-L/usr/local/sqlite3/lib\" CPPFLAGS=\"-I /usr/local/sqlite3/include\" \nLD_RUN_PATH=/usr/local/sqlite3/lib make\nLD_RUN_PATH=/usr/local/sqlite3/lib make install\n```\n\n检查是否安装成功：\n![sqlite3-success](sqlite3.png)\n\n成功后，在去启动demosite，应该就没问题啦。\n\n```\ncd /www/demosite\npython3 manage.py runserver 0.0.0.0:8002\n```\n\n# 4、nginx安装\n\n```shell\ncd ~\nwget http://nginx.org/download/nginx-1.9.9.tar.gz \ntar xzvf nginx-1.9.9.tar.gz \ncd nginx-1.9.9\n# 配置（指定安装目录）\n./configure --prefix=/usr/local/nginx-1.9.9 --with-http_stub_status_module  --with-http_gzip_static_module\nmake && make install\n# 检查是否成功\n/usr/local/nginx-1.9.9/sbin/nginx -V\n# 建立软连接\nln -s /usr/local/nginx-1.9.9/sbin/nginx /usr/bin/nginx\n```\n\n## （1）uwsgi配置\n\n在/etc目录下创建uwsgi9090.ini文件，输入如下内容：\n\n```shell\n[uwsgi]\nsocket = 127.0.0.1:9090\nmaster = true         #主进程\nvhost = true          #多站模式\nno-site = true        #多站模式时不设置入口模块和文件\nworkers = 2           #子进程数\nreload-mercy = 10     \nvacuum = true         #退出、重启时清理文件\nmax-requests = 1000   \nlimit-as = 512\nbuffer-size = 30000\npythonpath = /usr/local/python3/lib/python3.7/site-packages\npidfile = /var/run/uwsgi9090.pid    #pid文件，用于下面的脚本启动、停止该进程\ndaemonize = /www/uwsgi9090.log\n```\n\nPS:注意上面pythonpath的配置，很多网上的文章没有这个，所以我们的环境里面有python2和python3的时候，uwsgi启动就默认找python2下面的django，所以会出现找不到django的问题\"ModuleNotFoundError: No module named 'django'\"。\n\n## (2) Nginx配置\n\n找到nginx的安装目录（如：/usr/local/nginx/），打开conf/nginx.conf文件，修改server配置：\n\n```shell\nserver {\n        listen       80;\n        server_name  localhost;\n        \n        location / {            \n            include  uwsgi_params;\n            uwsgi_pass  127.0.0.1:9090;              #必须和uwsgi中的设置一致\n            uwsgi_param UWSGI_SCRIPT demosite.wsgi;  #入口文件，即wsgi.py相对于项目根目录的位置，“.”相当于一层目录\n            uwsgi_param UWSGI_CHDIR /www/demosite;       #项目根目录\n            index  index.html index.htm;\n            client_max_body_size 35m;\n        }\n    }\n```\n\n设置完成后，在终端运行：\n```shell\nuwsgi --ini /etc/uwsgi9090.ini & /usr/local/nginx/sbin/nginx\n```\n浏览器输入：http://127.0.0.1，你就可以看到 django 的界面了。如下：\n\n![django-success](django-success.png)\n\n\n## (3)、补充\n\n在弄环境的过程中，难免会遇到问题，所以对服务的启动停止也很正常，补充一些命令\n\n```shell\n# nginx 检查配置文件是否正确\nnginx -t\n# 重启nginx\nnginx -s reload\n```\n\n```shell\n# 停止uwsgi\nuwsgi3 --stop /var/run/uwsgi9090.pid\n```\n\n# 5、参考文章\n1. 【Django Nginx+uwsgi 安装配置】 https://www.runoob.com/django/django-nginx-uwsgi.html\n2. 【Centos 7升级原python 2.7.5至Python 3.7】 https://blog.51cto.com/10316297/2134736?from=timeline\n3. 【Python3以上版本安装sqlite3的解决方案】 https://www.jianshu.com/p/4b5ba514e0a4","slug":"python3-nginx-uwsgi","published":1,"updated":"2019-07-30T02:18:03.267Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvop2000i4c41tv0q8jtk","content":"<h1 id=\"1、python3环境安装\"><a href=\"#1、python3环境安装\" class=\"headerlink\" title=\"1、python3环境安装\"></a>1、python3环境安装</h1><p>默认的云服务器上安装python版本现在是2.7的版本。如果新开发的应用，使用了python3，由于语法上的不向后兼容，必须得在服务器上安装python3。</p>\n<h2 id=\"1-、安装编译环境包\"><a href=\"#1-、安装编译环境包\" class=\"headerlink\" title=\"(1)、安装编译环境包\"></a>(1)、安装编译环境包</h2><pre><code>yum install gcc-c++ gcc make cmake zlib-devel bzip2-devel openssl-devel ncurse-devel -y\n</code></pre><h2 id=\"2-、下载3-7源代码\"><a href=\"#2-、下载3-7源代码\" class=\"headerlink\" title=\"(2)、下载3.7源代码\"></a>(2)、下载3.7源代码</h2><pre><code class=\"shell\">cd ~\nwget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz\n</code></pre>\n<p>如果wget命令不存在，使用yum安装：</p>\n<pre><code>yum -y install wget\n</code></pre><h2 id=\"3-、解压、配置、安装\"><a href=\"#3-、解压、配置、安装\" class=\"headerlink\" title=\"(3)、解压、配置、安装\"></a>(3)、解压、配置、安装</h2><pre><code class=\"shell\"># 解压\ntar Jxvf Python-3.7.0.tar.xz\ncd Python-3.7.0\n# 创建安装目录\nmkdir -p /usr/local/python3\n#配置（指定安装目录）\n./configure --prefix=/usr/local/python3 --enable-optimizations\nmake &amp;&amp; make install\n</code></pre>\n<p>在make &amp;&amp; make install这一步，有可能出现“ModuleNotFoundError: No module named ‘_ctypes’”的错误。<br>此时我们把libffi-devel安装上，然后再执行make &amp;&amp; make install即可。</p>\n<pre><code>yum install libffi-devel -y\n</code></pre><h2 id=\"4-、创建python3软链接\"><a href=\"#4-、创建python3软链接\" class=\"headerlink\" title=\"(4)、创建python3软链接\"></a>(4)、创建python3软链接</h2><pre><code>ln -s /usr/local/python3/bin/python3.7 /usr/bin/python3\nln -s /usr/local/python3/bin/pip3.7 /usr/bin/pip3\n</code></pre><h2 id=\"5-、检查\"><a href=\"#5-、检查\" class=\"headerlink\" title=\"(5)、检查\"></a>(5)、检查</h2><pre><code>python3 -V\n</code></pre><p>如果出现3.7.0版本，说明安装成功。</p>\n<p><img src=\"/2019/07/27/python3-nginx-uwsgi/python3-success.png\" alt=\"Python3.7-success\"></p>\n<h1 id=\"2、uwsgi安装\"><a href=\"#2、uwsgi安装\" class=\"headerlink\" title=\"2、uwsgi安装\"></a>2、uwsgi安装</h1><pre><code class=\"shell\">pip3 install uwsgi\n#创建uwsgi3的软链接，和python2的区分开来\nln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi3\n#查看 uwsgi 版本\nuwsgi3 --version\n</code></pre>\n<p>检测uwsgi是否正常：<br>新建 /www/test.py 文件，输入如下内容：</p>\n<pre><code class=\"python\">def application(env, start_response):\n    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;,&#39;text/html&#39;)])\n    return [b&quot;Hello uwsgi&quot;]\n</code></pre>\n<p>然后在终端运行：</p>\n<pre><code>uwsgi3 --http :8001 --wsgi-file test.py\n</code></pre><p>在浏览器中输入 <a href=\"http://127.0.0.1:8001\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8001</a> , 看看是否有”Hello uwsgi“的字样输出。如果没有看看报错信息，据此来查找解决方案。</p>\n<h1 id=\"3、django安装\"><a href=\"#3、django安装\" class=\"headerlink\" title=\"3、django安装\"></a>3、django安装</h1><pre><code class=\"shell\">pip3 install django\n</code></pre>\n<p>测试 django 是否正常，运行：</p>\n<pre><code class=\"shell\">mkdir /www\ncd /www\n# 这里需要注意django-admin.py的位置，当提示命令不存在时，使用find命令全局查找一下\n# find / -name &quot;*django-admin.py*&quot;\n/usr/local/python3/bin/django-admin.py startproject demosite\ncd demosite\npython3 manage.py runserver 0.0.0.0:8002\n</code></pre>\n<p>启动成功，在浏览器内输入：<a href=\"http://127.0.0.1:8002\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8002</a> ,检查django是否运行正常。</p>\n<p>不过，如果报错”ModuleNotFoundError: No module named ‘_sqlite3’”。我们还是要忍着处理一下（毕竟这么多步骤下来，挨了不少坑了）。这里网上很多的答案是去”yum install sqlite-devel”,然后再次编译python3。但是你这么做之后，启动django发现它报错提示说要求3.8及以上的版本。所以这里我们一步到位地解决掉它，我们直接安装高级版本的sqlite3。</p>\n<pre><code class=\"shell\">cd ~\nwget https://www.sqlite.org/2019/sqlite-autoconf-3290000.tar.gz\n# 解压\ntar zxvf sqlite-autoconf-3290000.tar.gz\ncd sqlite-autoconf-3290000\n./configure --prefix=/usr/local/sqlite3 --disable-static --enable-fts5 --enable-json1 CFLAGS=&quot;-g -O2 -DSQLITE_ENABLE_FTS3=1 -DSQLITE_ENABLE_FTS4=1 -DSQLITE_ENABLE_RTREE=1&quot;\nmake &amp;&amp; make install\n</code></pre>\n<p>对Python3.7再进行编译：</p>\n<pre><code>cd ~/Python-3.7.0\nLD_RUN_PATH=/usr/local/sqlite3/lib ./configure --prefix=/usr/local/python3 --enable-optimizations LDFLAGS=&quot;-L/usr/local/sqlite3/lib&quot; CPPFLAGS=&quot;-I /usr/local/sqlite3/include&quot; \nLD_RUN_PATH=/usr/local/sqlite3/lib make\nLD_RUN_PATH=/usr/local/sqlite3/lib make install\n</code></pre><p>检查是否安装成功：<br><img src=\"/2019/07/27/python3-nginx-uwsgi/sqlite3.png\" alt=\"sqlite3-success\"></p>\n<p>成功后，在去启动demosite，应该就没问题啦。</p>\n<pre><code>cd /www/demosite\npython3 manage.py runserver 0.0.0.0:8002\n</code></pre><h1 id=\"4、nginx安装\"><a href=\"#4、nginx安装\" class=\"headerlink\" title=\"4、nginx安装\"></a>4、nginx安装</h1><pre><code class=\"shell\">cd ~\nwget http://nginx.org/download/nginx-1.9.9.tar.gz \ntar xzvf nginx-1.9.9.tar.gz \ncd nginx-1.9.9\n# 配置（指定安装目录）\n./configure --prefix=/usr/local/nginx-1.9.9 --with-http_stub_status_module  --with-http_gzip_static_module\nmake &amp;&amp; make install\n# 检查是否成功\n/usr/local/nginx-1.9.9/sbin/nginx -V\n# 建立软连接\nln -s /usr/local/nginx-1.9.9/sbin/nginx /usr/bin/nginx\n</code></pre>\n<h2 id=\"（1）uwsgi配置\"><a href=\"#（1）uwsgi配置\" class=\"headerlink\" title=\"（1）uwsgi配置\"></a>（1）uwsgi配置</h2><p>在/etc目录下创建uwsgi9090.ini文件，输入如下内容：</p>\n<pre><code class=\"shell\">[uwsgi]\nsocket = 127.0.0.1:9090\nmaster = true         #主进程\nvhost = true          #多站模式\nno-site = true        #多站模式时不设置入口模块和文件\nworkers = 2           #子进程数\nreload-mercy = 10     \nvacuum = true         #退出、重启时清理文件\nmax-requests = 1000   \nlimit-as = 512\nbuffer-size = 30000\npythonpath = /usr/local/python3/lib/python3.7/site-packages\npidfile = /var/run/uwsgi9090.pid    #pid文件，用于下面的脚本启动、停止该进程\ndaemonize = /www/uwsgi9090.log\n</code></pre>\n<p>PS:注意上面pythonpath的配置，很多网上的文章没有这个，所以我们的环境里面有python2和python3的时候，uwsgi启动就默认找python2下面的django，所以会出现找不到django的问题”ModuleNotFoundError: No module named ‘django’”。</p>\n<h2 id=\"2-Nginx配置\"><a href=\"#2-Nginx配置\" class=\"headerlink\" title=\"(2) Nginx配置\"></a>(2) Nginx配置</h2><p>找到nginx的安装目录（如：/usr/local/nginx/），打开conf/nginx.conf文件，修改server配置：</p>\n<pre><code class=\"shell\">server {\n        listen       80;\n        server_name  localhost;\n\n        location / {            \n            include  uwsgi_params;\n            uwsgi_pass  127.0.0.1:9090;              #必须和uwsgi中的设置一致\n            uwsgi_param UWSGI_SCRIPT demosite.wsgi;  #入口文件，即wsgi.py相对于项目根目录的位置，“.”相当于一层目录\n            uwsgi_param UWSGI_CHDIR /www/demosite;       #项目根目录\n            index  index.html index.htm;\n            client_max_body_size 35m;\n        }\n    }\n</code></pre>\n<p>设置完成后，在终端运行：</p>\n<pre><code class=\"shell\">uwsgi --ini /etc/uwsgi9090.ini &amp; /usr/local/nginx/sbin/nginx\n</code></pre>\n<p>浏览器输入：<a href=\"http://127.0.0.1，你就可以看到\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1，你就可以看到</a> django 的界面了。如下：</p>\n<p><img src=\"/2019/07/27/python3-nginx-uwsgi/django-success.png\" alt=\"django-success\"></p>\n<h2 id=\"3-、补充\"><a href=\"#3-、补充\" class=\"headerlink\" title=\"(3)、补充\"></a>(3)、补充</h2><p>在弄环境的过程中，难免会遇到问题，所以对服务的启动停止也很正常，补充一些命令</p>\n<pre><code class=\"shell\"># nginx 检查配置文件是否正确\nnginx -t\n# 重启nginx\nnginx -s reload\n</code></pre>\n<pre><code class=\"shell\"># 停止uwsgi\nuwsgi3 --stop /var/run/uwsgi9090.pid\n</code></pre>\n<h1 id=\"5、参考文章\"><a href=\"#5、参考文章\" class=\"headerlink\" title=\"5、参考文章\"></a>5、参考文章</h1><ol>\n<li>【Django Nginx+uwsgi 安装配置】 <a href=\"https://www.runoob.com/django/django-nginx-uwsgi.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/django/django-nginx-uwsgi.html</a></li>\n<li>【Centos 7升级原python 2.7.5至Python 3.7】 <a href=\"https://blog.51cto.com/10316297/2134736?from=timeline\" target=\"_blank\" rel=\"noopener\">https://blog.51cto.com/10316297/2134736?from=timeline</a></li>\n<li>【Python3以上版本安装sqlite3的解决方案】 <a href=\"https://www.jianshu.com/p/4b5ba514e0a4\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/4b5ba514e0a4</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1、python3环境安装\"><a href=\"#1、python3环境安装\" class=\"headerlink\" title=\"1、python3环境安装\"></a>1、python3环境安装</h1><p>默认的云服务器上安装python版本现在是2.7的版本。如果新开发的应用，使用了python3，由于语法上的不向后兼容，必须得在服务器上安装python3。</p>\n<h2 id=\"1-、安装编译环境包\"><a href=\"#1-、安装编译环境包\" class=\"headerlink\" title=\"(1)、安装编译环境包\"></a>(1)、安装编译环境包</h2><pre><code>yum install gcc-c++ gcc make cmake zlib-devel bzip2-devel openssl-devel ncurse-devel -y\n</code></pre><h2 id=\"2-、下载3-7源代码\"><a href=\"#2-、下载3-7源代码\" class=\"headerlink\" title=\"(2)、下载3.7源代码\"></a>(2)、下载3.7源代码</h2><pre><code class=\"shell\">cd ~\nwget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz\n</code></pre>\n<p>如果wget命令不存在，使用yum安装：</p>\n<pre><code>yum -y install wget\n</code></pre><h2 id=\"3-、解压、配置、安装\"><a href=\"#3-、解压、配置、安装\" class=\"headerlink\" title=\"(3)、解压、配置、安装\"></a>(3)、解压、配置、安装</h2><pre><code class=\"shell\"># 解压\ntar Jxvf Python-3.7.0.tar.xz\ncd Python-3.7.0\n# 创建安装目录\nmkdir -p /usr/local/python3\n#配置（指定安装目录）\n./configure --prefix=/usr/local/python3 --enable-optimizations\nmake &amp;&amp; make install\n</code></pre>\n<p>在make &amp;&amp; make install这一步，有可能出现“ModuleNotFoundError: No module named ‘_ctypes’”的错误。<br>此时我们把libffi-devel安装上，然后再执行make &amp;&amp; make install即可。</p>\n<pre><code>yum install libffi-devel -y\n</code></pre><h2 id=\"4-、创建python3软链接\"><a href=\"#4-、创建python3软链接\" class=\"headerlink\" title=\"(4)、创建python3软链接\"></a>(4)、创建python3软链接</h2><pre><code>ln -s /usr/local/python3/bin/python3.7 /usr/bin/python3\nln -s /usr/local/python3/bin/pip3.7 /usr/bin/pip3\n</code></pre><h2 id=\"5-、检查\"><a href=\"#5-、检查\" class=\"headerlink\" title=\"(5)、检查\"></a>(5)、检查</h2><pre><code>python3 -V\n</code></pre><p>如果出现3.7.0版本，说明安装成功。</p>\n<p><img src=\"/2019/07/27/python3-nginx-uwsgi/python3-success.png\" alt=\"Python3.7-success\"></p>\n<h1 id=\"2、uwsgi安装\"><a href=\"#2、uwsgi安装\" class=\"headerlink\" title=\"2、uwsgi安装\"></a>2、uwsgi安装</h1><pre><code class=\"shell\">pip3 install uwsgi\n#创建uwsgi3的软链接，和python2的区分开来\nln -s /usr/local/python3/bin/uwsgi /usr/bin/uwsgi3\n#查看 uwsgi 版本\nuwsgi3 --version\n</code></pre>\n<p>检测uwsgi是否正常：<br>新建 /www/test.py 文件，输入如下内容：</p>\n<pre><code class=\"python\">def application(env, start_response):\n    start_response(&#39;200 OK&#39;, [(&#39;Content-Type&#39;,&#39;text/html&#39;)])\n    return [b&quot;Hello uwsgi&quot;]\n</code></pre>\n<p>然后在终端运行：</p>\n<pre><code>uwsgi3 --http :8001 --wsgi-file test.py\n</code></pre><p>在浏览器中输入 <a href=\"http://127.0.0.1:8001\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8001</a> , 看看是否有”Hello uwsgi“的字样输出。如果没有看看报错信息，据此来查找解决方案。</p>\n<h1 id=\"3、django安装\"><a href=\"#3、django安装\" class=\"headerlink\" title=\"3、django安装\"></a>3、django安装</h1><pre><code class=\"shell\">pip3 install django\n</code></pre>\n<p>测试 django 是否正常，运行：</p>\n<pre><code class=\"shell\">mkdir /www\ncd /www\n# 这里需要注意django-admin.py的位置，当提示命令不存在时，使用find命令全局查找一下\n# find / -name &quot;*django-admin.py*&quot;\n/usr/local/python3/bin/django-admin.py startproject demosite\ncd demosite\npython3 manage.py runserver 0.0.0.0:8002\n</code></pre>\n<p>启动成功，在浏览器内输入：<a href=\"http://127.0.0.1:8002\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8002</a> ,检查django是否运行正常。</p>\n<p>不过，如果报错”ModuleNotFoundError: No module named ‘_sqlite3’”。我们还是要忍着处理一下（毕竟这么多步骤下来，挨了不少坑了）。这里网上很多的答案是去”yum install sqlite-devel”,然后再次编译python3。但是你这么做之后，启动django发现它报错提示说要求3.8及以上的版本。所以这里我们一步到位地解决掉它，我们直接安装高级版本的sqlite3。</p>\n<pre><code class=\"shell\">cd ~\nwget https://www.sqlite.org/2019/sqlite-autoconf-3290000.tar.gz\n# 解压\ntar zxvf sqlite-autoconf-3290000.tar.gz\ncd sqlite-autoconf-3290000\n./configure --prefix=/usr/local/sqlite3 --disable-static --enable-fts5 --enable-json1 CFLAGS=&quot;-g -O2 -DSQLITE_ENABLE_FTS3=1 -DSQLITE_ENABLE_FTS4=1 -DSQLITE_ENABLE_RTREE=1&quot;\nmake &amp;&amp; make install\n</code></pre>\n<p>对Python3.7再进行编译：</p>\n<pre><code>cd ~/Python-3.7.0\nLD_RUN_PATH=/usr/local/sqlite3/lib ./configure --prefix=/usr/local/python3 --enable-optimizations LDFLAGS=&quot;-L/usr/local/sqlite3/lib&quot; CPPFLAGS=&quot;-I /usr/local/sqlite3/include&quot; \nLD_RUN_PATH=/usr/local/sqlite3/lib make\nLD_RUN_PATH=/usr/local/sqlite3/lib make install\n</code></pre><p>检查是否安装成功：<br><img src=\"/2019/07/27/python3-nginx-uwsgi/sqlite3.png\" alt=\"sqlite3-success\"></p>\n<p>成功后，在去启动demosite，应该就没问题啦。</p>\n<pre><code>cd /www/demosite\npython3 manage.py runserver 0.0.0.0:8002\n</code></pre><h1 id=\"4、nginx安装\"><a href=\"#4、nginx安装\" class=\"headerlink\" title=\"4、nginx安装\"></a>4、nginx安装</h1><pre><code class=\"shell\">cd ~\nwget http://nginx.org/download/nginx-1.9.9.tar.gz \ntar xzvf nginx-1.9.9.tar.gz \ncd nginx-1.9.9\n# 配置（指定安装目录）\n./configure --prefix=/usr/local/nginx-1.9.9 --with-http_stub_status_module  --with-http_gzip_static_module\nmake &amp;&amp; make install\n# 检查是否成功\n/usr/local/nginx-1.9.9/sbin/nginx -V\n# 建立软连接\nln -s /usr/local/nginx-1.9.9/sbin/nginx /usr/bin/nginx\n</code></pre>\n<h2 id=\"（1）uwsgi配置\"><a href=\"#（1）uwsgi配置\" class=\"headerlink\" title=\"（1）uwsgi配置\"></a>（1）uwsgi配置</h2><p>在/etc目录下创建uwsgi9090.ini文件，输入如下内容：</p>\n<pre><code class=\"shell\">[uwsgi]\nsocket = 127.0.0.1:9090\nmaster = true         #主进程\nvhost = true          #多站模式\nno-site = true        #多站模式时不设置入口模块和文件\nworkers = 2           #子进程数\nreload-mercy = 10     \nvacuum = true         #退出、重启时清理文件\nmax-requests = 1000   \nlimit-as = 512\nbuffer-size = 30000\npythonpath = /usr/local/python3/lib/python3.7/site-packages\npidfile = /var/run/uwsgi9090.pid    #pid文件，用于下面的脚本启动、停止该进程\ndaemonize = /www/uwsgi9090.log\n</code></pre>\n<p>PS:注意上面pythonpath的配置，很多网上的文章没有这个，所以我们的环境里面有python2和python3的时候，uwsgi启动就默认找python2下面的django，所以会出现找不到django的问题”ModuleNotFoundError: No module named ‘django’”。</p>\n<h2 id=\"2-Nginx配置\"><a href=\"#2-Nginx配置\" class=\"headerlink\" title=\"(2) Nginx配置\"></a>(2) Nginx配置</h2><p>找到nginx的安装目录（如：/usr/local/nginx/），打开conf/nginx.conf文件，修改server配置：</p>\n<pre><code class=\"shell\">server {\n        listen       80;\n        server_name  localhost;\n\n        location / {            \n            include  uwsgi_params;\n            uwsgi_pass  127.0.0.1:9090;              #必须和uwsgi中的设置一致\n            uwsgi_param UWSGI_SCRIPT demosite.wsgi;  #入口文件，即wsgi.py相对于项目根目录的位置，“.”相当于一层目录\n            uwsgi_param UWSGI_CHDIR /www/demosite;       #项目根目录\n            index  index.html index.htm;\n            client_max_body_size 35m;\n        }\n    }\n</code></pre>\n<p>设置完成后，在终端运行：</p>\n<pre><code class=\"shell\">uwsgi --ini /etc/uwsgi9090.ini &amp; /usr/local/nginx/sbin/nginx\n</code></pre>\n<p>浏览器输入：<a href=\"http://127.0.0.1，你就可以看到\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1，你就可以看到</a> django 的界面了。如下：</p>\n<p><img src=\"/2019/07/27/python3-nginx-uwsgi/django-success.png\" alt=\"django-success\"></p>\n<h2 id=\"3-、补充\"><a href=\"#3-、补充\" class=\"headerlink\" title=\"(3)、补充\"></a>(3)、补充</h2><p>在弄环境的过程中，难免会遇到问题，所以对服务的启动停止也很正常，补充一些命令</p>\n<pre><code class=\"shell\"># nginx 检查配置文件是否正确\nnginx -t\n# 重启nginx\nnginx -s reload\n</code></pre>\n<pre><code class=\"shell\"># 停止uwsgi\nuwsgi3 --stop /var/run/uwsgi9090.pid\n</code></pre>\n<h1 id=\"5、参考文章\"><a href=\"#5、参考文章\" class=\"headerlink\" title=\"5、参考文章\"></a>5、参考文章</h1><ol>\n<li>【Django Nginx+uwsgi 安装配置】 <a href=\"https://www.runoob.com/django/django-nginx-uwsgi.html\" target=\"_blank\" rel=\"noopener\">https://www.runoob.com/django/django-nginx-uwsgi.html</a></li>\n<li>【Centos 7升级原python 2.7.5至Python 3.7】 <a href=\"https://blog.51cto.com/10316297/2134736?from=timeline\" target=\"_blank\" rel=\"noopener\">https://blog.51cto.com/10316297/2134736?from=timeline</a></li>\n<li>【Python3以上版本安装sqlite3的解决方案】 <a href=\"https://www.jianshu.com/p/4b5ba514e0a4\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/4b5ba514e0a4</a></li>\n</ol>\n"},{"title":"react-ace placeholder & 受控处理","date":"2019-03-29T15:42:03.000Z","_content":"\n我们在开发的过程中，可能会用到类似富文本编辑器这样的控件。在react体系中，react-ace是首选。这里我们来看看使用这个组件时，会遇到的问题。\n\n## 1、placeholder\n\n最新的官方文档里面其实是有 placeholder 这个属性配置，但是即使你安装了最新版本的react－ace，你会发现它并不生效。在这种情况下，我们能做的就是自己来实现placeholder的功能。\n\n设置了placeholder属性后的效果如下（其实并没有生效）：\n\n![no-placeholder](react-ace-placeholder-01.gif)\n\n下面这段代码用来添加placeholder功能。\n\n{% codeblock %}\nimport React, { Component } from 'react'\nimport AceEditor from 'react-ace'\n\nlet editorRef = null\n\nclass App extends Component {\n\n    handleChange = () => {\n        this.update()\n    }\n\n    update = () => {\n        if (!editorRef) {\n            return\n        }\n        const editor = editorRef.editor\n        let shouldShow = !editor.session.getValue().length\n        let node = editor.renderer.emptyMessageNode\n        if (!shouldShow && node) {\n            editor.renderer.scroller.removeChild(editor.renderer.emptyMessageNode)\n            editor.renderer.emptyMessageNode = null\n        } else if (shouldShow && !node) {\n            node = document.createElement('div')\n            editor.renderer.emptyMessageNode = node\n            node.innerHTML = '我是placeholder~~~~'\n            node.className = 'ace_invisible ace_emptyMessage'\n            node.style.padding = '0 9px'\n            node.style.position = 'absolute'\n            node.style.zIndex = 5\n            editor.renderer.scroller.appendChild(node)\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <AceEditor\n                    onChange={this.handleChange}\n                    ref={(r) => {\n                        editorRef = r\n                        setTimeout(() => {\n                            this.update()\n                        })\n                    }}\n                    placeholder=\"placeholder ace editor\"\n                />\n            </div>\n        )\n    }\n}\n\nexport default App\n{% endcodeblock %}\n\n实现效果如下：\n![react-ace-placeholder](react-ace-02.gif)\n\ndemo地址大家可以查看 {% link 这里 https://github.com/Two-Ftry/react-essay/tree/master/react-ace-00 %} 。\n\n我们来分析一下这段代码的实现。首先我们先获得了react-ace的引用（editorRef），然后调用update()方法。editorRef中，保存有ace-editor的实例（即editorRef.editor）。拿到了ace-editor实例，我们就要去看看{% link ace-editor的文档 https://ace.c9.io/#nav=api&api=editor %}，看看都有些什么API。这段代码里面，用到了session、renderer这两个实例。\n\n- session：是EditorSession的实例，它存储了编辑器的所有状态数据；通过getValue()方法可以获得当前文档中输入的字符串。\n- renderer：是VirtualRenderer的实例，负责将所有东西渲染到屏幕上。\n  \n而整体渲染在浏览器中的dom结构如下：\n\n- ace_editor\n    - textarea\n    - gutter(ace_gutter)\n    - ace_scroller\n        - ace_content (输入内容的显示区)\n\n我们要控制placeholder，那么可能得控制ace_content部分。而在renderer实例里面，有一个scroller的实例，存储的是ace_scroller对应的dom对象（它是ace_content的父元素），这就是我们要放置placeholder的dom了。\n\n有了对这几个实例的了解。我们就不难分析这段代码了。首先，用getValue()方法，获得输入内容。如果内容为空，那么就需要显示placeholder。所以使用document.createElement('div')来创建了一个dom，并加上placeholder的内容以及style样式。然后把这个dom存放在renderer.emptyMessageNode属性中，并把dom通过appendChild()方法添加到scroller中（即ace_scroller对应的区域）渲染出来。此时，placeholder的效果就显示出来了。\n\n而如果用户输入内容，我们使用onChange事件监听用户的输入，在onChange事件中调用update()方法。如果用户输入了内容，getValue()返回不为空，这时我们就从scroller对象中移除对应的dom，并将renderer.emptyMessageNode设置为null。这样，placeholder的效果就实现了。\n\nPS：这段代码是基于stackoverflow上 {% link 这个回答 https://stackoverflow.com/questions/26695708/how-can-i-add-placeholder-text-when-the-editor-is-empty %} 的基础上实现的，大家也可去这里查看实现。\n\n\n## 2、 AceEditor受控组件\n\n在开发过程中，可能会遇到一个问题。那就是你将AceEditor做成受控组件，然后在输入英文的过程中，切换输入中文，发现前面的输入会清空。这个问题的原因是，AceEditor组件在输入的过程中被更新了，导致之前输入的内容都消失。这时，手动控制shouldComponentUpdate即可。\n\n{% codeblock %}\n shouldComponentUpdate (nextProps) {\n    const { content } = this.props\n    if (content === nextProps.content) {\n      return false\n    }\n    return true\n  }\n{% endcodeblock %}\n\nPS:在开发中遇到这个问题，但是在写demo的时候，一直无法重现，先记录在此。\n\n## 3、光标错位\n\n当页面内容嵌套比较深的时候，极有可能出现光标错位的问题，起因就是上下文的字体样式影响到了ace-editor，导致它计算位置错误。这时我们只要重置ace-editor本身的样式即可。\n\n问题如下：\n![react-ace-cursor](react-ace-cursor.png)\n\n修复方案：\n{% codeblock %}\n.ace_editor {\n  * {\n    font-family: inherit;\n  }\n}\n{% endcodeblock %}","source":"_posts/react-ace-placeholder-20190329.md","raw":"---\ntitle: react-ace placeholder & 受控处理\ndate: 2019-03-29 23:42:03\ntags: react ace placeholder 内容清空 光标 错位\n---\n\n我们在开发的过程中，可能会用到类似富文本编辑器这样的控件。在react体系中，react-ace是首选。这里我们来看看使用这个组件时，会遇到的问题。\n\n## 1、placeholder\n\n最新的官方文档里面其实是有 placeholder 这个属性配置，但是即使你安装了最新版本的react－ace，你会发现它并不生效。在这种情况下，我们能做的就是自己来实现placeholder的功能。\n\n设置了placeholder属性后的效果如下（其实并没有生效）：\n\n![no-placeholder](react-ace-placeholder-01.gif)\n\n下面这段代码用来添加placeholder功能。\n\n{% codeblock %}\nimport React, { Component } from 'react'\nimport AceEditor from 'react-ace'\n\nlet editorRef = null\n\nclass App extends Component {\n\n    handleChange = () => {\n        this.update()\n    }\n\n    update = () => {\n        if (!editorRef) {\n            return\n        }\n        const editor = editorRef.editor\n        let shouldShow = !editor.session.getValue().length\n        let node = editor.renderer.emptyMessageNode\n        if (!shouldShow && node) {\n            editor.renderer.scroller.removeChild(editor.renderer.emptyMessageNode)\n            editor.renderer.emptyMessageNode = null\n        } else if (shouldShow && !node) {\n            node = document.createElement('div')\n            editor.renderer.emptyMessageNode = node\n            node.innerHTML = '我是placeholder~~~~'\n            node.className = 'ace_invisible ace_emptyMessage'\n            node.style.padding = '0 9px'\n            node.style.position = 'absolute'\n            node.style.zIndex = 5\n            editor.renderer.scroller.appendChild(node)\n        }\n    }\n\n    render() {\n        return (\n            <div>\n                <AceEditor\n                    onChange={this.handleChange}\n                    ref={(r) => {\n                        editorRef = r\n                        setTimeout(() => {\n                            this.update()\n                        })\n                    }}\n                    placeholder=\"placeholder ace editor\"\n                />\n            </div>\n        )\n    }\n}\n\nexport default App\n{% endcodeblock %}\n\n实现效果如下：\n![react-ace-placeholder](react-ace-02.gif)\n\ndemo地址大家可以查看 {% link 这里 https://github.com/Two-Ftry/react-essay/tree/master/react-ace-00 %} 。\n\n我们来分析一下这段代码的实现。首先我们先获得了react-ace的引用（editorRef），然后调用update()方法。editorRef中，保存有ace-editor的实例（即editorRef.editor）。拿到了ace-editor实例，我们就要去看看{% link ace-editor的文档 https://ace.c9.io/#nav=api&api=editor %}，看看都有些什么API。这段代码里面，用到了session、renderer这两个实例。\n\n- session：是EditorSession的实例，它存储了编辑器的所有状态数据；通过getValue()方法可以获得当前文档中输入的字符串。\n- renderer：是VirtualRenderer的实例，负责将所有东西渲染到屏幕上。\n  \n而整体渲染在浏览器中的dom结构如下：\n\n- ace_editor\n    - textarea\n    - gutter(ace_gutter)\n    - ace_scroller\n        - ace_content (输入内容的显示区)\n\n我们要控制placeholder，那么可能得控制ace_content部分。而在renderer实例里面，有一个scroller的实例，存储的是ace_scroller对应的dom对象（它是ace_content的父元素），这就是我们要放置placeholder的dom了。\n\n有了对这几个实例的了解。我们就不难分析这段代码了。首先，用getValue()方法，获得输入内容。如果内容为空，那么就需要显示placeholder。所以使用document.createElement('div')来创建了一个dom，并加上placeholder的内容以及style样式。然后把这个dom存放在renderer.emptyMessageNode属性中，并把dom通过appendChild()方法添加到scroller中（即ace_scroller对应的区域）渲染出来。此时，placeholder的效果就显示出来了。\n\n而如果用户输入内容，我们使用onChange事件监听用户的输入，在onChange事件中调用update()方法。如果用户输入了内容，getValue()返回不为空，这时我们就从scroller对象中移除对应的dom，并将renderer.emptyMessageNode设置为null。这样，placeholder的效果就实现了。\n\nPS：这段代码是基于stackoverflow上 {% link 这个回答 https://stackoverflow.com/questions/26695708/how-can-i-add-placeholder-text-when-the-editor-is-empty %} 的基础上实现的，大家也可去这里查看实现。\n\n\n## 2、 AceEditor受控组件\n\n在开发过程中，可能会遇到一个问题。那就是你将AceEditor做成受控组件，然后在输入英文的过程中，切换输入中文，发现前面的输入会清空。这个问题的原因是，AceEditor组件在输入的过程中被更新了，导致之前输入的内容都消失。这时，手动控制shouldComponentUpdate即可。\n\n{% codeblock %}\n shouldComponentUpdate (nextProps) {\n    const { content } = this.props\n    if (content === nextProps.content) {\n      return false\n    }\n    return true\n  }\n{% endcodeblock %}\n\nPS:在开发中遇到这个问题，但是在写demo的时候，一直无法重现，先记录在此。\n\n## 3、光标错位\n\n当页面内容嵌套比较深的时候，极有可能出现光标错位的问题，起因就是上下文的字体样式影响到了ace-editor，导致它计算位置错误。这时我们只要重置ace-editor本身的样式即可。\n\n问题如下：\n![react-ace-cursor](react-ace-cursor.png)\n\n修复方案：\n{% codeblock %}\n.ace_editor {\n  * {\n    font-family: inherit;\n  }\n}\n{% endcodeblock %}","slug":"react-ace-placeholder","published":1,"updated":"2019-04-01T04:37:06.576Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvop6000k4c41z7cc792j","content":"<p>我们在开发的过程中，可能会用到类似富文本编辑器这样的控件。在react体系中，react-ace是首选。这里我们来看看使用这个组件时，会遇到的问题。</p>\n<h2 id=\"1、placeholder\"><a href=\"#1、placeholder\" class=\"headerlink\" title=\"1、placeholder\"></a>1、placeholder</h2><p>最新的官方文档里面其实是有 placeholder 这个属性配置，但是即使你安装了最新版本的react－ace，你会发现它并不生效。在这种情况下，我们能做的就是自己来实现placeholder的功能。</p>\n<p>设置了placeholder属性后的效果如下（其实并没有生效）：</p>\n<p><img src=\"/2019/03/29/react-ace-placeholder/react-ace-placeholder-01.gif\" alt=\"no-placeholder\"></p>\n<p>下面这段代码用来添加placeholder功能。</p>\n<pre><code>import React, { Component } from &#39;react&#39;\nimport AceEditor from &#39;react-ace&#39;\n\nlet editorRef = null\n\nclass App extends Component {\n\n    handleChange = () =&gt; {\n        this.update()\n    }\n\n    update = () =&gt; {\n        if (!editorRef) {\n            return\n        }\n        const editor = editorRef.editor\n        let shouldShow = !editor.session.getValue().length\n        let node = editor.renderer.emptyMessageNode\n        if (!shouldShow &amp;&amp; node) {\n            editor.renderer.scroller.removeChild(editor.renderer.emptyMessageNode)\n            editor.renderer.emptyMessageNode = null\n        } else if (shouldShow &amp;&amp; !node) {\n            node = document.createElement(&#39;div&#39;)\n            editor.renderer.emptyMessageNode = node\n            node.innerHTML = &#39;我是placeholder~~~~&#39;\n            node.className = &#39;ace_invisible ace_emptyMessage&#39;\n            node.style.padding = &#39;0 9px&#39;\n            node.style.position = &#39;absolute&#39;\n            node.style.zIndex = 5\n            editor.renderer.scroller.appendChild(node)\n        }\n    }\n\n    render() {\n        return (\n            &lt;div&gt;\n                &lt;AceEditor\n                    onChange={this.handleChange}\n                    ref={(r) =&gt; {\n                        editorRef = r\n                        setTimeout(() =&gt; {\n                            this.update()\n                        })\n                    }}\n                    placeholder=&quot;placeholder ace editor&quot;\n                &#x2F;&gt;\n            &lt;&#x2F;div&gt;\n        )\n    }\n}\n\nexport default App</code></pre>\n<p>实现效果如下：<br><img src=\"/2019/03/29/react-ace-placeholder/react-ace-02.gif\" alt=\"react-ace-placeholder\"></p>\n<p>demo地址大家可以查看 <a href=\"https://github.com/Two-Ftry/react-essay/tree/master/react-ace-00\" target=\"_blank\" rel=\"noopener\">这里</a> 。</p>\n<p>我们来分析一下这段代码的实现。首先我们先获得了react-ace的引用（editorRef），然后调用update()方法。editorRef中，保存有ace-editor的实例（即editorRef.editor）。拿到了ace-editor实例，我们就要去看看<a href=\"https://ace.c9.io/#nav=api&api=editor\" target=\"_blank\" rel=\"noopener\">ace-editor的文档</a>，看看都有些什么API。这段代码里面，用到了session、renderer这两个实例。</p>\n<ul>\n<li>session：是EditorSession的实例，它存储了编辑器的所有状态数据；通过getValue()方法可以获得当前文档中输入的字符串。</li>\n<li>renderer：是VirtualRenderer的实例，负责将所有东西渲染到屏幕上。</li>\n</ul>\n<p>而整体渲染在浏览器中的dom结构如下：</p>\n<ul>\n<li>ace_editor<ul>\n<li>textarea</li>\n<li>gutter(ace_gutter)</li>\n<li>ace_scroller<ul>\n<li>ace_content (输入内容的显示区)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>我们要控制placeholder，那么可能得控制ace_content部分。而在renderer实例里面，有一个scroller的实例，存储的是ace_scroller对应的dom对象（它是ace_content的父元素），这就是我们要放置placeholder的dom了。</p>\n<p>有了对这几个实例的了解。我们就不难分析这段代码了。首先，用getValue()方法，获得输入内容。如果内容为空，那么就需要显示placeholder。所以使用document.createElement(‘div’)来创建了一个dom，并加上placeholder的内容以及style样式。然后把这个dom存放在renderer.emptyMessageNode属性中，并把dom通过appendChild()方法添加到scroller中（即ace_scroller对应的区域）渲染出来。此时，placeholder的效果就显示出来了。</p>\n<p>而如果用户输入内容，我们使用onChange事件监听用户的输入，在onChange事件中调用update()方法。如果用户输入了内容，getValue()返回不为空，这时我们就从scroller对象中移除对应的dom，并将renderer.emptyMessageNode设置为null。这样，placeholder的效果就实现了。</p>\n<p>PS：这段代码是基于stackoverflow上 <a href=\"https://stackoverflow.com/questions/26695708/how-can-i-add-placeholder-text-when-the-editor-is-empty\" target=\"_blank\" rel=\"noopener\">这个回答</a> 的基础上实现的，大家也可去这里查看实现。</p>\n<h2 id=\"2、-AceEditor受控组件\"><a href=\"#2、-AceEditor受控组件\" class=\"headerlink\" title=\"2、 AceEditor受控组件\"></a>2、 AceEditor受控组件</h2><p>在开发过程中，可能会遇到一个问题。那就是你将AceEditor做成受控组件，然后在输入英文的过程中，切换输入中文，发现前面的输入会清空。这个问题的原因是，AceEditor组件在输入的过程中被更新了，导致之前输入的内容都消失。这时，手动控制shouldComponentUpdate即可。</p>\n<pre><code>shouldComponentUpdate (nextProps) {\n   const { content } = this.props\n   if (content === nextProps.content) {\n     return false\n   }\n   return true\n }</code></pre>\n<p>PS:在开发中遇到这个问题，但是在写demo的时候，一直无法重现，先记录在此。</p>\n<h2 id=\"3、光标错位\"><a href=\"#3、光标错位\" class=\"headerlink\" title=\"3、光标错位\"></a>3、光标错位</h2><p>当页面内容嵌套比较深的时候，极有可能出现光标错位的问题，起因就是上下文的字体样式影响到了ace-editor，导致它计算位置错误。这时我们只要重置ace-editor本身的样式即可。</p>\n<p>问题如下：<br><img src=\"/2019/03/29/react-ace-placeholder/react-ace-cursor.png\" alt=\"react-ace-cursor\"></p>\n<p>修复方案：<br><pre><code>.ace_editor {\n  * {\n    font-family: inherit;\n  }\n}</code></pre></p>\n","site":{"data":{}},"excerpt":"","more":"<p>我们在开发的过程中，可能会用到类似富文本编辑器这样的控件。在react体系中，react-ace是首选。这里我们来看看使用这个组件时，会遇到的问题。</p>\n<h2 id=\"1、placeholder\"><a href=\"#1、placeholder\" class=\"headerlink\" title=\"1、placeholder\"></a>1、placeholder</h2><p>最新的官方文档里面其实是有 placeholder 这个属性配置，但是即使你安装了最新版本的react－ace，你会发现它并不生效。在这种情况下，我们能做的就是自己来实现placeholder的功能。</p>\n<p>设置了placeholder属性后的效果如下（其实并没有生效）：</p>\n<p><img src=\"/2019/03/29/react-ace-placeholder/react-ace-placeholder-01.gif\" alt=\"no-placeholder\"></p>\n<p>下面这段代码用来添加placeholder功能。</p>\n<pre><code>import React, { Component } from &#39;react&#39;\nimport AceEditor from &#39;react-ace&#39;\n\nlet editorRef = null\n\nclass App extends Component {\n\n    handleChange = () =&gt; {\n        this.update()\n    }\n\n    update = () =&gt; {\n        if (!editorRef) {\n            return\n        }\n        const editor = editorRef.editor\n        let shouldShow = !editor.session.getValue().length\n        let node = editor.renderer.emptyMessageNode\n        if (!shouldShow &amp;&amp; node) {\n            editor.renderer.scroller.removeChild(editor.renderer.emptyMessageNode)\n            editor.renderer.emptyMessageNode = null\n        } else if (shouldShow &amp;&amp; !node) {\n            node = document.createElement(&#39;div&#39;)\n            editor.renderer.emptyMessageNode = node\n            node.innerHTML = &#39;我是placeholder~~~~&#39;\n            node.className = &#39;ace_invisible ace_emptyMessage&#39;\n            node.style.padding = &#39;0 9px&#39;\n            node.style.position = &#39;absolute&#39;\n            node.style.zIndex = 5\n            editor.renderer.scroller.appendChild(node)\n        }\n    }\n\n    render() {\n        return (\n            &lt;div&gt;\n                &lt;AceEditor\n                    onChange={this.handleChange}\n                    ref={(r) =&gt; {\n                        editorRef = r\n                        setTimeout(() =&gt; {\n                            this.update()\n                        })\n                    }}\n                    placeholder=&quot;placeholder ace editor&quot;\n                &#x2F;&gt;\n            &lt;&#x2F;div&gt;\n        )\n    }\n}\n\nexport default App</code></pre>\n<p>实现效果如下：<br><img src=\"/2019/03/29/react-ace-placeholder/react-ace-02.gif\" alt=\"react-ace-placeholder\"></p>\n<p>demo地址大家可以查看 <a href=\"https://github.com/Two-Ftry/react-essay/tree/master/react-ace-00\" target=\"_blank\" rel=\"noopener\">这里</a> 。</p>\n<p>我们来分析一下这段代码的实现。首先我们先获得了react-ace的引用（editorRef），然后调用update()方法。editorRef中，保存有ace-editor的实例（即editorRef.editor）。拿到了ace-editor实例，我们就要去看看<a href=\"https://ace.c9.io/#nav=api&api=editor\" target=\"_blank\" rel=\"noopener\">ace-editor的文档</a>，看看都有些什么API。这段代码里面，用到了session、renderer这两个实例。</p>\n<ul>\n<li>session：是EditorSession的实例，它存储了编辑器的所有状态数据；通过getValue()方法可以获得当前文档中输入的字符串。</li>\n<li>renderer：是VirtualRenderer的实例，负责将所有东西渲染到屏幕上。</li>\n</ul>\n<p>而整体渲染在浏览器中的dom结构如下：</p>\n<ul>\n<li>ace_editor<ul>\n<li>textarea</li>\n<li>gutter(ace_gutter)</li>\n<li>ace_scroller<ul>\n<li>ace_content (输入内容的显示区)</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p>我们要控制placeholder，那么可能得控制ace_content部分。而在renderer实例里面，有一个scroller的实例，存储的是ace_scroller对应的dom对象（它是ace_content的父元素），这就是我们要放置placeholder的dom了。</p>\n<p>有了对这几个实例的了解。我们就不难分析这段代码了。首先，用getValue()方法，获得输入内容。如果内容为空，那么就需要显示placeholder。所以使用document.createElement(‘div’)来创建了一个dom，并加上placeholder的内容以及style样式。然后把这个dom存放在renderer.emptyMessageNode属性中，并把dom通过appendChild()方法添加到scroller中（即ace_scroller对应的区域）渲染出来。此时，placeholder的效果就显示出来了。</p>\n<p>而如果用户输入内容，我们使用onChange事件监听用户的输入，在onChange事件中调用update()方法。如果用户输入了内容，getValue()返回不为空，这时我们就从scroller对象中移除对应的dom，并将renderer.emptyMessageNode设置为null。这样，placeholder的效果就实现了。</p>\n<p>PS：这段代码是基于stackoverflow上 <a href=\"https://stackoverflow.com/questions/26695708/how-can-i-add-placeholder-text-when-the-editor-is-empty\" target=\"_blank\" rel=\"noopener\">这个回答</a> 的基础上实现的，大家也可去这里查看实现。</p>\n<h2 id=\"2、-AceEditor受控组件\"><a href=\"#2、-AceEditor受控组件\" class=\"headerlink\" title=\"2、 AceEditor受控组件\"></a>2、 AceEditor受控组件</h2><p>在开发过程中，可能会遇到一个问题。那就是你将AceEditor做成受控组件，然后在输入英文的过程中，切换输入中文，发现前面的输入会清空。这个问题的原因是，AceEditor组件在输入的过程中被更新了，导致之前输入的内容都消失。这时，手动控制shouldComponentUpdate即可。</p>\n<pre><code>shouldComponentUpdate (nextProps) {\n   const { content } = this.props\n   if (content === nextProps.content) {\n     return false\n   }\n   return true\n }</code></pre>\n<p>PS:在开发中遇到这个问题，但是在写demo的时候，一直无法重现，先记录在此。</p>\n<h2 id=\"3、光标错位\"><a href=\"#3、光标错位\" class=\"headerlink\" title=\"3、光标错位\"></a>3、光标错位</h2><p>当页面内容嵌套比较深的时候，极有可能出现光标错位的问题，起因就是上下文的字体样式影响到了ace-editor，导致它计算位置错误。这时我们只要重置ace-editor本身的样式即可。</p>\n<p>问题如下：<br><img src=\"/2019/03/29/react-ace-placeholder/react-ace-cursor.png\" alt=\"react-ace-cursor\"></p>\n<p>修复方案：<br><pre><code>.ace_editor {\n  * {\n    font-family: inherit;\n  }\n}</code></pre></p>\n"},{"title":"reactRouter1-初识react router","date":"2019-02-25T09:43:09.000Z","_content":"\n设想，我们正在使用react构建一个单页应用（SPA），我们应该怎么设置路由呢？在页面没有刷新的情况下，要更改页面的某个部分或者整个页面，这时候就是使用前端路由的时候了。配合react构建SPA的路由框架非react-router莫属。react-router更新到4.0版本，其设计思想已经和前几个版本不一样。其设计的思路是\"动态路由\"。何为\"动态路由\"?就是路由发生在app的渲染过程中！那与之相对应的就是\"静态路由\"，静态路由是在应用初始化前就已经定义好路由信息。所以，从定义上看是完全不一样的，那在使用的过程中也会有很大差别。\n\n接下来我们看看react-router是如何工作的？\n\n- (1) 把&lt;Router /&gt;组件放到应用的最顶层\n- (2) 使用&lt;Link /&gt;组件定义路由\n- (3) 最后，使用&lt;Route /&gt;组件展现路由对应的UI\n\n如上，react-router会涉及到几个重要的组件，分别&lt;是Router /&gt;、&lt;Link /&gt;和&lt;Route /&gt;,翻译过来就是路由组件、导航组件和路由匹配组件。实际上，react-router也就是由这三类组件组成，所有这些组件都可以从\"react-router-dom\"这个npm包中导入使用。\n\n我们来看看路由组件&lt;Router /&gt;,针对web应用，react-router提供了&lt;BrowserRouter /&gt;和&lt;HashRouter /&gt;。除了实现原理不一样外，使用上也有区别，&lt;BrowserRouter /&gt;支持服务端渲染而&lt;HashRouter /&gt;不支持，所以在使用的时候得注意这一点。\n\n基于以上对react-router的简单认识，我们来把它使用起来，加深理解。假设我们在构建一个\"Todo应用\"，包含两个一面，一个待办列表页面，另一个是添加待办事项的页面。我们来一步步实现它。\n\n# 1、搭建环境\n\n要使用react-router，必须得把react的页面配置起来。我们简单地使用webpack来进行配置，并编写简单的页面，搭建起一个开发环境。目录信息如下：\n\n- package.json\n- webpack.config.js\n- src\n    - AddTodo.js (添加待办事项页面)\n    - app.js (顶层App组件)\n    - index.js (入口文件)\n    - Todo.js (待办事项)\n    - TodoList.js (待办事项列表页面)\n\n具体实现参考 {% link 这里 https://github.com/Two-Ftry/react-essay/tree/master/react-router-00 %} 。\n\n# 2、添加react-router\n\nreact-router 4.0+的三类组件（即路由组件、导航组件和路由匹配组件），都在\"react-router-dom\"这个npm包里面。我们先在项目根目录下安装依赖。\n\n{% codeblock %}\n> npm install -D react-router-dom\n{% endcodeblock %}\n\n依赖安装完成之后。我们来实现路由。按照上面提到的react-router工作的三个步骤，我们来一步步实现。\n\n## 2.1 添加&lt;Router /&gt;组件\n\n在app的顶层添加router组件，这里我们的index.js入口文件，就是整个web app的顶部，所以我们在index.js文件中添加&lt;Router /&gt;。\n\n{% codeblock %}\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { HashRouter as Router } from 'react-router-dom'\n\nimport App from './app'\n\nReactDOM.render(\n    <Router>\n        <App />\n    </Router>,\n    document.getElementsByTagName('BODY')[0],\n)\n{% endcodeblock %}\n\n这里我们使用HashRouter，因为是前端的简单实现，使用HashRouter和BrowserRouter都可。然后把&lt;Router /&gt;把  &lt; App /&gt;包裹起来，就完成任务了。\n\n但是Router到底做了些什么？为什么要加Router在顶层呢？\n\n## 2.2 使用&lt;Link /&gt;组件定义路由\n\ntodo应用的操作逻辑，进来之后首先展现列表页；从列表页，可以进入“添加页面”；而从“添加页面”又可以返回列表页，形成一个闭环。\n\n列表页(TodoList.js)添加 &lt;Link /&gt; 的代码如下：\n<table style=\"margin-left: auto; margin-right: auto;margin-top:-150px;\">\n        <tr>\n            <td>\n    {% codeblock %}\n    // TodoList.js(添加Link前)\n    import React from 'react'\n    import Todo from './Todo'\n\n    const TodoList = ({todos}) => (\n        <div>\n            <h1>待办列表</h1>\n            <ul>\n                {todos.map((todo, index) => (\n                    <Todo key={index} {...todo} />\n                ))}\n            </ul>\n        </div>\n    )\n\n    export default TodoList\n    {% endcodeblock %}                \n            </td>\n            <td>\n    {% codeblock %}\n    // TodoList.js(添加Link后)\n    import React from 'react'\n    import { Link } from 'react-router-dom'\n    import Todo from './Todo'\n    const TodoList = ({todos}) => (\n        <div>\n            <h1>待办列表</h1>\n            <Link to=\"addTodo\">添加</Link>\n            <ul>\n                {todos.map((todo, index) => (\n                    <Todo key={index} {...todo} />\n                ))}\n            </ul>\n        </div>\n    )\n    export default TodoList\n    {% endcodeblock %}\n            </td>\n        </tr>\n    </table>\n    \n添加页(AddTodo.js)添加 &lt;Link /&gt; 的代码如下：\n\n<table style=\"margin-left: auto; margin-right: auto;margin-top:-150px;\">\n        <tr>\n            <td>\n    {% codeblock %}\n    // AddTodo.js(添加Link前)\n    import React from 'react';\n\n    const AddTodo = () => {\n        return (\n            <div>\n                <h1>添加待办</h1>\n                <br />\n                <input type=\"text\" />\n                <button type=\"button\">Add</button>\n            </div>\n        )\n    }\n\n    export default AddTodo\n    {% endcodeblock %}                \n            </td>\n            <td>\n    {% codeblock %}\n    // AddTodo.js(添加Link后)\n    import React from 'react';\n    import { Link } from 'react-router-dom'\n    const AddTodo = () => {\n        return (\n            <div>\n                <h1>添加待办</h1>\n                <Link to=\"/\">返回</Link>\n                <br />\n                <input type=\"text\" />\n                <button type=\"button\">Add</button>\n            </div>\n        )\n    }\n    export default AddTodo\n    {% endcodeblock %}\n            </td>\n        </tr>\n    </table>\n\n## 2.3 使用&lt;Route /&gt;组件展现路由对应的UI\n\n上一个小节，我们列表页的路由为\"/\",AddTodo页面的路由为\"/addTodo\"。所以我们在使用&lt;Route /&gt;就使用这两个路由定义。&lt;Route /&gt;有三种方式渲染路由组件，\n\n1. component：component属性，直接配置需要展示的组件即可；\n2. render: render是一个方法，可以添加函数定义；而要展示的组件，通过return返回即可展示；\n3. children：children和render有一点类似，都是一个方法，不过children中的组件，无论路由是否匹配都会展示。\n\nPS: 当看到children属性的时候，我们可能会想到在react的组件树，父组件可以通过children组件获取到子组件。没错，这里的children和react中定义的是一样的。\n\n我们在app.js文件中定义&lt;Route /&gt;，代码如下(只展示render部分的代码)：\n<table style=\"margin-left: auto; margin-right: auto;margin-top:-150px;\">\n        <tr>\n            <td style=\"vertical-align: top;\">\n    {% codeblock %}\n    // app.js(添加Route前)\n    <div>\n        <TodoList todos={data} />\n        <AddTodo />\n    </div>\n    {% endcodeblock %}                \n            </td>\n            <td style=\"vertical-align: top;\">\n    {% codeblock %}\n    // app.js(添加Route后)\n    <div>\n        <Route exact path=\"/\" render={() => {\n            return (<TodoList todos={data} />)\n        }}/>\n        <Route path=\"/addTodo\" render={() => {\n            return (<AddTodo />)\n        }}/>\n    </div>\n    {% endcodeblock %}\n            </td>\n        </tr>\n    </table>\n\n# 3、结语\n\n以上就是，一个简单的使用了react-router的react SPA应用。详细代码请 {% link 戳这里 https://github.com/Two-Ftry/react-essay/tree/master/react-router-01 %}","source":"_posts/reactRouter1-fist-acquaintance-20190225.md","raw":"---\ntitle: reactRouter1-初识react router\ndate: 2019-02-25 17:43:09\ntags: react-router\n---\n\n设想，我们正在使用react构建一个单页应用（SPA），我们应该怎么设置路由呢？在页面没有刷新的情况下，要更改页面的某个部分或者整个页面，这时候就是使用前端路由的时候了。配合react构建SPA的路由框架非react-router莫属。react-router更新到4.0版本，其设计思想已经和前几个版本不一样。其设计的思路是\"动态路由\"。何为\"动态路由\"?就是路由发生在app的渲染过程中！那与之相对应的就是\"静态路由\"，静态路由是在应用初始化前就已经定义好路由信息。所以，从定义上看是完全不一样的，那在使用的过程中也会有很大差别。\n\n接下来我们看看react-router是如何工作的？\n\n- (1) 把&lt;Router /&gt;组件放到应用的最顶层\n- (2) 使用&lt;Link /&gt;组件定义路由\n- (3) 最后，使用&lt;Route /&gt;组件展现路由对应的UI\n\n如上，react-router会涉及到几个重要的组件，分别&lt;是Router /&gt;、&lt;Link /&gt;和&lt;Route /&gt;,翻译过来就是路由组件、导航组件和路由匹配组件。实际上，react-router也就是由这三类组件组成，所有这些组件都可以从\"react-router-dom\"这个npm包中导入使用。\n\n我们来看看路由组件&lt;Router /&gt;,针对web应用，react-router提供了&lt;BrowserRouter /&gt;和&lt;HashRouter /&gt;。除了实现原理不一样外，使用上也有区别，&lt;BrowserRouter /&gt;支持服务端渲染而&lt;HashRouter /&gt;不支持，所以在使用的时候得注意这一点。\n\n基于以上对react-router的简单认识，我们来把它使用起来，加深理解。假设我们在构建一个\"Todo应用\"，包含两个一面，一个待办列表页面，另一个是添加待办事项的页面。我们来一步步实现它。\n\n# 1、搭建环境\n\n要使用react-router，必须得把react的页面配置起来。我们简单地使用webpack来进行配置，并编写简单的页面，搭建起一个开发环境。目录信息如下：\n\n- package.json\n- webpack.config.js\n- src\n    - AddTodo.js (添加待办事项页面)\n    - app.js (顶层App组件)\n    - index.js (入口文件)\n    - Todo.js (待办事项)\n    - TodoList.js (待办事项列表页面)\n\n具体实现参考 {% link 这里 https://github.com/Two-Ftry/react-essay/tree/master/react-router-00 %} 。\n\n# 2、添加react-router\n\nreact-router 4.0+的三类组件（即路由组件、导航组件和路由匹配组件），都在\"react-router-dom\"这个npm包里面。我们先在项目根目录下安装依赖。\n\n{% codeblock %}\n> npm install -D react-router-dom\n{% endcodeblock %}\n\n依赖安装完成之后。我们来实现路由。按照上面提到的react-router工作的三个步骤，我们来一步步实现。\n\n## 2.1 添加&lt;Router /&gt;组件\n\n在app的顶层添加router组件，这里我们的index.js入口文件，就是整个web app的顶部，所以我们在index.js文件中添加&lt;Router /&gt;。\n\n{% codeblock %}\nimport React from 'react'\nimport ReactDOM from 'react-dom'\nimport { HashRouter as Router } from 'react-router-dom'\n\nimport App from './app'\n\nReactDOM.render(\n    <Router>\n        <App />\n    </Router>,\n    document.getElementsByTagName('BODY')[0],\n)\n{% endcodeblock %}\n\n这里我们使用HashRouter，因为是前端的简单实现，使用HashRouter和BrowserRouter都可。然后把&lt;Router /&gt;把  &lt; App /&gt;包裹起来，就完成任务了。\n\n但是Router到底做了些什么？为什么要加Router在顶层呢？\n\n## 2.2 使用&lt;Link /&gt;组件定义路由\n\ntodo应用的操作逻辑，进来之后首先展现列表页；从列表页，可以进入“添加页面”；而从“添加页面”又可以返回列表页，形成一个闭环。\n\n列表页(TodoList.js)添加 &lt;Link /&gt; 的代码如下：\n<table style=\"margin-left: auto; margin-right: auto;margin-top:-150px;\">\n        <tr>\n            <td>\n    {% codeblock %}\n    // TodoList.js(添加Link前)\n    import React from 'react'\n    import Todo from './Todo'\n\n    const TodoList = ({todos}) => (\n        <div>\n            <h1>待办列表</h1>\n            <ul>\n                {todos.map((todo, index) => (\n                    <Todo key={index} {...todo} />\n                ))}\n            </ul>\n        </div>\n    )\n\n    export default TodoList\n    {% endcodeblock %}                \n            </td>\n            <td>\n    {% codeblock %}\n    // TodoList.js(添加Link后)\n    import React from 'react'\n    import { Link } from 'react-router-dom'\n    import Todo from './Todo'\n    const TodoList = ({todos}) => (\n        <div>\n            <h1>待办列表</h1>\n            <Link to=\"addTodo\">添加</Link>\n            <ul>\n                {todos.map((todo, index) => (\n                    <Todo key={index} {...todo} />\n                ))}\n            </ul>\n        </div>\n    )\n    export default TodoList\n    {% endcodeblock %}\n            </td>\n        </tr>\n    </table>\n    \n添加页(AddTodo.js)添加 &lt;Link /&gt; 的代码如下：\n\n<table style=\"margin-left: auto; margin-right: auto;margin-top:-150px;\">\n        <tr>\n            <td>\n    {% codeblock %}\n    // AddTodo.js(添加Link前)\n    import React from 'react';\n\n    const AddTodo = () => {\n        return (\n            <div>\n                <h1>添加待办</h1>\n                <br />\n                <input type=\"text\" />\n                <button type=\"button\">Add</button>\n            </div>\n        )\n    }\n\n    export default AddTodo\n    {% endcodeblock %}                \n            </td>\n            <td>\n    {% codeblock %}\n    // AddTodo.js(添加Link后)\n    import React from 'react';\n    import { Link } from 'react-router-dom'\n    const AddTodo = () => {\n        return (\n            <div>\n                <h1>添加待办</h1>\n                <Link to=\"/\">返回</Link>\n                <br />\n                <input type=\"text\" />\n                <button type=\"button\">Add</button>\n            </div>\n        )\n    }\n    export default AddTodo\n    {% endcodeblock %}\n            </td>\n        </tr>\n    </table>\n\n## 2.3 使用&lt;Route /&gt;组件展现路由对应的UI\n\n上一个小节，我们列表页的路由为\"/\",AddTodo页面的路由为\"/addTodo\"。所以我们在使用&lt;Route /&gt;就使用这两个路由定义。&lt;Route /&gt;有三种方式渲染路由组件，\n\n1. component：component属性，直接配置需要展示的组件即可；\n2. render: render是一个方法，可以添加函数定义；而要展示的组件，通过return返回即可展示；\n3. children：children和render有一点类似，都是一个方法，不过children中的组件，无论路由是否匹配都会展示。\n\nPS: 当看到children属性的时候，我们可能会想到在react的组件树，父组件可以通过children组件获取到子组件。没错，这里的children和react中定义的是一样的。\n\n我们在app.js文件中定义&lt;Route /&gt;，代码如下(只展示render部分的代码)：\n<table style=\"margin-left: auto; margin-right: auto;margin-top:-150px;\">\n        <tr>\n            <td style=\"vertical-align: top;\">\n    {% codeblock %}\n    // app.js(添加Route前)\n    <div>\n        <TodoList todos={data} />\n        <AddTodo />\n    </div>\n    {% endcodeblock %}                \n            </td>\n            <td style=\"vertical-align: top;\">\n    {% codeblock %}\n    // app.js(添加Route后)\n    <div>\n        <Route exact path=\"/\" render={() => {\n            return (<TodoList todos={data} />)\n        }}/>\n        <Route path=\"/addTodo\" render={() => {\n            return (<AddTodo />)\n        }}/>\n    </div>\n    {% endcodeblock %}\n            </td>\n        </tr>\n    </table>\n\n# 3、结语\n\n以上就是，一个简单的使用了react-router的react SPA应用。详细代码请 {% link 戳这里 https://github.com/Two-Ftry/react-essay/tree/master/react-router-01 %}","slug":"reactRouter1-fist-acquaintance","published":1,"updated":"2019-03-12T05:26:03.466Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvop9000n4c41byz0t6sr","content":"<p>设想，我们正在使用react构建一个单页应用（SPA），我们应该怎么设置路由呢？在页面没有刷新的情况下，要更改页面的某个部分或者整个页面，这时候就是使用前端路由的时候了。配合react构建SPA的路由框架非react-router莫属。react-router更新到4.0版本，其设计思想已经和前几个版本不一样。其设计的思路是”动态路由”。何为”动态路由”?就是路由发生在app的渲染过程中！那与之相对应的就是”静态路由”，静态路由是在应用初始化前就已经定义好路由信息。所以，从定义上看是完全不一样的，那在使用的过程中也会有很大差别。</p>\n<p>接下来我们看看react-router是如何工作的？</p>\n<ul>\n<li>(1) 把&lt;Router /&gt;组件放到应用的最顶层</li>\n<li>(2) 使用&lt;Link /&gt;组件定义路由</li>\n<li>(3) 最后，使用&lt;Route /&gt;组件展现路由对应的UI</li>\n</ul>\n<p>如上，react-router会涉及到几个重要的组件，分别&lt;是Router /&gt;、&lt;Link /&gt;和&lt;Route /&gt;,翻译过来就是路由组件、导航组件和路由匹配组件。实际上，react-router也就是由这三类组件组成，所有这些组件都可以从”react-router-dom”这个npm包中导入使用。</p>\n<p>我们来看看路由组件&lt;Router /&gt;,针对web应用，react-router提供了&lt;BrowserRouter /&gt;和&lt;HashRouter /&gt;。除了实现原理不一样外，使用上也有区别，&lt;BrowserRouter /&gt;支持服务端渲染而&lt;HashRouter /&gt;不支持，所以在使用的时候得注意这一点。</p>\n<p>基于以上对react-router的简单认识，我们来把它使用起来，加深理解。假设我们在构建一个”Todo应用”，包含两个一面，一个待办列表页面，另一个是添加待办事项的页面。我们来一步步实现它。</p>\n<h1 id=\"1、搭建环境\"><a href=\"#1、搭建环境\" class=\"headerlink\" title=\"1、搭建环境\"></a>1、搭建环境</h1><p>要使用react-router，必须得把react的页面配置起来。我们简单地使用webpack来进行配置，并编写简单的页面，搭建起一个开发环境。目录信息如下：</p>\n<ul>\n<li>package.json</li>\n<li>webpack.config.js</li>\n<li>src<ul>\n<li>AddTodo.js (添加待办事项页面)</li>\n<li>app.js (顶层App组件)</li>\n<li>index.js (入口文件)</li>\n<li>Todo.js (待办事项)</li>\n<li>TodoList.js (待办事项列表页面)</li>\n</ul>\n</li>\n</ul>\n<p>具体实现参考 <a href=\"https://github.com/Two-Ftry/react-essay/tree/master/react-router-00\" target=\"_blank\" rel=\"noopener\">这里</a> 。</p>\n<h1 id=\"2、添加react-router\"><a href=\"#2、添加react-router\" class=\"headerlink\" title=\"2、添加react-router\"></a>2、添加react-router</h1><p>react-router 4.0+的三类组件（即路由组件、导航组件和路由匹配组件），都在”react-router-dom”这个npm包里面。我们先在项目根目录下安装依赖。</p>\n<pre><code>&gt; npm install -D react-router-dom</code></pre>\n<p>依赖安装完成之后。我们来实现路由。按照上面提到的react-router工作的三个步骤，我们来一步步实现。</p>\n<h2 id=\"2-1-添加-lt-Router-gt-组件\"><a href=\"#2-1-添加-lt-Router-gt-组件\" class=\"headerlink\" title=\"2.1 添加&lt;Router /&gt;组件\"></a>2.1 添加&lt;Router /&gt;组件</h2><p>在app的顶层添加router组件，这里我们的index.js入口文件，就是整个web app的顶部，所以我们在index.js文件中添加&lt;Router /&gt;。</p>\n<pre><code>import React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\nimport { HashRouter as Router } from &#39;react-router-dom&#39;\n\nimport App from &#39;.&#x2F;app&#39;\n\nReactDOM.render(\n    &lt;Router&gt;\n        &lt;App &#x2F;&gt;\n    &lt;&#x2F;Router&gt;,\n    document.getElementsByTagName(&#39;BODY&#39;)[0],\n)</code></pre>\n<p>这里我们使用HashRouter，因为是前端的简单实现，使用HashRouter和BrowserRouter都可。然后把&lt;Router /&gt;把  &lt; App /&gt;包裹起来，就完成任务了。</p>\n<p>但是Router到底做了些什么？为什么要加Router在顶层呢？</p>\n<h2 id=\"2-2-使用-lt-Link-gt-组件定义路由\"><a href=\"#2-2-使用-lt-Link-gt-组件定义路由\" class=\"headerlink\" title=\"2.2 使用&lt;Link /&gt;组件定义路由\"></a>2.2 使用&lt;Link /&gt;组件定义路由</h2><p>todo应用的操作逻辑，进来之后首先展现列表页；从列表页，可以进入“添加页面”；而从“添加页面”又可以返回列表页，形成一个闭环。</p>\n<p>列表页(TodoList.js)添加 &lt;Link /&gt; 的代码如下：</p>\n<table style=\"margin-left: auto; margin-right: auto;margin-top:-150px;\"><br>        <tr><br>            <td><br>    <pre><code>&#x2F;&#x2F; TodoList.js(添加Link前)\nimport React from &#39;react&#39;\nimport Todo from &#39;.&#x2F;Todo&#39;\n\nconst TodoList = ({todos}) =&gt; (\n    &lt;div&gt;\n        &lt;h1&gt;待办列表&lt;&#x2F;h1&gt;\n        &lt;ul&gt;\n            {todos.map((todo, index) =&gt; (\n                &lt;Todo key={index} {...todo} &#x2F;&gt;\n            ))}\n        &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n)\n\nexport default TodoList</code></pre><br>            </td><br>            <td><br>    <pre><code>&#x2F;&#x2F; TodoList.js(添加Link后)\nimport React from &#39;react&#39;\nimport { Link } from &#39;react-router-dom&#39;\nimport Todo from &#39;.&#x2F;Todo&#39;\nconst TodoList = ({todos}) =&gt; (\n    &lt;div&gt;\n        &lt;h1&gt;待办列表&lt;&#x2F;h1&gt;\n        &lt;Link to=&quot;addTodo&quot;&gt;添加&lt;&#x2F;Link&gt;\n        &lt;ul&gt;\n            {todos.map((todo, index) =&gt; (\n                &lt;Todo key={index} {...todo} &#x2F;&gt;\n            ))}\n        &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n)\nexport default TodoList</code></pre><br>            </td><br>        </tr><br>    </table>\n\n<p>添加页(AddTodo.js)添加 &lt;Link /&gt; 的代码如下：</p>\n<table style=\"margin-left: auto; margin-right: auto;margin-top:-150px;\"><br>        <tr><br>            <td><br>    <pre><code>&#x2F;&#x2F; AddTodo.js(添加Link前)\nimport React from &#39;react&#39;;\n\nconst AddTodo = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;添加待办&lt;&#x2F;h1&gt;\n            &lt;br &#x2F;&gt;\n            &lt;input type=&quot;text&quot; &#x2F;&gt;\n            &lt;button type=&quot;button&quot;&gt;Add&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n}\n\nexport default AddTodo</code></pre><br>            </td><br>            <td><br>    <pre><code>&#x2F;&#x2F; AddTodo.js(添加Link后)\nimport React from &#39;react&#39;;\nimport { Link } from &#39;react-router-dom&#39;\nconst AddTodo = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;添加待办&lt;&#x2F;h1&gt;\n            &lt;Link to=&quot;&#x2F;&quot;&gt;返回&lt;&#x2F;Link&gt;\n            &lt;br &#x2F;&gt;\n            &lt;input type=&quot;text&quot; &#x2F;&gt;\n            &lt;button type=&quot;button&quot;&gt;Add&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n}\nexport default AddTodo</code></pre><br>            </td><br>        </tr><br>    </table>\n\n<h2 id=\"2-3-使用-lt-Route-gt-组件展现路由对应的UI\"><a href=\"#2-3-使用-lt-Route-gt-组件展现路由对应的UI\" class=\"headerlink\" title=\"2.3 使用&lt;Route /&gt;组件展现路由对应的UI\"></a>2.3 使用&lt;Route /&gt;组件展现路由对应的UI</h2><p>上一个小节，我们列表页的路由为”/“,AddTodo页面的路由为”/addTodo”。所以我们在使用&lt;Route /&gt;就使用这两个路由定义。&lt;Route /&gt;有三种方式渲染路由组件，</p>\n<ol>\n<li>component：component属性，直接配置需要展示的组件即可；</li>\n<li>render: render是一个方法，可以添加函数定义；而要展示的组件，通过return返回即可展示；</li>\n<li>children：children和render有一点类似，都是一个方法，不过children中的组件，无论路由是否匹配都会展示。</li>\n</ol>\n<p>PS: 当看到children属性的时候，我们可能会想到在react的组件树，父组件可以通过children组件获取到子组件。没错，这里的children和react中定义的是一样的。</p>\n<p>我们在app.js文件中定义&lt;Route /&gt;，代码如下(只展示render部分的代码)：</p>\n<table style=\"margin-left: auto; margin-right: auto;margin-top:-150px;\"><br>        <tr><br>            <td style=\"vertical-align: top;\"><br>    <pre><code>&#x2F;&#x2F; app.js(添加Route前)\n&lt;div&gt;\n    &lt;TodoList todos={data} &#x2F;&gt;\n    &lt;AddTodo &#x2F;&gt;\n&lt;&#x2F;div&gt;</code></pre><br>            </td><br>            <td style=\"vertical-align: top;\"><br>    <pre><code>&#x2F;&#x2F; app.js(添加Route后)\n&lt;div&gt;\n    &lt;Route exact path=&quot;&#x2F;&quot; render={() =&gt; {\n        return (&lt;TodoList todos={data} &#x2F;&gt;)\n    }}&#x2F;&gt;\n    &lt;Route path=&quot;&#x2F;addTodo&quot; render={() =&gt; {\n        return (&lt;AddTodo &#x2F;&gt;)\n    }}&#x2F;&gt;\n&lt;&#x2F;div&gt;</code></pre><br>            </td><br>        </tr><br>    </table>\n\n<h1 id=\"3、结语\"><a href=\"#3、结语\" class=\"headerlink\" title=\"3、结语\"></a>3、结语</h1><p>以上就是，一个简单的使用了react-router的react SPA应用。详细代码请 <a href=\"https://github.com/Two-Ftry/react-essay/tree/master/react-router-01\" target=\"_blank\" rel=\"noopener\">戳这里</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>设想，我们正在使用react构建一个单页应用（SPA），我们应该怎么设置路由呢？在页面没有刷新的情况下，要更改页面的某个部分或者整个页面，这时候就是使用前端路由的时候了。配合react构建SPA的路由框架非react-router莫属。react-router更新到4.0版本，其设计思想已经和前几个版本不一样。其设计的思路是”动态路由”。何为”动态路由”?就是路由发生在app的渲染过程中！那与之相对应的就是”静态路由”，静态路由是在应用初始化前就已经定义好路由信息。所以，从定义上看是完全不一样的，那在使用的过程中也会有很大差别。</p>\n<p>接下来我们看看react-router是如何工作的？</p>\n<ul>\n<li>(1) 把&lt;Router /&gt;组件放到应用的最顶层</li>\n<li>(2) 使用&lt;Link /&gt;组件定义路由</li>\n<li>(3) 最后，使用&lt;Route /&gt;组件展现路由对应的UI</li>\n</ul>\n<p>如上，react-router会涉及到几个重要的组件，分别&lt;是Router /&gt;、&lt;Link /&gt;和&lt;Route /&gt;,翻译过来就是路由组件、导航组件和路由匹配组件。实际上，react-router也就是由这三类组件组成，所有这些组件都可以从”react-router-dom”这个npm包中导入使用。</p>\n<p>我们来看看路由组件&lt;Router /&gt;,针对web应用，react-router提供了&lt;BrowserRouter /&gt;和&lt;HashRouter /&gt;。除了实现原理不一样外，使用上也有区别，&lt;BrowserRouter /&gt;支持服务端渲染而&lt;HashRouter /&gt;不支持，所以在使用的时候得注意这一点。</p>\n<p>基于以上对react-router的简单认识，我们来把它使用起来，加深理解。假设我们在构建一个”Todo应用”，包含两个一面，一个待办列表页面，另一个是添加待办事项的页面。我们来一步步实现它。</p>\n<h1 id=\"1、搭建环境\"><a href=\"#1、搭建环境\" class=\"headerlink\" title=\"1、搭建环境\"></a>1、搭建环境</h1><p>要使用react-router，必须得把react的页面配置起来。我们简单地使用webpack来进行配置，并编写简单的页面，搭建起一个开发环境。目录信息如下：</p>\n<ul>\n<li>package.json</li>\n<li>webpack.config.js</li>\n<li>src<ul>\n<li>AddTodo.js (添加待办事项页面)</li>\n<li>app.js (顶层App组件)</li>\n<li>index.js (入口文件)</li>\n<li>Todo.js (待办事项)</li>\n<li>TodoList.js (待办事项列表页面)</li>\n</ul>\n</li>\n</ul>\n<p>具体实现参考 <a href=\"https://github.com/Two-Ftry/react-essay/tree/master/react-router-00\" target=\"_blank\" rel=\"noopener\">这里</a> 。</p>\n<h1 id=\"2、添加react-router\"><a href=\"#2、添加react-router\" class=\"headerlink\" title=\"2、添加react-router\"></a>2、添加react-router</h1><p>react-router 4.0+的三类组件（即路由组件、导航组件和路由匹配组件），都在”react-router-dom”这个npm包里面。我们先在项目根目录下安装依赖。</p>\n<pre><code>&gt; npm install -D react-router-dom</code></pre>\n<p>依赖安装完成之后。我们来实现路由。按照上面提到的react-router工作的三个步骤，我们来一步步实现。</p>\n<h2 id=\"2-1-添加-lt-Router-gt-组件\"><a href=\"#2-1-添加-lt-Router-gt-组件\" class=\"headerlink\" title=\"2.1 添加&lt;Router /&gt;组件\"></a>2.1 添加&lt;Router /&gt;组件</h2><p>在app的顶层添加router组件，这里我们的index.js入口文件，就是整个web app的顶部，所以我们在index.js文件中添加&lt;Router /&gt;。</p>\n<pre><code>import React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\nimport { HashRouter as Router } from &#39;react-router-dom&#39;\n\nimport App from &#39;.&#x2F;app&#39;\n\nReactDOM.render(\n    &lt;Router&gt;\n        &lt;App &#x2F;&gt;\n    &lt;&#x2F;Router&gt;,\n    document.getElementsByTagName(&#39;BODY&#39;)[0],\n)</code></pre>\n<p>这里我们使用HashRouter，因为是前端的简单实现，使用HashRouter和BrowserRouter都可。然后把&lt;Router /&gt;把  &lt; App /&gt;包裹起来，就完成任务了。</p>\n<p>但是Router到底做了些什么？为什么要加Router在顶层呢？</p>\n<h2 id=\"2-2-使用-lt-Link-gt-组件定义路由\"><a href=\"#2-2-使用-lt-Link-gt-组件定义路由\" class=\"headerlink\" title=\"2.2 使用&lt;Link /&gt;组件定义路由\"></a>2.2 使用&lt;Link /&gt;组件定义路由</h2><p>todo应用的操作逻辑，进来之后首先展现列表页；从列表页，可以进入“添加页面”；而从“添加页面”又可以返回列表页，形成一个闭环。</p>\n<p>列表页(TodoList.js)添加 &lt;Link /&gt; 的代码如下：</p>\n<table style=\"margin-left: auto; margin-right: auto;margin-top:-150px;\"><br>        <tr><br>            <td><br>    <pre><code>&#x2F;&#x2F; TodoList.js(添加Link前)\nimport React from &#39;react&#39;\nimport Todo from &#39;.&#x2F;Todo&#39;\n\nconst TodoList = ({todos}) =&gt; (\n    &lt;div&gt;\n        &lt;h1&gt;待办列表&lt;&#x2F;h1&gt;\n        &lt;ul&gt;\n            {todos.map((todo, index) =&gt; (\n                &lt;Todo key={index} {...todo} &#x2F;&gt;\n            ))}\n        &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n)\n\nexport default TodoList</code></pre><br>            </td><br>            <td><br>    <pre><code>&#x2F;&#x2F; TodoList.js(添加Link后)\nimport React from &#39;react&#39;\nimport { Link } from &#39;react-router-dom&#39;\nimport Todo from &#39;.&#x2F;Todo&#39;\nconst TodoList = ({todos}) =&gt; (\n    &lt;div&gt;\n        &lt;h1&gt;待办列表&lt;&#x2F;h1&gt;\n        &lt;Link to=&quot;addTodo&quot;&gt;添加&lt;&#x2F;Link&gt;\n        &lt;ul&gt;\n            {todos.map((todo, index) =&gt; (\n                &lt;Todo key={index} {...todo} &#x2F;&gt;\n            ))}\n        &lt;&#x2F;ul&gt;\n    &lt;&#x2F;div&gt;\n)\nexport default TodoList</code></pre><br>            </td><br>        </tr><br>    </table>\n\n<p>添加页(AddTodo.js)添加 &lt;Link /&gt; 的代码如下：</p>\n<table style=\"margin-left: auto; margin-right: auto;margin-top:-150px;\"><br>        <tr><br>            <td><br>    <pre><code>&#x2F;&#x2F; AddTodo.js(添加Link前)\nimport React from &#39;react&#39;;\n\nconst AddTodo = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;添加待办&lt;&#x2F;h1&gt;\n            &lt;br &#x2F;&gt;\n            &lt;input type=&quot;text&quot; &#x2F;&gt;\n            &lt;button type=&quot;button&quot;&gt;Add&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n}\n\nexport default AddTodo</code></pre><br>            </td><br>            <td><br>    <pre><code>&#x2F;&#x2F; AddTodo.js(添加Link后)\nimport React from &#39;react&#39;;\nimport { Link } from &#39;react-router-dom&#39;\nconst AddTodo = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;h1&gt;添加待办&lt;&#x2F;h1&gt;\n            &lt;Link to=&quot;&#x2F;&quot;&gt;返回&lt;&#x2F;Link&gt;\n            &lt;br &#x2F;&gt;\n            &lt;input type=&quot;text&quot; &#x2F;&gt;\n            &lt;button type=&quot;button&quot;&gt;Add&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n}\nexport default AddTodo</code></pre><br>            </td><br>        </tr><br>    </table>\n\n<h2 id=\"2-3-使用-lt-Route-gt-组件展现路由对应的UI\"><a href=\"#2-3-使用-lt-Route-gt-组件展现路由对应的UI\" class=\"headerlink\" title=\"2.3 使用&lt;Route /&gt;组件展现路由对应的UI\"></a>2.3 使用&lt;Route /&gt;组件展现路由对应的UI</h2><p>上一个小节，我们列表页的路由为”/“,AddTodo页面的路由为”/addTodo”。所以我们在使用&lt;Route /&gt;就使用这两个路由定义。&lt;Route /&gt;有三种方式渲染路由组件，</p>\n<ol>\n<li>component：component属性，直接配置需要展示的组件即可；</li>\n<li>render: render是一个方法，可以添加函数定义；而要展示的组件，通过return返回即可展示；</li>\n<li>children：children和render有一点类似，都是一个方法，不过children中的组件，无论路由是否匹配都会展示。</li>\n</ol>\n<p>PS: 当看到children属性的时候，我们可能会想到在react的组件树，父组件可以通过children组件获取到子组件。没错，这里的children和react中定义的是一样的。</p>\n<p>我们在app.js文件中定义&lt;Route /&gt;，代码如下(只展示render部分的代码)：</p>\n<table style=\"margin-left: auto; margin-right: auto;margin-top:-150px;\"><br>        <tr><br>            <td style=\"vertical-align: top;\"><br>    <pre><code>&#x2F;&#x2F; app.js(添加Route前)\n&lt;div&gt;\n    &lt;TodoList todos={data} &#x2F;&gt;\n    &lt;AddTodo &#x2F;&gt;\n&lt;&#x2F;div&gt;</code></pre><br>            </td><br>            <td style=\"vertical-align: top;\"><br>    <pre><code>&#x2F;&#x2F; app.js(添加Route后)\n&lt;div&gt;\n    &lt;Route exact path=&quot;&#x2F;&quot; render={() =&gt; {\n        return (&lt;TodoList todos={data} &#x2F;&gt;)\n    }}&#x2F;&gt;\n    &lt;Route path=&quot;&#x2F;addTodo&quot; render={() =&gt; {\n        return (&lt;AddTodo &#x2F;&gt;)\n    }}&#x2F;&gt;\n&lt;&#x2F;div&gt;</code></pre><br>            </td><br>        </tr><br>    </table>\n\n<h1 id=\"3、结语\"><a href=\"#3、结语\" class=\"headerlink\" title=\"3、结语\"></a>3、结语</h1><p>以上就是，一个简单的使用了react-router的react SPA应用。详细代码请 <a href=\"https://github.com/Two-Ftry/react-essay/tree/master/react-router-01\" target=\"_blank\" rel=\"noopener\">戳这里</a></p>\n"},{"title":"reactRouter2-skills","date":"2019-03-20T09:18:16.000Z","_content":"\nreact-router由路由组件、导航组件和路由匹配组件这三类组件构成。整体使用上不复杂。但是在使用上也有一些技巧。本文，我们就来看看在实际开发中会使用到的react-router的技巧吧。\n\n## 1、处理当前选中菜单\n\n效果如下：\n<div style=\"border: 1px solid #ccc;\">\n![routerskill1](router-children.gif)\n</div>\n\n在上图的效果里面，我们看到当选中当前菜单后，对应的菜单不再可以点击。我们分两步来处理这个问题，首先我们要有路由，使用&lt;Link /&gt;组件就可以实现。\n\n{% codeblock %}\n<ul>\n    <li>\n        <Link to=\"/\">列表页</Link>\n    </li>\n    <li>\n        <Link to=\"/addTodo\">添加页</Link>\n    </li>\n</ul>\n{% endcodeblock %}\n\n&lt;Link /&gt;组件默认会为我们生成一个a标签，点击这个标签就可以进行跳转。那我们如何让当前选中的菜单不可被点击呢？这就需要用到&lt;Route /&gt;组件的一个children属性。children是一个方法，Route会显示children方法中返回的内容；无论&lt;Route /&gt;组件的path是否匹配当前路由，都会显示出来。如果匹配，传入的match参数会包含路由信息，否则match参数为空。利用这个特性，我们就可以实现想要的效果啦。\n\n{% codeblock %}\n<ul>\n    <li>\n        <Route exact path=\"/\">\n            {\n                ({ match }) => {\n                    if (match) {\n                        return (<span>列表页</span>)\n                    }\n                    return (<Link to=\"/\">列表页</Link>)\n                }\n            }\n        </Route>  \n    </li>\n    <li>\n        <Route exact path=\"/addTodo\">\n            {\n                ({match}) => {\n                    if (match) {\n                        return (<span>添加页</span>)\n                    }\n                    return (<Link to=\"/addTodo\">添加页</Link>)\n                }\n            }\n        </Route>   \n    </li>\n</ul>\n{% endcodeblock %}\n\n## 2、404\n\nreact-router中有一个&lt;Switch /&gt;组件，它的作用是只显示第一个匹配到的路由对应的组件。利用这个特性，可以做404页面的展示。\n\n在&lt;Switch /&gt;的子组件中，把支持的路由写在前面，最后加一个没有path属性的路由，并将路由组件设置为404的提示，就能实现404的功能。\n\n{% codeblock %}\n<Switch>\n    <Route exact path=\"/\" render={ () => {\n        return (<TodoList todos={data} />)\n    }} />\n    <Route path=\"/addTodo\" component={AddTodo} />\n    <Route component={Page404} />\n</Switch>\n{% endcodeblock %}\n\n效果如下：\n\n<div style=\"border: 1px solid #ccc;\">\n![routerskill2](router-404.gif)\n</div>\n\n## 3、demo地址\n\n上面两个小技巧的demo地址在 {% link 这里 https://github.com/Two-Ftry/react-essay/tree/master/react-router-02 %} 。","source":"_posts/reactRouter2-skills-20190320.md","raw":"---\ntitle: reactRouter2-skills\ndate: 2019-03-20 17:18:16\ntags: react router\n---\n\nreact-router由路由组件、导航组件和路由匹配组件这三类组件构成。整体使用上不复杂。但是在使用上也有一些技巧。本文，我们就来看看在实际开发中会使用到的react-router的技巧吧。\n\n## 1、处理当前选中菜单\n\n效果如下：\n<div style=\"border: 1px solid #ccc;\">\n![routerskill1](router-children.gif)\n</div>\n\n在上图的效果里面，我们看到当选中当前菜单后，对应的菜单不再可以点击。我们分两步来处理这个问题，首先我们要有路由，使用&lt;Link /&gt;组件就可以实现。\n\n{% codeblock %}\n<ul>\n    <li>\n        <Link to=\"/\">列表页</Link>\n    </li>\n    <li>\n        <Link to=\"/addTodo\">添加页</Link>\n    </li>\n</ul>\n{% endcodeblock %}\n\n&lt;Link /&gt;组件默认会为我们生成一个a标签，点击这个标签就可以进行跳转。那我们如何让当前选中的菜单不可被点击呢？这就需要用到&lt;Route /&gt;组件的一个children属性。children是一个方法，Route会显示children方法中返回的内容；无论&lt;Route /&gt;组件的path是否匹配当前路由，都会显示出来。如果匹配，传入的match参数会包含路由信息，否则match参数为空。利用这个特性，我们就可以实现想要的效果啦。\n\n{% codeblock %}\n<ul>\n    <li>\n        <Route exact path=\"/\">\n            {\n                ({ match }) => {\n                    if (match) {\n                        return (<span>列表页</span>)\n                    }\n                    return (<Link to=\"/\">列表页</Link>)\n                }\n            }\n        </Route>  \n    </li>\n    <li>\n        <Route exact path=\"/addTodo\">\n            {\n                ({match}) => {\n                    if (match) {\n                        return (<span>添加页</span>)\n                    }\n                    return (<Link to=\"/addTodo\">添加页</Link>)\n                }\n            }\n        </Route>   \n    </li>\n</ul>\n{% endcodeblock %}\n\n## 2、404\n\nreact-router中有一个&lt;Switch /&gt;组件，它的作用是只显示第一个匹配到的路由对应的组件。利用这个特性，可以做404页面的展示。\n\n在&lt;Switch /&gt;的子组件中，把支持的路由写在前面，最后加一个没有path属性的路由，并将路由组件设置为404的提示，就能实现404的功能。\n\n{% codeblock %}\n<Switch>\n    <Route exact path=\"/\" render={ () => {\n        return (<TodoList todos={data} />)\n    }} />\n    <Route path=\"/addTodo\" component={AddTodo} />\n    <Route component={Page404} />\n</Switch>\n{% endcodeblock %}\n\n效果如下：\n\n<div style=\"border: 1px solid #ccc;\">\n![routerskill2](router-404.gif)\n</div>\n\n## 3、demo地址\n\n上面两个小技巧的demo地址在 {% link 这里 https://github.com/Two-Ftry/react-essay/tree/master/react-router-02 %} 。","slug":"reactRouter2-skills","published":1,"updated":"2019-03-29T11:13:41.497Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvopc000p4c41a24v7341","content":"<p>react-router由路由组件、导航组件和路由匹配组件这三类组件构成。整体使用上不复杂。但是在使用上也有一些技巧。本文，我们就来看看在实际开发中会使用到的react-router的技巧吧。</p>\n<h2 id=\"1、处理当前选中菜单\"><a href=\"#1、处理当前选中菜单\" class=\"headerlink\" title=\"1、处理当前选中菜单\"></a>1、处理当前选中菜单</h2><p>效果如下：</p>\n<div style=\"border: 1px solid #ccc;\"><br><img src=\"/2019/03/20/reactRouter2-skills/router-children.gif\" alt=\"routerskill1\"><br></div>\n\n<p>在上图的效果里面，我们看到当选中当前菜单后，对应的菜单不再可以点击。我们分两步来处理这个问题，首先我们要有路由，使用&lt;Link /&gt;组件就可以实现。</p>\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;\n        &lt;Link to=&quot;&#x2F;&quot;&gt;列表页&lt;&#x2F;Link&gt;\n    &lt;&#x2F;li&gt;\n    &lt;li&gt;\n        &lt;Link to=&quot;&#x2F;addTodo&quot;&gt;添加页&lt;&#x2F;Link&gt;\n    &lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;</code></pre>\n<p>&lt;Link /&gt;组件默认会为我们生成一个a标签，点击这个标签就可以进行跳转。那我们如何让当前选中的菜单不可被点击呢？这就需要用到&lt;Route /&gt;组件的一个children属性。children是一个方法，Route会显示children方法中返回的内容；无论&lt;Route /&gt;组件的path是否匹配当前路由，都会显示出来。如果匹配，传入的match参数会包含路由信息，否则match参数为空。利用这个特性，我们就可以实现想要的效果啦。</p>\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;\n        &lt;Route exact path=&quot;&#x2F;&quot;&gt;\n            {\n                ({ match }) =&gt; {\n                    if (match) {\n                        return (&lt;span&gt;列表页&lt;&#x2F;span&gt;)\n                    }\n                    return (&lt;Link to=&quot;&#x2F;&quot;&gt;列表页&lt;&#x2F;Link&gt;)\n                }\n            }\n        &lt;&#x2F;Route&gt;  \n    &lt;&#x2F;li&gt;\n    &lt;li&gt;\n        &lt;Route exact path=&quot;&#x2F;addTodo&quot;&gt;\n            {\n                ({match}) =&gt; {\n                    if (match) {\n                        return (&lt;span&gt;添加页&lt;&#x2F;span&gt;)\n                    }\n                    return (&lt;Link to=&quot;&#x2F;addTodo&quot;&gt;添加页&lt;&#x2F;Link&gt;)\n                }\n            }\n        &lt;&#x2F;Route&gt;   \n    &lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;</code></pre>\n<h2 id=\"2、404\"><a href=\"#2、404\" class=\"headerlink\" title=\"2、404\"></a>2、404</h2><p>react-router中有一个&lt;Switch /&gt;组件，它的作用是只显示第一个匹配到的路由对应的组件。利用这个特性，可以做404页面的展示。</p>\n<p>在&lt;Switch /&gt;的子组件中，把支持的路由写在前面，最后加一个没有path属性的路由，并将路由组件设置为404的提示，就能实现404的功能。</p>\n<pre><code>&lt;Switch&gt;\n    &lt;Route exact path=&quot;&#x2F;&quot; render={ () =&gt; {\n        return (&lt;TodoList todos={data} &#x2F;&gt;)\n    }} &#x2F;&gt;\n    &lt;Route path=&quot;&#x2F;addTodo&quot; component={AddTodo} &#x2F;&gt;\n    &lt;Route component={Page404} &#x2F;&gt;\n&lt;&#x2F;Switch&gt;</code></pre>\n<p>效果如下：</p>\n<div style=\"border: 1px solid #ccc;\"><br><img src=\"/2019/03/20/reactRouter2-skills/router-404.gif\" alt=\"routerskill2\"><br></div>\n\n<h2 id=\"3、demo地址\"><a href=\"#3、demo地址\" class=\"headerlink\" title=\"3、demo地址\"></a>3、demo地址</h2><p>上面两个小技巧的demo地址在 <a href=\"https://github.com/Two-Ftry/react-essay/tree/master/react-router-02\" target=\"_blank\" rel=\"noopener\">这里</a> 。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>react-router由路由组件、导航组件和路由匹配组件这三类组件构成。整体使用上不复杂。但是在使用上也有一些技巧。本文，我们就来看看在实际开发中会使用到的react-router的技巧吧。</p>\n<h2 id=\"1、处理当前选中菜单\"><a href=\"#1、处理当前选中菜单\" class=\"headerlink\" title=\"1、处理当前选中菜单\"></a>1、处理当前选中菜单</h2><p>效果如下：</p>\n<div style=\"border: 1px solid #ccc;\"><br><img src=\"/2019/03/20/reactRouter2-skills/router-children.gif\" alt=\"routerskill1\"><br></div>\n\n<p>在上图的效果里面，我们看到当选中当前菜单后，对应的菜单不再可以点击。我们分两步来处理这个问题，首先我们要有路由，使用&lt;Link /&gt;组件就可以实现。</p>\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;\n        &lt;Link to=&quot;&#x2F;&quot;&gt;列表页&lt;&#x2F;Link&gt;\n    &lt;&#x2F;li&gt;\n    &lt;li&gt;\n        &lt;Link to=&quot;&#x2F;addTodo&quot;&gt;添加页&lt;&#x2F;Link&gt;\n    &lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;</code></pre>\n<p>&lt;Link /&gt;组件默认会为我们生成一个a标签，点击这个标签就可以进行跳转。那我们如何让当前选中的菜单不可被点击呢？这就需要用到&lt;Route /&gt;组件的一个children属性。children是一个方法，Route会显示children方法中返回的内容；无论&lt;Route /&gt;组件的path是否匹配当前路由，都会显示出来。如果匹配，传入的match参数会包含路由信息，否则match参数为空。利用这个特性，我们就可以实现想要的效果啦。</p>\n<pre><code>&lt;ul&gt;\n    &lt;li&gt;\n        &lt;Route exact path=&quot;&#x2F;&quot;&gt;\n            {\n                ({ match }) =&gt; {\n                    if (match) {\n                        return (&lt;span&gt;列表页&lt;&#x2F;span&gt;)\n                    }\n                    return (&lt;Link to=&quot;&#x2F;&quot;&gt;列表页&lt;&#x2F;Link&gt;)\n                }\n            }\n        &lt;&#x2F;Route&gt;  \n    &lt;&#x2F;li&gt;\n    &lt;li&gt;\n        &lt;Route exact path=&quot;&#x2F;addTodo&quot;&gt;\n            {\n                ({match}) =&gt; {\n                    if (match) {\n                        return (&lt;span&gt;添加页&lt;&#x2F;span&gt;)\n                    }\n                    return (&lt;Link to=&quot;&#x2F;addTodo&quot;&gt;添加页&lt;&#x2F;Link&gt;)\n                }\n            }\n        &lt;&#x2F;Route&gt;   \n    &lt;&#x2F;li&gt;\n&lt;&#x2F;ul&gt;</code></pre>\n<h2 id=\"2、404\"><a href=\"#2、404\" class=\"headerlink\" title=\"2、404\"></a>2、404</h2><p>react-router中有一个&lt;Switch /&gt;组件，它的作用是只显示第一个匹配到的路由对应的组件。利用这个特性，可以做404页面的展示。</p>\n<p>在&lt;Switch /&gt;的子组件中，把支持的路由写在前面，最后加一个没有path属性的路由，并将路由组件设置为404的提示，就能实现404的功能。</p>\n<pre><code>&lt;Switch&gt;\n    &lt;Route exact path=&quot;&#x2F;&quot; render={ () =&gt; {\n        return (&lt;TodoList todos={data} &#x2F;&gt;)\n    }} &#x2F;&gt;\n    &lt;Route path=&quot;&#x2F;addTodo&quot; component={AddTodo} &#x2F;&gt;\n    &lt;Route component={Page404} &#x2F;&gt;\n&lt;&#x2F;Switch&gt;</code></pre>\n<p>效果如下：</p>\n<div style=\"border: 1px solid #ccc;\"><br><img src=\"/2019/03/20/reactRouter2-skills/router-404.gif\" alt=\"routerskill2\"><br></div>\n\n<h2 id=\"3、demo地址\"><a href=\"#3、demo地址\" class=\"headerlink\" title=\"3、demo地址\"></a>3、demo地址</h2><p>上面两个小技巧的demo地址在 <a href=\"https://github.com/Two-Ftry/react-essay/tree/master/react-router-02\" target=\"_blank\" rel=\"noopener\">这里</a> 。</p>\n"},{"title":"redux(六)-redux原理","date":"2019-01-10T04:17:07.000Z","_content":"\nredux作为一个状态管理器，它对数据进行管理控制，并且规定了数据更改的方式（即通过dispatch一个action的方式）。","source":"_posts/redux6-myRedux-20190110.md","raw":"---\ntitle: redux(六)-redux原理\ndate: 2019-01-10 12:17:07\ntags:\n---\n\nredux作为一个状态管理器，它对数据进行管理控制，并且规定了数据更改的方式（即通过dispatch一个action的方式）。","slug":"redux6-myRedux","published":1,"updated":"2019-01-10T04:20:04.840Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvope000q4c4109aqrt86","content":"<p>redux作为一个状态管理器，它对数据进行管理控制，并且规定了数据更改的方式（即通过dispatch一个action的方式）。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>redux作为一个状态管理器，它对数据进行管理控制，并且规定了数据更改的方式（即通过dispatch一个action的方式）。</p>\n"},{"title":"redux(五)-中间件","date":"2019-01-08T10:01:33.000Z","_content":"\nredux的生态中，提供了中间件（即middleware）的方式来增强redux。middleware是指可以被嵌入在框架接收请求到产生响应过程之中的代码。middleware的方式能够很好的对代码进行解耦，如此middleware就能够独立成一个个的功能模块，方便维护和升级。那在redux中是如何提供对middleware的支持呢？redux提供了applyMiddleware()方法来支持middleware。applyMiddleware()方法的实现思路，就是将这些middleware形成一个链表，当dispatch()一个action的时候，就逐个调用调用链表里的middlware。它看起来就像下面这样。\n\n![middleware](redux-middleware.png)\n\n实现的代码像下面这样：\n\n{% codeblock %}\nfunction applyMiddleware(store, middlewares) {\n  middlewares = middlewares.slice()\n  middlewares.reverse()\n\n  let dispatch = store.dispatch\n  middlewares.forEach(middleware =>\n    dispatch = middleware(store)(dispatch)\n  )\n\n  return Object.assign({}, store, { dispatch })\n}\n{% endcodeblock %}\n\n这段代码，首先将middlewares逆序排列，然后遍历这个逆序的middlewares，获取每个middleware的返回函数赋给dispatch，遍历完成后dispatch变量就是第一个middleware的返回函数，最后把store中的dispatch()方法替换成了第一个middleware的返回函数。所以如果我们添加了中间件，在执行store.dispatch()方法时，这个方法已经不是redux本身的dispatch()方法，而是第一个middleware的返回函数，redux本身的dispatch()方法会在所有middlewares的返回函数都执行后被调用。\n\n同时，我们也注意到在遍历middlewares，我们对middleware进行了两次调用，分别传入了store和dispatch变量，即middleware(store)(dispatch)，store变量是一个固定的值，但是dispatch在每一次遍历后都重新指向了前一个middleware的返回值，在官方文档中这个dispatch变量命名为next，其实是更合理的。所以我们在编写middleware的时候，需要遵循如下的写法：\n\n{% codeblock %}\nconst middleware = (store) => (next) => (action) => {\n    // ... code\n    const result = next(action)\n    // ... code\n    return result\n}\n{% endcodeblock %}\n\nstore的传入只是方便在middleware中获取应用的状态，而next的传入是为了形成一个链表，指向下一个middleware，所以在自己编写middleware的时候，需要在middleware内部手动调用next(action)以便能调用下一个middleware。\n\n# 1、logger中间件\n\nlogger中间件的目的，是在dispatch执行前做一次记录，dispatch完成后，打印出dispatch之后的state。按照middleware的方式，我们来完成这个组件。\n\n{% codeblock %}\n// middlewares/logger.js\nconst logger = (store) => (next) => (action) => {\n    console.log('dispatching', action)\n    next(action)\n    console.log('next state', store.getState())\n}\n\nexport default logger\n{% endcodeblock %}\n\nlogger中间件，在执行next之前打印出当前的action，然后执行next（即往后继续执行其他的middleware或者执行redux的dispatch()）,当dispatch完成后，打印出state信息。\n\n# 2、thunk middleware\n\n我们都知道，如果想要使用redux dispatch一个function类型的action，需要添加一个redux-thunk的middleware。那它是怎样实现的呢？我们来尝试实现它。\n\n{% codeblock %}\n// middlewares/thunk.js\nconst thunk = (store) => (next) => (action) => {\n    if (typeof action === 'function') {\n        action(store.dispatch, store.getState)\n    } else {\n        next(action)\n    }\n}\n\nexport default thunk\n{% endcodeblock %}\n\n上面这段代码，仍然采用了redux middleware的实现模式来包装（即(store) => (next) => (action)）。在实现的内部，我们判断传递进来的action，如果不是一个function，那么就调用下一个middleware；如果是function，我们就执行这个action，并且把redux的dispatch()和getState()方法参数传入到这个action方法，到此调用链结束。\n\n在acion生成方法的内部，如果使用了dispatch()方法重新发起action，则会沿着middlewares的调用链表重新执行。一般dispatch一个function action，会像下面这样：\n\n{% codeblock %}\n// 使用示意-action生成方法\nexport function dispatchInitTodos() {\n  return (dispatch) => {\n    getTodos().then((data) => {\n      dispatch({\n        type: 'INIT_TODOS',\n        data,\n      })\n    })\n  }\n}\nstore.dispatch(dispatchInitTodos())\n{% endcodeblock %}\n\n# 3、promise middleware\n\ndispatch一个Promise，和dispatch一个function会不会是一样的方式呢？我们先来写一个使用promise作为action的代码。\n\n{% codeblock %}\nfunction dispatchPromise(){\n  return  new Promise((resolve, reject) => {\n    // ...\n  })\n}\n{% endcodeblock %}\n\n如上述代码，我们dispatch一个Promise，这个Promise对象在创建出来的时候，就已经开始执行内部的逻辑了。这和function还是不一样的，function定义出来之后，可以延后执行，所以我们可以在middleware的实现中调用function。\n\n所以在实现promise middleware的时候，思路是将Promise的resolved（或者rejected）的值作为一个action，重新使用store.dispatch()方法来发起这个action。\n\n{% codeblock %}\n// middlewares/promise.js\nconst promise = (store) => (next) => (action) => {\n    // 抽取一个dispatch的方法\n    // 支持派发多个action\n    const dispatchInnerAction = (data) => {\n        if (Array.isArray(data)) {\n            data.forEach(item => {\n                store.dispatch(item)\n            })\n        } else {\n            store.dispatch(data)\n        }\n    }\n    if (typeof action.then === 'function') {\n        action.then((data) => {\n            dispatchInnerAction(data)\n        }, (err) => {\n            dispatchInnerAction(err)\n        })\n    } else {\n        next(action)\n    }\n}\n\nexport default promise\n{% endcodeblock %}\n\n上述这段代码，当action.then为一个function的时候，我们就断定这个action为一个Promise对象。我们调用action.then()方法来获取这个Promises对象的resolved值（或者rejected值）。**当然，这里resolved值（或者rejected值）要求必须为一个action。**为了支持多个action，对resolved值（或者rejected值）进行了判断，如果是一个数组，逐个遍历并dispatch，否则直接dispatch。\n\nPromise action的生成函数大体如下：\n\n{% codeblock %}\n// actions.js\nimport { getTodos } from './services.js'\n\n// 初始化todos\nexport function initTodos(list) {\n  return {\n    type: 'INIT_TODOS',\n    list,\n  }\n}\n\nexport function dispatchInitTodosPromise(){\n  return  getTodos().then((data) => {\n    return initTodos(data.list)\n  })\n}\n{% endcodeblock %}\n\n上述代码，getTodos()方法本身返回了一个Promise，我们调用getTodos().then()后传递给middleware的依然是一个Promise，并且使用 return initTodos(...)的形式resolved了一个action。在promise middleware中，这个resolved了的action会使用store.dispatch()方法发起。\n\n# 4、结语\n\n本文我们学习了redux middleware的实现机制，同时举了几个例子来编写自定义的middleware。如果不明白，可以到redux的官方文档中，查看 {% link middlewares https://redux.js.org/advanced/middleware %} 这篇教程，里面很详尽地道出了middleware的演进思路。不过这篇文章中举的两个例子，logger和crashReporter，虽然简单易懂，但是代表性不是特别强，最好自己动手实现一个简单的redux-thunk和redux-promise，对于redux middleware的理解将会更加深入。\n\n本章的实现代码可以查看{% link redux-06 https://github.com/Two-Ftry/react-essay/tree/master/redux-06 %}。","source":"_posts/redux5-middleware-20190110.md","raw":"---\ntitle: redux(五)-中间件\ntags: redux middleware\ndate: 2019-01-08 18:01:33\n---\n\nredux的生态中，提供了中间件（即middleware）的方式来增强redux。middleware是指可以被嵌入在框架接收请求到产生响应过程之中的代码。middleware的方式能够很好的对代码进行解耦，如此middleware就能够独立成一个个的功能模块，方便维护和升级。那在redux中是如何提供对middleware的支持呢？redux提供了applyMiddleware()方法来支持middleware。applyMiddleware()方法的实现思路，就是将这些middleware形成一个链表，当dispatch()一个action的时候，就逐个调用调用链表里的middlware。它看起来就像下面这样。\n\n![middleware](redux-middleware.png)\n\n实现的代码像下面这样：\n\n{% codeblock %}\nfunction applyMiddleware(store, middlewares) {\n  middlewares = middlewares.slice()\n  middlewares.reverse()\n\n  let dispatch = store.dispatch\n  middlewares.forEach(middleware =>\n    dispatch = middleware(store)(dispatch)\n  )\n\n  return Object.assign({}, store, { dispatch })\n}\n{% endcodeblock %}\n\n这段代码，首先将middlewares逆序排列，然后遍历这个逆序的middlewares，获取每个middleware的返回函数赋给dispatch，遍历完成后dispatch变量就是第一个middleware的返回函数，最后把store中的dispatch()方法替换成了第一个middleware的返回函数。所以如果我们添加了中间件，在执行store.dispatch()方法时，这个方法已经不是redux本身的dispatch()方法，而是第一个middleware的返回函数，redux本身的dispatch()方法会在所有middlewares的返回函数都执行后被调用。\n\n同时，我们也注意到在遍历middlewares，我们对middleware进行了两次调用，分别传入了store和dispatch变量，即middleware(store)(dispatch)，store变量是一个固定的值，但是dispatch在每一次遍历后都重新指向了前一个middleware的返回值，在官方文档中这个dispatch变量命名为next，其实是更合理的。所以我们在编写middleware的时候，需要遵循如下的写法：\n\n{% codeblock %}\nconst middleware = (store) => (next) => (action) => {\n    // ... code\n    const result = next(action)\n    // ... code\n    return result\n}\n{% endcodeblock %}\n\nstore的传入只是方便在middleware中获取应用的状态，而next的传入是为了形成一个链表，指向下一个middleware，所以在自己编写middleware的时候，需要在middleware内部手动调用next(action)以便能调用下一个middleware。\n\n# 1、logger中间件\n\nlogger中间件的目的，是在dispatch执行前做一次记录，dispatch完成后，打印出dispatch之后的state。按照middleware的方式，我们来完成这个组件。\n\n{% codeblock %}\n// middlewares/logger.js\nconst logger = (store) => (next) => (action) => {\n    console.log('dispatching', action)\n    next(action)\n    console.log('next state', store.getState())\n}\n\nexport default logger\n{% endcodeblock %}\n\nlogger中间件，在执行next之前打印出当前的action，然后执行next（即往后继续执行其他的middleware或者执行redux的dispatch()）,当dispatch完成后，打印出state信息。\n\n# 2、thunk middleware\n\n我们都知道，如果想要使用redux dispatch一个function类型的action，需要添加一个redux-thunk的middleware。那它是怎样实现的呢？我们来尝试实现它。\n\n{% codeblock %}\n// middlewares/thunk.js\nconst thunk = (store) => (next) => (action) => {\n    if (typeof action === 'function') {\n        action(store.dispatch, store.getState)\n    } else {\n        next(action)\n    }\n}\n\nexport default thunk\n{% endcodeblock %}\n\n上面这段代码，仍然采用了redux middleware的实现模式来包装（即(store) => (next) => (action)）。在实现的内部，我们判断传递进来的action，如果不是一个function，那么就调用下一个middleware；如果是function，我们就执行这个action，并且把redux的dispatch()和getState()方法参数传入到这个action方法，到此调用链结束。\n\n在acion生成方法的内部，如果使用了dispatch()方法重新发起action，则会沿着middlewares的调用链表重新执行。一般dispatch一个function action，会像下面这样：\n\n{% codeblock %}\n// 使用示意-action生成方法\nexport function dispatchInitTodos() {\n  return (dispatch) => {\n    getTodos().then((data) => {\n      dispatch({\n        type: 'INIT_TODOS',\n        data,\n      })\n    })\n  }\n}\nstore.dispatch(dispatchInitTodos())\n{% endcodeblock %}\n\n# 3、promise middleware\n\ndispatch一个Promise，和dispatch一个function会不会是一样的方式呢？我们先来写一个使用promise作为action的代码。\n\n{% codeblock %}\nfunction dispatchPromise(){\n  return  new Promise((resolve, reject) => {\n    // ...\n  })\n}\n{% endcodeblock %}\n\n如上述代码，我们dispatch一个Promise，这个Promise对象在创建出来的时候，就已经开始执行内部的逻辑了。这和function还是不一样的，function定义出来之后，可以延后执行，所以我们可以在middleware的实现中调用function。\n\n所以在实现promise middleware的时候，思路是将Promise的resolved（或者rejected）的值作为一个action，重新使用store.dispatch()方法来发起这个action。\n\n{% codeblock %}\n// middlewares/promise.js\nconst promise = (store) => (next) => (action) => {\n    // 抽取一个dispatch的方法\n    // 支持派发多个action\n    const dispatchInnerAction = (data) => {\n        if (Array.isArray(data)) {\n            data.forEach(item => {\n                store.dispatch(item)\n            })\n        } else {\n            store.dispatch(data)\n        }\n    }\n    if (typeof action.then === 'function') {\n        action.then((data) => {\n            dispatchInnerAction(data)\n        }, (err) => {\n            dispatchInnerAction(err)\n        })\n    } else {\n        next(action)\n    }\n}\n\nexport default promise\n{% endcodeblock %}\n\n上述这段代码，当action.then为一个function的时候，我们就断定这个action为一个Promise对象。我们调用action.then()方法来获取这个Promises对象的resolved值（或者rejected值）。**当然，这里resolved值（或者rejected值）要求必须为一个action。**为了支持多个action，对resolved值（或者rejected值）进行了判断，如果是一个数组，逐个遍历并dispatch，否则直接dispatch。\n\nPromise action的生成函数大体如下：\n\n{% codeblock %}\n// actions.js\nimport { getTodos } from './services.js'\n\n// 初始化todos\nexport function initTodos(list) {\n  return {\n    type: 'INIT_TODOS',\n    list,\n  }\n}\n\nexport function dispatchInitTodosPromise(){\n  return  getTodos().then((data) => {\n    return initTodos(data.list)\n  })\n}\n{% endcodeblock %}\n\n上述代码，getTodos()方法本身返回了一个Promise，我们调用getTodos().then()后传递给middleware的依然是一个Promise，并且使用 return initTodos(...)的形式resolved了一个action。在promise middleware中，这个resolved了的action会使用store.dispatch()方法发起。\n\n# 4、结语\n\n本文我们学习了redux middleware的实现机制，同时举了几个例子来编写自定义的middleware。如果不明白，可以到redux的官方文档中，查看 {% link middlewares https://redux.js.org/advanced/middleware %} 这篇教程，里面很详尽地道出了middleware的演进思路。不过这篇文章中举的两个例子，logger和crashReporter，虽然简单易懂，但是代表性不是特别强，最好自己动手实现一个简单的redux-thunk和redux-promise，对于redux middleware的理解将会更加深入。\n\n本章的实现代码可以查看{% link redux-06 https://github.com/Two-Ftry/react-essay/tree/master/redux-06 %}。","slug":"redux5-middleware","published":1,"updated":"2019-02-18T05:29:35.658Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvopf000t4c4189hhs2vu","content":"<p>redux的生态中，提供了中间件（即middleware）的方式来增强redux。middleware是指可以被嵌入在框架接收请求到产生响应过程之中的代码。middleware的方式能够很好的对代码进行解耦，如此middleware就能够独立成一个个的功能模块，方便维护和升级。那在redux中是如何提供对middleware的支持呢？redux提供了applyMiddleware()方法来支持middleware。applyMiddleware()方法的实现思路，就是将这些middleware形成一个链表，当dispatch()一个action的时候，就逐个调用调用链表里的middlware。它看起来就像下面这样。</p>\n<p><img src=\"/2019/01/08/redux5-middleware/redux-middleware.png\" alt=\"middleware\"></p>\n<p>实现的代码像下面这样：</p>\n<pre><code>function applyMiddleware(store, middlewares) {\n  middlewares = middlewares.slice()\n  middlewares.reverse()\n\n  let dispatch = store.dispatch\n  middlewares.forEach(middleware =&gt;\n    dispatch = middleware(store)(dispatch)\n  )\n\n  return Object.assign({}, store, { dispatch })\n}</code></pre>\n<p>这段代码，首先将middlewares逆序排列，然后遍历这个逆序的middlewares，获取每个middleware的返回函数赋给dispatch，遍历完成后dispatch变量就是第一个middleware的返回函数，最后把store中的dispatch()方法替换成了第一个middleware的返回函数。所以如果我们添加了中间件，在执行store.dispatch()方法时，这个方法已经不是redux本身的dispatch()方法，而是第一个middleware的返回函数，redux本身的dispatch()方法会在所有middlewares的返回函数都执行后被调用。</p>\n<p>同时，我们也注意到在遍历middlewares，我们对middleware进行了两次调用，分别传入了store和dispatch变量，即middleware(store)(dispatch)，store变量是一个固定的值，但是dispatch在每一次遍历后都重新指向了前一个middleware的返回值，在官方文档中这个dispatch变量命名为next，其实是更合理的。所以我们在编写middleware的时候，需要遵循如下的写法：</p>\n<pre><code>const middleware = (store) =&gt; (next) =&gt; (action) =&gt; {\n    &#x2F;&#x2F; ... code\n    const result = next(action)\n    &#x2F;&#x2F; ... code\n    return result\n}</code></pre>\n<p>store的传入只是方便在middleware中获取应用的状态，而next的传入是为了形成一个链表，指向下一个middleware，所以在自己编写middleware的时候，需要在middleware内部手动调用next(action)以便能调用下一个middleware。</p>\n<h1 id=\"1、logger中间件\"><a href=\"#1、logger中间件\" class=\"headerlink\" title=\"1、logger中间件\"></a>1、logger中间件</h1><p>logger中间件的目的，是在dispatch执行前做一次记录，dispatch完成后，打印出dispatch之后的state。按照middleware的方式，我们来完成这个组件。</p>\n<pre><code>&#x2F;&#x2F; middlewares&#x2F;logger.js\nconst logger = (store) =&gt; (next) =&gt; (action) =&gt; {\n    console.log(&#39;dispatching&#39;, action)\n    next(action)\n    console.log(&#39;next state&#39;, store.getState())\n}\n\nexport default logger</code></pre>\n<p>logger中间件，在执行next之前打印出当前的action，然后执行next（即往后继续执行其他的middleware或者执行redux的dispatch()）,当dispatch完成后，打印出state信息。</p>\n<h1 id=\"2、thunk-middleware\"><a href=\"#2、thunk-middleware\" class=\"headerlink\" title=\"2、thunk middleware\"></a>2、thunk middleware</h1><p>我们都知道，如果想要使用redux dispatch一个function类型的action，需要添加一个redux-thunk的middleware。那它是怎样实现的呢？我们来尝试实现它。</p>\n<pre><code>&#x2F;&#x2F; middlewares&#x2F;thunk.js\nconst thunk = (store) =&gt; (next) =&gt; (action) =&gt; {\n    if (typeof action === &#39;function&#39;) {\n        action(store.dispatch, store.getState)\n    } else {\n        next(action)\n    }\n}\n\nexport default thunk</code></pre>\n<p>上面这段代码，仍然采用了redux middleware的实现模式来包装（即(store) =&gt; (next) =&gt; (action)）。在实现的内部，我们判断传递进来的action，如果不是一个function，那么就调用下一个middleware；如果是function，我们就执行这个action，并且把redux的dispatch()和getState()方法参数传入到这个action方法，到此调用链结束。</p>\n<p>在acion生成方法的内部，如果使用了dispatch()方法重新发起action，则会沿着middlewares的调用链表重新执行。一般dispatch一个function action，会像下面这样：</p>\n<pre><code>&#x2F;&#x2F; 使用示意-action生成方法\nexport function dispatchInitTodos() {\n  return (dispatch) =&gt; {\n    getTodos().then((data) =&gt; {\n      dispatch({\n        type: &#39;INIT_TODOS&#39;,\n        data,\n      })\n    })\n  }\n}\nstore.dispatch(dispatchInitTodos())</code></pre>\n<h1 id=\"3、promise-middleware\"><a href=\"#3、promise-middleware\" class=\"headerlink\" title=\"3、promise middleware\"></a>3、promise middleware</h1><p>dispatch一个Promise，和dispatch一个function会不会是一样的方式呢？我们先来写一个使用promise作为action的代码。</p>\n<pre><code>function dispatchPromise(){\n  return  new Promise((resolve, reject) =&gt; {\n    &#x2F;&#x2F; ...\n  })\n}</code></pre>\n<p>如上述代码，我们dispatch一个Promise，这个Promise对象在创建出来的时候，就已经开始执行内部的逻辑了。这和function还是不一样的，function定义出来之后，可以延后执行，所以我们可以在middleware的实现中调用function。</p>\n<p>所以在实现promise middleware的时候，思路是将Promise的resolved（或者rejected）的值作为一个action，重新使用store.dispatch()方法来发起这个action。</p>\n<pre><code>&#x2F;&#x2F; middlewares&#x2F;promise.js\nconst promise = (store) =&gt; (next) =&gt; (action) =&gt; {\n    &#x2F;&#x2F; 抽取一个dispatch的方法\n    &#x2F;&#x2F; 支持派发多个action\n    const dispatchInnerAction = (data) =&gt; {\n        if (Array.isArray(data)) {\n            data.forEach(item =&gt; {\n                store.dispatch(item)\n            })\n        } else {\n            store.dispatch(data)\n        }\n    }\n    if (typeof action.then === &#39;function&#39;) {\n        action.then((data) =&gt; {\n            dispatchInnerAction(data)\n        }, (err) =&gt; {\n            dispatchInnerAction(err)\n        })\n    } else {\n        next(action)\n    }\n}\n\nexport default promise</code></pre>\n<p>上述这段代码，当action.then为一个function的时候，我们就断定这个action为一个Promise对象。我们调用action.then()方法来获取这个Promises对象的resolved值（或者rejected值）。<strong>当然，这里resolved值（或者rejected值）要求必须为一个action。</strong>为了支持多个action，对resolved值（或者rejected值）进行了判断，如果是一个数组，逐个遍历并dispatch，否则直接dispatch。</p>\n<p>Promise action的生成函数大体如下：</p>\n<pre><code>&#x2F;&#x2F; actions.js\nimport { getTodos } from &#39;.&#x2F;services.js&#39;\n\n&#x2F;&#x2F; 初始化todos\nexport function initTodos(list) {\n  return {\n    type: &#39;INIT_TODOS&#39;,\n    list,\n  }\n}\n\nexport function dispatchInitTodosPromise(){\n  return  getTodos().then((data) =&gt; {\n    return initTodos(data.list)\n  })\n}</code></pre>\n<p>上述代码，getTodos()方法本身返回了一个Promise，我们调用getTodos().then()后传递给middleware的依然是一个Promise，并且使用 return initTodos(…)的形式resolved了一个action。在promise middleware中，这个resolved了的action会使用store.dispatch()方法发起。</p>\n<h1 id=\"4、结语\"><a href=\"#4、结语\" class=\"headerlink\" title=\"4、结语\"></a>4、结语</h1><p>本文我们学习了redux middleware的实现机制，同时举了几个例子来编写自定义的middleware。如果不明白，可以到redux的官方文档中，查看 <a href=\"https://redux.js.org/advanced/middleware\" target=\"_blank\" rel=\"noopener\">middlewares</a> 这篇教程，里面很详尽地道出了middleware的演进思路。不过这篇文章中举的两个例子，logger和crashReporter，虽然简单易懂，但是代表性不是特别强，最好自己动手实现一个简单的redux-thunk和redux-promise，对于redux middleware的理解将会更加深入。</p>\n<p>本章的实现代码可以查看<a href=\"https://github.com/Two-Ftry/react-essay/tree/master/redux-06\" target=\"_blank\" rel=\"noopener\">redux-06</a>。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>redux的生态中，提供了中间件（即middleware）的方式来增强redux。middleware是指可以被嵌入在框架接收请求到产生响应过程之中的代码。middleware的方式能够很好的对代码进行解耦，如此middleware就能够独立成一个个的功能模块，方便维护和升级。那在redux中是如何提供对middleware的支持呢？redux提供了applyMiddleware()方法来支持middleware。applyMiddleware()方法的实现思路，就是将这些middleware形成一个链表，当dispatch()一个action的时候，就逐个调用调用链表里的middlware。它看起来就像下面这样。</p>\n<p><img src=\"/2019/01/08/redux5-middleware/redux-middleware.png\" alt=\"middleware\"></p>\n<p>实现的代码像下面这样：</p>\n<pre><code>function applyMiddleware(store, middlewares) {\n  middlewares = middlewares.slice()\n  middlewares.reverse()\n\n  let dispatch = store.dispatch\n  middlewares.forEach(middleware =&gt;\n    dispatch = middleware(store)(dispatch)\n  )\n\n  return Object.assign({}, store, { dispatch })\n}</code></pre>\n<p>这段代码，首先将middlewares逆序排列，然后遍历这个逆序的middlewares，获取每个middleware的返回函数赋给dispatch，遍历完成后dispatch变量就是第一个middleware的返回函数，最后把store中的dispatch()方法替换成了第一个middleware的返回函数。所以如果我们添加了中间件，在执行store.dispatch()方法时，这个方法已经不是redux本身的dispatch()方法，而是第一个middleware的返回函数，redux本身的dispatch()方法会在所有middlewares的返回函数都执行后被调用。</p>\n<p>同时，我们也注意到在遍历middlewares，我们对middleware进行了两次调用，分别传入了store和dispatch变量，即middleware(store)(dispatch)，store变量是一个固定的值，但是dispatch在每一次遍历后都重新指向了前一个middleware的返回值，在官方文档中这个dispatch变量命名为next，其实是更合理的。所以我们在编写middleware的时候，需要遵循如下的写法：</p>\n<pre><code>const middleware = (store) =&gt; (next) =&gt; (action) =&gt; {\n    &#x2F;&#x2F; ... code\n    const result = next(action)\n    &#x2F;&#x2F; ... code\n    return result\n}</code></pre>\n<p>store的传入只是方便在middleware中获取应用的状态，而next的传入是为了形成一个链表，指向下一个middleware，所以在自己编写middleware的时候，需要在middleware内部手动调用next(action)以便能调用下一个middleware。</p>\n<h1 id=\"1、logger中间件\"><a href=\"#1、logger中间件\" class=\"headerlink\" title=\"1、logger中间件\"></a>1、logger中间件</h1><p>logger中间件的目的，是在dispatch执行前做一次记录，dispatch完成后，打印出dispatch之后的state。按照middleware的方式，我们来完成这个组件。</p>\n<pre><code>&#x2F;&#x2F; middlewares&#x2F;logger.js\nconst logger = (store) =&gt; (next) =&gt; (action) =&gt; {\n    console.log(&#39;dispatching&#39;, action)\n    next(action)\n    console.log(&#39;next state&#39;, store.getState())\n}\n\nexport default logger</code></pre>\n<p>logger中间件，在执行next之前打印出当前的action，然后执行next（即往后继续执行其他的middleware或者执行redux的dispatch()）,当dispatch完成后，打印出state信息。</p>\n<h1 id=\"2、thunk-middleware\"><a href=\"#2、thunk-middleware\" class=\"headerlink\" title=\"2、thunk middleware\"></a>2、thunk middleware</h1><p>我们都知道，如果想要使用redux dispatch一个function类型的action，需要添加一个redux-thunk的middleware。那它是怎样实现的呢？我们来尝试实现它。</p>\n<pre><code>&#x2F;&#x2F; middlewares&#x2F;thunk.js\nconst thunk = (store) =&gt; (next) =&gt; (action) =&gt; {\n    if (typeof action === &#39;function&#39;) {\n        action(store.dispatch, store.getState)\n    } else {\n        next(action)\n    }\n}\n\nexport default thunk</code></pre>\n<p>上面这段代码，仍然采用了redux middleware的实现模式来包装（即(store) =&gt; (next) =&gt; (action)）。在实现的内部，我们判断传递进来的action，如果不是一个function，那么就调用下一个middleware；如果是function，我们就执行这个action，并且把redux的dispatch()和getState()方法参数传入到这个action方法，到此调用链结束。</p>\n<p>在acion生成方法的内部，如果使用了dispatch()方法重新发起action，则会沿着middlewares的调用链表重新执行。一般dispatch一个function action，会像下面这样：</p>\n<pre><code>&#x2F;&#x2F; 使用示意-action生成方法\nexport function dispatchInitTodos() {\n  return (dispatch) =&gt; {\n    getTodos().then((data) =&gt; {\n      dispatch({\n        type: &#39;INIT_TODOS&#39;,\n        data,\n      })\n    })\n  }\n}\nstore.dispatch(dispatchInitTodos())</code></pre>\n<h1 id=\"3、promise-middleware\"><a href=\"#3、promise-middleware\" class=\"headerlink\" title=\"3、promise middleware\"></a>3、promise middleware</h1><p>dispatch一个Promise，和dispatch一个function会不会是一样的方式呢？我们先来写一个使用promise作为action的代码。</p>\n<pre><code>function dispatchPromise(){\n  return  new Promise((resolve, reject) =&gt; {\n    &#x2F;&#x2F; ...\n  })\n}</code></pre>\n<p>如上述代码，我们dispatch一个Promise，这个Promise对象在创建出来的时候，就已经开始执行内部的逻辑了。这和function还是不一样的，function定义出来之后，可以延后执行，所以我们可以在middleware的实现中调用function。</p>\n<p>所以在实现promise middleware的时候，思路是将Promise的resolved（或者rejected）的值作为一个action，重新使用store.dispatch()方法来发起这个action。</p>\n<pre><code>&#x2F;&#x2F; middlewares&#x2F;promise.js\nconst promise = (store) =&gt; (next) =&gt; (action) =&gt; {\n    &#x2F;&#x2F; 抽取一个dispatch的方法\n    &#x2F;&#x2F; 支持派发多个action\n    const dispatchInnerAction = (data) =&gt; {\n        if (Array.isArray(data)) {\n            data.forEach(item =&gt; {\n                store.dispatch(item)\n            })\n        } else {\n            store.dispatch(data)\n        }\n    }\n    if (typeof action.then === &#39;function&#39;) {\n        action.then((data) =&gt; {\n            dispatchInnerAction(data)\n        }, (err) =&gt; {\n            dispatchInnerAction(err)\n        })\n    } else {\n        next(action)\n    }\n}\n\nexport default promise</code></pre>\n<p>上述这段代码，当action.then为一个function的时候，我们就断定这个action为一个Promise对象。我们调用action.then()方法来获取这个Promises对象的resolved值（或者rejected值）。<strong>当然，这里resolved值（或者rejected值）要求必须为一个action。</strong>为了支持多个action，对resolved值（或者rejected值）进行了判断，如果是一个数组，逐个遍历并dispatch，否则直接dispatch。</p>\n<p>Promise action的生成函数大体如下：</p>\n<pre><code>&#x2F;&#x2F; actions.js\nimport { getTodos } from &#39;.&#x2F;services.js&#39;\n\n&#x2F;&#x2F; 初始化todos\nexport function initTodos(list) {\n  return {\n    type: &#39;INIT_TODOS&#39;,\n    list,\n  }\n}\n\nexport function dispatchInitTodosPromise(){\n  return  getTodos().then((data) =&gt; {\n    return initTodos(data.list)\n  })\n}</code></pre>\n<p>上述代码，getTodos()方法本身返回了一个Promise，我们调用getTodos().then()后传递给middleware的依然是一个Promise，并且使用 return initTodos(…)的形式resolved了一个action。在promise middleware中，这个resolved了的action会使用store.dispatch()方法发起。</p>\n<h1 id=\"4、结语\"><a href=\"#4、结语\" class=\"headerlink\" title=\"4、结语\"></a>4、结语</h1><p>本文我们学习了redux middleware的实现机制，同时举了几个例子来编写自定义的middleware。如果不明白，可以到redux的官方文档中，查看 <a href=\"https://redux.js.org/advanced/middleware\" target=\"_blank\" rel=\"noopener\">middlewares</a> 这篇教程，里面很详尽地道出了middleware的演进思路。不过这篇文章中举的两个例子，logger和crashReporter，虽然简单易懂，但是代表性不是特别强，最好自己动手实现一个简单的redux-thunk和redux-promise，对于redux middleware的理解将会更加深入。</p>\n<p>本章的实现代码可以查看<a href=\"https://github.com/Two-Ftry/react-essay/tree/master/redux-06\" target=\"_blank\" rel=\"noopener\">redux-06</a>。</p>\n"},{"title":"redux(八)-redux与vuex","date":"2019-01-13T13:09:49.000Z","_content":"\nreact和vue作为目前前端非常流行的两大框架，而redux和vuex分别是这两大框架会用到的状态管理库，在学习了redux后，是非常有必要与vuex做一下对比。vuex背后的基本思想，借鉴了redux等库，但是又有所不同，vuex是专门为vue设计的状态管理库，以利用vue的响应机制来进行高效的状态更新。所以如果既用过redux也用过vuex，那就会发现它们之间那么的相似，用起来又有所不同。\n\n# 1、状态\n\nredux和vuex作为状态管理库，都维护着应用的状态（即state）。但是从使用者定义state的方式来看，完全是不一样等。\n\n在redux里面，state是通过reducer的返回值来确定的，所以是需要分析reducer才能看出它的结构。而vuex里面，state是直接可以定义的。\n\n{% codeblock %}\nimport Vuex from 'vuex'\nconst store = new Vuex.Store({\n    state: {\n        visibilityFilter: 'SHOW_ALL',\n        todos: [],\n    },\n})\n{% endcodeblock %}\n\n从这一点来看，虽然都是state，但是vuex的阅读性和维护性更好。所以，我们会看到基于redux基础上的库dva，也采用了vuex的这种方式。\n\n# 2、获取状态\n\nredux中获取状态通过store.getState()方法来获取。而在vuex中，通过store.state.xxx的形式直接获取。并且vuex还提供了getter的方式来派生出一些状态，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\n{% codeblock %}\n// vuex的getter\ngetters: {\n    visibilityFilter (state) {\n        return state.visibilityFilter\n    }\n}\n{% endcodeblock %}\n\n# 3、更改状态\n\nredux里面能够更改state是reducer，vuex里面更改state的是mutation，从定义上是不一样的。reducer里面，接收上一次的state和action，返回新的state。而在vuex的mutation里面，会接收state和一个额外的参数，然后直接修改state状态，这一点是利用了vue的特性，所以vuex显得更加灵活一些。\n\n{% codeblock %}\n// reducer示例\nfunction visibilityFilter(state = 'SHOW_ALL', action) {\n    switch (action.type) {\n        case 'SET_VISIBILITY_FILTER':\n            return action.filter\n        default:\n            return state\n    }\n}\n{% endcodeblock %}\n\n{% codeblock %}\n// mutation示例\nmutations: {\n    setVisibilityFilter (state, { filter }) {\n        state.visibilityFilter = filter\n    },\n}\n{% endcodeblock %}\n\n# 4、Action\n\nredux的action是数据从应用到store的有效载何。redux自身只能处理带type属性的object形式的Action，需要支持其他方式的Action（如function、promise）需要通过中间件的方式集成进去。而vuex的action，设计上就是用来处理异步的情况，而不是一个载何，而要更改state还需要在action里面commit一个mutation。\n\n{% codeblock %}\n// redux Action示例\n// 更改过滤条件\nexport function setVisibilityFilter(filter) {\n  return { type: 'SET_VISIBILITY_FILTER', filter }\n}\n{% endcodeblock %}\n\n{% codeblock %}\n// vuex Action示例\nactions: {\n    initTodos ({ commit }) {\n        getTodos().then((data) => {\n            commit('initTodos', {\n                list: data.list,\n            })\n        })\n    }\n}\n{% endcodeblock %}\n\n# 5、结合其他库使用\n\n在结合其他库使用方面，redux其实是不依赖于任何库的，所以它的用途也更广，可以和vue、Angular、Ember、jQuery 甚至纯JavaScript结合使用。不过要和其他库搭配，可能需要做一些工作，比如引入一些其他的库，比如redux和react搭配就会引入\"react-redux\"。\n而vuex本身设计就是为vue做状态管理，vuex作为vue的一个plugin而存在，只能用在vue中，用途较窄。\n\n# 6、结语\n\n以上是在使用redux和vuex过程中，发现它们的一些不同。在此记录下来，即使认识有偏差，也方便日后修改。","source":"_posts/redux8-vuex-20190113.md","raw":"---\ntitle: redux(八)-redux与vuex\ndate: 2019-01-13 21:09:49\ntags: redux vuex\n---\n\nreact和vue作为目前前端非常流行的两大框架，而redux和vuex分别是这两大框架会用到的状态管理库，在学习了redux后，是非常有必要与vuex做一下对比。vuex背后的基本思想，借鉴了redux等库，但是又有所不同，vuex是专门为vue设计的状态管理库，以利用vue的响应机制来进行高效的状态更新。所以如果既用过redux也用过vuex，那就会发现它们之间那么的相似，用起来又有所不同。\n\n# 1、状态\n\nredux和vuex作为状态管理库，都维护着应用的状态（即state）。但是从使用者定义state的方式来看，完全是不一样等。\n\n在redux里面，state是通过reducer的返回值来确定的，所以是需要分析reducer才能看出它的结构。而vuex里面，state是直接可以定义的。\n\n{% codeblock %}\nimport Vuex from 'vuex'\nconst store = new Vuex.Store({\n    state: {\n        visibilityFilter: 'SHOW_ALL',\n        todos: [],\n    },\n})\n{% endcodeblock %}\n\n从这一点来看，虽然都是state，但是vuex的阅读性和维护性更好。所以，我们会看到基于redux基础上的库dva，也采用了vuex的这种方式。\n\n# 2、获取状态\n\nredux中获取状态通过store.getState()方法来获取。而在vuex中，通过store.state.xxx的形式直接获取。并且vuex还提供了getter的方式来派生出一些状态，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。\n\n{% codeblock %}\n// vuex的getter\ngetters: {\n    visibilityFilter (state) {\n        return state.visibilityFilter\n    }\n}\n{% endcodeblock %}\n\n# 3、更改状态\n\nredux里面能够更改state是reducer，vuex里面更改state的是mutation，从定义上是不一样的。reducer里面，接收上一次的state和action，返回新的state。而在vuex的mutation里面，会接收state和一个额外的参数，然后直接修改state状态，这一点是利用了vue的特性，所以vuex显得更加灵活一些。\n\n{% codeblock %}\n// reducer示例\nfunction visibilityFilter(state = 'SHOW_ALL', action) {\n    switch (action.type) {\n        case 'SET_VISIBILITY_FILTER':\n            return action.filter\n        default:\n            return state\n    }\n}\n{% endcodeblock %}\n\n{% codeblock %}\n// mutation示例\nmutations: {\n    setVisibilityFilter (state, { filter }) {\n        state.visibilityFilter = filter\n    },\n}\n{% endcodeblock %}\n\n# 4、Action\n\nredux的action是数据从应用到store的有效载何。redux自身只能处理带type属性的object形式的Action，需要支持其他方式的Action（如function、promise）需要通过中间件的方式集成进去。而vuex的action，设计上就是用来处理异步的情况，而不是一个载何，而要更改state还需要在action里面commit一个mutation。\n\n{% codeblock %}\n// redux Action示例\n// 更改过滤条件\nexport function setVisibilityFilter(filter) {\n  return { type: 'SET_VISIBILITY_FILTER', filter }\n}\n{% endcodeblock %}\n\n{% codeblock %}\n// vuex Action示例\nactions: {\n    initTodos ({ commit }) {\n        getTodos().then((data) => {\n            commit('initTodos', {\n                list: data.list,\n            })\n        })\n    }\n}\n{% endcodeblock %}\n\n# 5、结合其他库使用\n\n在结合其他库使用方面，redux其实是不依赖于任何库的，所以它的用途也更广，可以和vue、Angular、Ember、jQuery 甚至纯JavaScript结合使用。不过要和其他库搭配，可能需要做一些工作，比如引入一些其他的库，比如redux和react搭配就会引入\"react-redux\"。\n而vuex本身设计就是为vue做状态管理，vuex作为vue的一个plugin而存在，只能用在vue中，用途较窄。\n\n# 6、结语\n\n以上是在使用redux和vuex过程中，发现它们的一些不同。在此记录下来，即使认识有偏差，也方便日后修改。","slug":"redux8-vuex","published":1,"updated":"2019-01-18T04:59:58.780Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvopi000u4c41t5pjgldo","content":"<p>react和vue作为目前前端非常流行的两大框架，而redux和vuex分别是这两大框架会用到的状态管理库，在学习了redux后，是非常有必要与vuex做一下对比。vuex背后的基本思想，借鉴了redux等库，但是又有所不同，vuex是专门为vue设计的状态管理库，以利用vue的响应机制来进行高效的状态更新。所以如果既用过redux也用过vuex，那就会发现它们之间那么的相似，用起来又有所不同。</p>\n<h1 id=\"1、状态\"><a href=\"#1、状态\" class=\"headerlink\" title=\"1、状态\"></a>1、状态</h1><p>redux和vuex作为状态管理库，都维护着应用的状态（即state）。但是从使用者定义state的方式来看，完全是不一样等。</p>\n<p>在redux里面，state是通过reducer的返回值来确定的，所以是需要分析reducer才能看出它的结构。而vuex里面，state是直接可以定义的。</p>\n<pre><code>import Vuex from &#39;vuex&#39;\nconst store = new Vuex.Store({\n    state: {\n        visibilityFilter: &#39;SHOW_ALL&#39;,\n        todos: [],\n    },\n})</code></pre>\n<p>从这一点来看，虽然都是state，但是vuex的阅读性和维护性更好。所以，我们会看到基于redux基础上的库dva，也采用了vuex的这种方式。</p>\n<h1 id=\"2、获取状态\"><a href=\"#2、获取状态\" class=\"headerlink\" title=\"2、获取状态\"></a>2、获取状态</h1><p>redux中获取状态通过store.getState()方法来获取。而在vuex中，通过store.state.xxx的形式直接获取。并且vuex还提供了getter的方式来派生出一些状态，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>\n<pre><code>&#x2F;&#x2F; vuex的getter\ngetters: {\n    visibilityFilter (state) {\n        return state.visibilityFilter\n    }\n}</code></pre>\n<h1 id=\"3、更改状态\"><a href=\"#3、更改状态\" class=\"headerlink\" title=\"3、更改状态\"></a>3、更改状态</h1><p>redux里面能够更改state是reducer，vuex里面更改state的是mutation，从定义上是不一样的。reducer里面，接收上一次的state和action，返回新的state。而在vuex的mutation里面，会接收state和一个额外的参数，然后直接修改state状态，这一点是利用了vue的特性，所以vuex显得更加灵活一些。</p>\n<pre><code>&#x2F;&#x2F; reducer示例\nfunction visibilityFilter(state = &#39;SHOW_ALL&#39;, action) {\n    switch (action.type) {\n        case &#39;SET_VISIBILITY_FILTER&#39;:\n            return action.filter\n        default:\n            return state\n    }\n}</code></pre>\n<pre><code>&#x2F;&#x2F; mutation示例\nmutations: {\n    setVisibilityFilter (state, { filter }) {\n        state.visibilityFilter = filter\n    },\n}</code></pre>\n<h1 id=\"4、Action\"><a href=\"#4、Action\" class=\"headerlink\" title=\"4、Action\"></a>4、Action</h1><p>redux的action是数据从应用到store的有效载何。redux自身只能处理带type属性的object形式的Action，需要支持其他方式的Action（如function、promise）需要通过中间件的方式集成进去。而vuex的action，设计上就是用来处理异步的情况，而不是一个载何，而要更改state还需要在action里面commit一个mutation。</p>\n<pre><code>&#x2F;&#x2F; redux Action示例\n&#x2F;&#x2F; 更改过滤条件\nexport function setVisibilityFilter(filter) {\n  return { type: &#39;SET_VISIBILITY_FILTER&#39;, filter }\n}</code></pre>\n<pre><code>&#x2F;&#x2F; vuex Action示例\nactions: {\n    initTodos ({ commit }) {\n        getTodos().then((data) =&gt; {\n            commit(&#39;initTodos&#39;, {\n                list: data.list,\n            })\n        })\n    }\n}</code></pre>\n<h1 id=\"5、结合其他库使用\"><a href=\"#5、结合其他库使用\" class=\"headerlink\" title=\"5、结合其他库使用\"></a>5、结合其他库使用</h1><p>在结合其他库使用方面，redux其实是不依赖于任何库的，所以它的用途也更广，可以和vue、Angular、Ember、jQuery 甚至纯JavaScript结合使用。不过要和其他库搭配，可能需要做一些工作，比如引入一些其他的库，比如redux和react搭配就会引入”react-redux”。<br>而vuex本身设计就是为vue做状态管理，vuex作为vue的一个plugin而存在，只能用在vue中，用途较窄。</p>\n<h1 id=\"6、结语\"><a href=\"#6、结语\" class=\"headerlink\" title=\"6、结语\"></a>6、结语</h1><p>以上是在使用redux和vuex过程中，发现它们的一些不同。在此记录下来，即使认识有偏差，也方便日后修改。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>react和vue作为目前前端非常流行的两大框架，而redux和vuex分别是这两大框架会用到的状态管理库，在学习了redux后，是非常有必要与vuex做一下对比。vuex背后的基本思想，借鉴了redux等库，但是又有所不同，vuex是专门为vue设计的状态管理库，以利用vue的响应机制来进行高效的状态更新。所以如果既用过redux也用过vuex，那就会发现它们之间那么的相似，用起来又有所不同。</p>\n<h1 id=\"1、状态\"><a href=\"#1、状态\" class=\"headerlink\" title=\"1、状态\"></a>1、状态</h1><p>redux和vuex作为状态管理库，都维护着应用的状态（即state）。但是从使用者定义state的方式来看，完全是不一样等。</p>\n<p>在redux里面，state是通过reducer的返回值来确定的，所以是需要分析reducer才能看出它的结构。而vuex里面，state是直接可以定义的。</p>\n<pre><code>import Vuex from &#39;vuex&#39;\nconst store = new Vuex.Store({\n    state: {\n        visibilityFilter: &#39;SHOW_ALL&#39;,\n        todos: [],\n    },\n})</code></pre>\n<p>从这一点来看，虽然都是state，但是vuex的阅读性和维护性更好。所以，我们会看到基于redux基础上的库dva，也采用了vuex的这种方式。</p>\n<h1 id=\"2、获取状态\"><a href=\"#2、获取状态\" class=\"headerlink\" title=\"2、获取状态\"></a>2、获取状态</h1><p>redux中获取状态通过store.getState()方法来获取。而在vuex中，通过store.state.xxx的形式直接获取。并且vuex还提供了getter的方式来派生出一些状态，getter的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p>\n<pre><code>&#x2F;&#x2F; vuex的getter\ngetters: {\n    visibilityFilter (state) {\n        return state.visibilityFilter\n    }\n}</code></pre>\n<h1 id=\"3、更改状态\"><a href=\"#3、更改状态\" class=\"headerlink\" title=\"3、更改状态\"></a>3、更改状态</h1><p>redux里面能够更改state是reducer，vuex里面更改state的是mutation，从定义上是不一样的。reducer里面，接收上一次的state和action，返回新的state。而在vuex的mutation里面，会接收state和一个额外的参数，然后直接修改state状态，这一点是利用了vue的特性，所以vuex显得更加灵活一些。</p>\n<pre><code>&#x2F;&#x2F; reducer示例\nfunction visibilityFilter(state = &#39;SHOW_ALL&#39;, action) {\n    switch (action.type) {\n        case &#39;SET_VISIBILITY_FILTER&#39;:\n            return action.filter\n        default:\n            return state\n    }\n}</code></pre>\n<pre><code>&#x2F;&#x2F; mutation示例\nmutations: {\n    setVisibilityFilter (state, { filter }) {\n        state.visibilityFilter = filter\n    },\n}</code></pre>\n<h1 id=\"4、Action\"><a href=\"#4、Action\" class=\"headerlink\" title=\"4、Action\"></a>4、Action</h1><p>redux的action是数据从应用到store的有效载何。redux自身只能处理带type属性的object形式的Action，需要支持其他方式的Action（如function、promise）需要通过中间件的方式集成进去。而vuex的action，设计上就是用来处理异步的情况，而不是一个载何，而要更改state还需要在action里面commit一个mutation。</p>\n<pre><code>&#x2F;&#x2F; redux Action示例\n&#x2F;&#x2F; 更改过滤条件\nexport function setVisibilityFilter(filter) {\n  return { type: &#39;SET_VISIBILITY_FILTER&#39;, filter }\n}</code></pre>\n<pre><code>&#x2F;&#x2F; vuex Action示例\nactions: {\n    initTodos ({ commit }) {\n        getTodos().then((data) =&gt; {\n            commit(&#39;initTodos&#39;, {\n                list: data.list,\n            })\n        })\n    }\n}</code></pre>\n<h1 id=\"5、结合其他库使用\"><a href=\"#5、结合其他库使用\" class=\"headerlink\" title=\"5、结合其他库使用\"></a>5、结合其他库使用</h1><p>在结合其他库使用方面，redux其实是不依赖于任何库的，所以它的用途也更广，可以和vue、Angular、Ember、jQuery 甚至纯JavaScript结合使用。不过要和其他库搭配，可能需要做一些工作，比如引入一些其他的库，比如redux和react搭配就会引入”react-redux”。<br>而vuex本身设计就是为vue做状态管理，vuex作为vue的一个plugin而存在，只能用在vue中，用途较窄。</p>\n<h1 id=\"6、结语\"><a href=\"#6、结语\" class=\"headerlink\" title=\"6、结语\"></a>6、结语</h1><p>以上是在使用redux和vuex过程中，发现它们的一些不同。在此记录下来，即使认识有偏差，也方便日后修改。</p>\n"},{"title":"我的第一篇博客文章","date":"2017-06-23T09:13:02.000Z","_content":"# 1、git提交\n$git add -u //只提交修改过的文件\n$git add -A //全部提交\n$git add -p //对同一个文件进行选择性的提交\n\n# 2、diff\n$git diff\n如果已经git add过，需要加--cached才可以看到\n\n# 3、保存工作进度\n$git stash\n$git checkout <new_branch>\n完成后：\n$git checkout <origin_branch>\n$git stash pop\n\n# 4、代理svn\n$git svn clone <svn_repos_url>\n$git svn fetch\n$git svn rebase\n$git svn dcommit\n\n# 5、分页器\n快捷键\nq - 退出分页器\nh - 显示分页器帮助\n空格 - 下翻一页，b - 上翻一页\nd - 下翻半页，u - 上翻半页\nj - 上翻一行，k - 下翻一行\n左右箭头\n/pattern: 向下寻找和pattern匹配的内容\n?pattern:向上寻找和pattern匹配的内容\nn/N: 向前/向后继续寻找。\ng - 跳到第一行；\nG - 跳到最后一行。\ng + 数字： 跳到相应的行。\n!<command> : 执行Shell命令。","source":"_posts/我的第一篇博客文章.md","raw":"---\ntitle: 我的第一篇博客文章\ndate: 2017-06-23 17:13:02\ntags:\n---\n# 1、git提交\n$git add -u //只提交修改过的文件\n$git add -A //全部提交\n$git add -p //对同一个文件进行选择性的提交\n\n# 2、diff\n$git diff\n如果已经git add过，需要加--cached才可以看到\n\n# 3、保存工作进度\n$git stash\n$git checkout <new_branch>\n完成后：\n$git checkout <origin_branch>\n$git stash pop\n\n# 4、代理svn\n$git svn clone <svn_repos_url>\n$git svn fetch\n$git svn rebase\n$git svn dcommit\n\n# 5、分页器\n快捷键\nq - 退出分页器\nh - 显示分页器帮助\n空格 - 下翻一页，b - 上翻一页\nd - 下翻半页，u - 上翻半页\nj - 上翻一行，k - 下翻一行\n左右箭头\n/pattern: 向下寻找和pattern匹配的内容\n?pattern:向上寻找和pattern匹配的内容\nn/N: 向前/向后继续寻找。\ng - 跳到第一行；\nG - 跳到最后一行。\ng + 数字： 跳到相应的行。\n!<command> : 执行Shell命令。","slug":"我的第一篇博客文章","published":1,"updated":"2019-07-30T04:59:25.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvopk000w4c41805pohdq","content":"<h1 id=\"1、git提交\"><a href=\"#1、git提交\" class=\"headerlink\" title=\"1、git提交\"></a>1、git提交</h1><p>$git add -u //只提交修改过的文件<br>$git add -A //全部提交<br>$git add -p //对同一个文件进行选择性的提交</p>\n<h1 id=\"2、diff\"><a href=\"#2、diff\" class=\"headerlink\" title=\"2、diff\"></a>2、diff</h1><p>$git diff<br>如果已经git add过，需要加–cached才可以看到</p>\n<h1 id=\"3、保存工作进度\"><a href=\"#3、保存工作进度\" class=\"headerlink\" title=\"3、保存工作进度\"></a>3、保存工作进度</h1><p>$git stash<br>$git checkout &lt;new_branch&gt;<br>完成后：<br>$git checkout &lt;origin_branch&gt;<br>$git stash pop</p>\n<h1 id=\"4、代理svn\"><a href=\"#4、代理svn\" class=\"headerlink\" title=\"4、代理svn\"></a>4、代理svn</h1><p>$git svn clone &lt;svn_repos_url&gt;<br>$git svn fetch<br>$git svn rebase<br>$git svn dcommit</p>\n<h1 id=\"5、分页器\"><a href=\"#5、分页器\" class=\"headerlink\" title=\"5、分页器\"></a>5、分页器</h1><p>快捷键<br>q - 退出分页器<br>h - 显示分页器帮助<br>空格 - 下翻一页，b - 上翻一页<br>d - 下翻半页，u - 上翻半页<br>j - 上翻一行，k - 下翻一行<br>左右箭头<br>/pattern: 向下寻找和pattern匹配的内容<br>?pattern:向上寻找和pattern匹配的内容<br>n/N: 向前/向后继续寻找。<br>g - 跳到第一行；<br>G - 跳到最后一行。<br>g + 数字： 跳到相应的行。<br>!<command> : 执行Shell命令。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"1、git提交\"><a href=\"#1、git提交\" class=\"headerlink\" title=\"1、git提交\"></a>1、git提交</h1><p>$git add -u //只提交修改过的文件<br>$git add -A //全部提交<br>$git add -p //对同一个文件进行选择性的提交</p>\n<h1 id=\"2、diff\"><a href=\"#2、diff\" class=\"headerlink\" title=\"2、diff\"></a>2、diff</h1><p>$git diff<br>如果已经git add过，需要加–cached才可以看到</p>\n<h1 id=\"3、保存工作进度\"><a href=\"#3、保存工作进度\" class=\"headerlink\" title=\"3、保存工作进度\"></a>3、保存工作进度</h1><p>$git stash<br>$git checkout &lt;new_branch&gt;<br>完成后：<br>$git checkout &lt;origin_branch&gt;<br>$git stash pop</p>\n<h1 id=\"4、代理svn\"><a href=\"#4、代理svn\" class=\"headerlink\" title=\"4、代理svn\"></a>4、代理svn</h1><p>$git svn clone &lt;svn_repos_url&gt;<br>$git svn fetch<br>$git svn rebase<br>$git svn dcommit</p>\n<h1 id=\"5、分页器\"><a href=\"#5、分页器\" class=\"headerlink\" title=\"5、分页器\"></a>5、分页器</h1><p>快捷键<br>q - 退出分页器<br>h - 显示分页器帮助<br>空格 - 下翻一页，b - 上翻一页<br>d - 下翻半页，u - 上翻半页<br>j - 上翻一行，k - 下翻一行<br>左右箭头<br>/pattern: 向下寻找和pattern匹配的内容<br>?pattern:向上寻找和pattern匹配的内容<br>n/N: 向前/向后继续寻找。<br>g - 跳到第一行；<br>G - 跳到最后一行。<br>g + 数字： 跳到相应的行。<br>!<command> : 执行Shell命令。</p>\n"},{"title":"redux(七)－在vue上应用redux","date":"2019-01-13T13:09:25.000Z","_content":"\nredux作为一个纯状态管理库，不单单能和react配合使用，还可以和vue、Angular、Ember、jQuery 甚至纯JavaScript结合使用。可能大家已经注意到，在redux和react配合使用时，我们还引入了一个\"react-redux\"库，\"react-redux\"就是专门为了将redux应用在react中而开发，所以你会看到react-redux使用Context、HOC这些react技术。既然redux应用可以这么广，那么本文我们就将redux应用在vue中试试看。\n我们仍然以\"待办事项\"作为例子。首先要有一个基础的UI项目，使用vue把它构建起来，大家请看这里{% link vue-base https://github.com/Two-Ftry/react-essay/tree/master/vue-01 %}。具体的搭建我就不在这里细说了。\n\n# 1、整合方式\n\n首先，我们来看，如何在vue中应用redux？这一点我们可以参考vuex这个专门为vue设计的状态管理库。vuex是以插件的方式引入vue中。vue中提供的插件增加功能的方式，允许使用者添加全局功能。\n\nvue中定义一个插件，要求插件对象有一个install方法，vue在添加插件的时候会将Vue自身作为参数传入install方法，然后将用户自定义的参数以第二个参数options传入。\n\n{% codeblock %}\nconst MyPlugin = {}\nMyPlugin.install = function (Vue, options) {\n    // ...\n}\n{% endcodeblock %}\n\n定义好插件之后，只需要使用Vue.use()方法便可将插件引入到vue中。\n{% codeblock %}\nimport Vue from 'vue'\nVue.use(MyPlugin, {...options})\n{% endcodeblock %}\n\nVue的插件功能具体能做的事情如下：\n1. 添加全局方法或属性\n2. 添加全局资源：指令/过滤器/过渡等\n3. 通过全局 mixin 方法添加一些组件选项\n4. 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。\n\n本文我们会使用到第3点。\n\n{% codeblock %}\nMyPlugin.install = function (Vue, options) {\n  // 注入组件\n  Vue.mixin({\n    created: function () {\n      // 逻辑...\n    }\n    ...\n  })\n}\n{% endcodeblock %}\n\n# 2、整合细节\n\n假如我们现在已经有了一个由redux创建的store对象。我们要考虑的几个问题是：\n\n1. vue组件如何获取到redux的state状态(即store.getState()的返回值)。\n2. 当state状态变化时，如何让vue组件中使用的状态也跟着变化。\n3. vue组件中如何dispatch一个Action。\n\n## 问题1\n我们一个问题一个问题来处理。首先第1个，我们可以直接通过将store.getState()方法的返回值mixin到Vue组件中即可。\n\n我们的插件命名为vueRedux的话，那么它看起来时这样的。\n\n{% codeblock %}\nconst vueRedux = {}\nvueRedux.install = function (Vue, options) {\n  const { store } = options \n  // 注入组件\n  Vue.mixin({\n    beforeCreate: function () {\n      this.$store = {}\n      this.$store.state = store.getState()\n    }\n  })\n}\nexport default vueRedux\n{% endcodeblock %}\n\n上面这段代码，在Vue的beforeCreate钩子函数中，我们为组建创建了一个this.$store的空对象，然后将store.getState()的返回值保存在this.$store的state属性中。定义this.$store，主要是想将store相关的属性和方法都放在一个对象下面，方便管理。\n\n## 问题2\n\n接着我们来看第2个问题“当state状态变化时，如何让vue组件中使用的状态也跟着变化”。首先，我们都知道如果redux的state发生变化，我们可以通过store.subscribe()方法来订阅感知state的变化。那获取到新的state后怎样更新到各个组件到$store.state中去呢?\n\n这时，我们需要知道vue本身对数据的控制就是响应式的，比如说定义了一个a属性，b属性依赖于a，那么当a变化时b也会跟着变化。\n\n{% codeblock %}\nnew Vue({\n    data () {\n        return {\n            a: 'hello world'\n        }\n    },\n    computed: {\n        b () {\n            return a + ' xxx'\n        }\n    }\n})\n{% endcodeblock %}\n\n上面这段代码，假如我修改了a的值，computed中定义的b的值也会跟着变化。基于这个理解，我们就可以来解决第2个问题了。我们可以将store.getState()的返回值定义为一个vue实例的state属性，每当检测到store的state发生变化，就更新这个vue实例的state属性。然后我们就把这个vue实例mixin到Vue组件中，不就让state变成响应式的了么？代码如下：\n\n{% codeblock %}\nconst vueRedux = {}\nvueRedux.install = (Vue, { store }) => {\n    // 将redux的state放置到一个vue的实例中，\n    // 每当更新vue实例的state，就能利用vue的特性来触发组件中依赖了state的属性进行更新\n    store._vm = new Vue({\n        data: {\n          state: store.getState()\n        },\n        created () {\n            this.init()\n        },\n        methods: {\n            init () {\n                // redux状态变化\n                store.subscribe(() => {\n                    this.state = store.getState()\n                })\n            }\n        }\n    })\n    // 使用mixin为每一个组件都添加$store属性，以获取store的state和方法\n    Vue.mixin({\n        beforeCreate: function () {\n            this.$store = store._vm\n        }\n    })\n}\n\nexport default vueRedux\n{% endcodeblock %}\n\n引入这个插件后的Vue组件中，就可以通过this.$store.state来获取应用的状态了。\n\n{% codeblock %}\n// 示例代码\nexport default {\n computed: {\n     visibilityFilter () {\n         const state = this.$store.state\n         return state.visibilityFilter\n     }\n }\n}\n{% endcodeblock %}\n\n## 问题3\n\n第3个问题就比较简单，我们只需要为Vue组件mixin进一个dispatch方法即可。这个dispatch()方法就调用store.dispatch()方法来派发action。\n\n{% codeblock %}\n// 使用mixin为每一个组件都添加$store属性，以获取store的state和方法\n    Vue.mixin({\n        beforeCreate: function () {\n            this.$store = store._vm\n            this.$store.dispatch = (action) => {\n                store.dispatch(action)\n            }\n        }\n    })\n{% endcodeblock %}\n\n# 3、插件代码\n经过上一节的分析，vueRedux插件的代码如下：\n{% codeblock %}\n\nconst vueRedux = {}\nvueRedux.install = (Vue, { store }) => {\n    // 将redux的state放置到一个vue的实例中，\n    // 每当更新vue实例的state，就能利用vue的特性来触发组件中依赖了state的属性进行更新\n    store._vm = new Vue({\n        data: {\n          state: store.getState()\n        },\n        created () {\n            this.init()\n        },\n        methods: {\n            init () {\n                // redux状态变化\n                store.subscribe(() => {\n                    this.state = store.getState()\n                })\n            }\n        }\n    })\n    // 使用mixin为每一个组件都添加$store属性，以获取store的state和方法\n    Vue.mixin({\n        beforeCreate: function () {\n            this.$store = store._vm\n            this.$store.dispatch = (action) => {\n                store.dispatch(action)\n            }\n        }\n    })\n}\n\nexport default vueRedux\n{% endcodeblock %}\n\n# 4、最后\n\n要把这个插件应用起来，我们需要使用Vue.use()方法引入插件。\n\n{% codeblock %}\nimport Vue from 'vue'\n// 假如已经有了一个创建redux store并导出store的store.js文件\nimport store from './store'\nVue.use(vueRedux, { store })\n{% endcodeblock %}\n\n本文主要逻辑在于如何实现vueRedux这个插件，文章中的代码并不完整。具体的示例代码大家可以撮{% link 这里vue-03 https://github.com/Two-Ftry/react-essay/tree/master/vue-03  %}。\n\n此外，对于vue和redux整合，github上也有对应的库{% link vueRedux https://github.com/yang-wei/vue-redux %}。这个库和本文的思想很相近，大家要将redux应用在vue的话，可以考虑这个库。不过，当然和vue配合的最好状态管理库是vuex。","source":"_posts/redux7-vue-20190113.md","raw":"---\ntitle: redux(七)－在vue上应用redux\ndate: 2019-01-13 21:09:25\ntags: redux vue\n---\n\nredux作为一个纯状态管理库，不单单能和react配合使用，还可以和vue、Angular、Ember、jQuery 甚至纯JavaScript结合使用。可能大家已经注意到，在redux和react配合使用时，我们还引入了一个\"react-redux\"库，\"react-redux\"就是专门为了将redux应用在react中而开发，所以你会看到react-redux使用Context、HOC这些react技术。既然redux应用可以这么广，那么本文我们就将redux应用在vue中试试看。\n我们仍然以\"待办事项\"作为例子。首先要有一个基础的UI项目，使用vue把它构建起来，大家请看这里{% link vue-base https://github.com/Two-Ftry/react-essay/tree/master/vue-01 %}。具体的搭建我就不在这里细说了。\n\n# 1、整合方式\n\n首先，我们来看，如何在vue中应用redux？这一点我们可以参考vuex这个专门为vue设计的状态管理库。vuex是以插件的方式引入vue中。vue中提供的插件增加功能的方式，允许使用者添加全局功能。\n\nvue中定义一个插件，要求插件对象有一个install方法，vue在添加插件的时候会将Vue自身作为参数传入install方法，然后将用户自定义的参数以第二个参数options传入。\n\n{% codeblock %}\nconst MyPlugin = {}\nMyPlugin.install = function (Vue, options) {\n    // ...\n}\n{% endcodeblock %}\n\n定义好插件之后，只需要使用Vue.use()方法便可将插件引入到vue中。\n{% codeblock %}\nimport Vue from 'vue'\nVue.use(MyPlugin, {...options})\n{% endcodeblock %}\n\nVue的插件功能具体能做的事情如下：\n1. 添加全局方法或属性\n2. 添加全局资源：指令/过滤器/过渡等\n3. 通过全局 mixin 方法添加一些组件选项\n4. 添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。\n\n本文我们会使用到第3点。\n\n{% codeblock %}\nMyPlugin.install = function (Vue, options) {\n  // 注入组件\n  Vue.mixin({\n    created: function () {\n      // 逻辑...\n    }\n    ...\n  })\n}\n{% endcodeblock %}\n\n# 2、整合细节\n\n假如我们现在已经有了一个由redux创建的store对象。我们要考虑的几个问题是：\n\n1. vue组件如何获取到redux的state状态(即store.getState()的返回值)。\n2. 当state状态变化时，如何让vue组件中使用的状态也跟着变化。\n3. vue组件中如何dispatch一个Action。\n\n## 问题1\n我们一个问题一个问题来处理。首先第1个，我们可以直接通过将store.getState()方法的返回值mixin到Vue组件中即可。\n\n我们的插件命名为vueRedux的话，那么它看起来时这样的。\n\n{% codeblock %}\nconst vueRedux = {}\nvueRedux.install = function (Vue, options) {\n  const { store } = options \n  // 注入组件\n  Vue.mixin({\n    beforeCreate: function () {\n      this.$store = {}\n      this.$store.state = store.getState()\n    }\n  })\n}\nexport default vueRedux\n{% endcodeblock %}\n\n上面这段代码，在Vue的beforeCreate钩子函数中，我们为组建创建了一个this.$store的空对象，然后将store.getState()的返回值保存在this.$store的state属性中。定义this.$store，主要是想将store相关的属性和方法都放在一个对象下面，方便管理。\n\n## 问题2\n\n接着我们来看第2个问题“当state状态变化时，如何让vue组件中使用的状态也跟着变化”。首先，我们都知道如果redux的state发生变化，我们可以通过store.subscribe()方法来订阅感知state的变化。那获取到新的state后怎样更新到各个组件到$store.state中去呢?\n\n这时，我们需要知道vue本身对数据的控制就是响应式的，比如说定义了一个a属性，b属性依赖于a，那么当a变化时b也会跟着变化。\n\n{% codeblock %}\nnew Vue({\n    data () {\n        return {\n            a: 'hello world'\n        }\n    },\n    computed: {\n        b () {\n            return a + ' xxx'\n        }\n    }\n})\n{% endcodeblock %}\n\n上面这段代码，假如我修改了a的值，computed中定义的b的值也会跟着变化。基于这个理解，我们就可以来解决第2个问题了。我们可以将store.getState()的返回值定义为一个vue实例的state属性，每当检测到store的state发生变化，就更新这个vue实例的state属性。然后我们就把这个vue实例mixin到Vue组件中，不就让state变成响应式的了么？代码如下：\n\n{% codeblock %}\nconst vueRedux = {}\nvueRedux.install = (Vue, { store }) => {\n    // 将redux的state放置到一个vue的实例中，\n    // 每当更新vue实例的state，就能利用vue的特性来触发组件中依赖了state的属性进行更新\n    store._vm = new Vue({\n        data: {\n          state: store.getState()\n        },\n        created () {\n            this.init()\n        },\n        methods: {\n            init () {\n                // redux状态变化\n                store.subscribe(() => {\n                    this.state = store.getState()\n                })\n            }\n        }\n    })\n    // 使用mixin为每一个组件都添加$store属性，以获取store的state和方法\n    Vue.mixin({\n        beforeCreate: function () {\n            this.$store = store._vm\n        }\n    })\n}\n\nexport default vueRedux\n{% endcodeblock %}\n\n引入这个插件后的Vue组件中，就可以通过this.$store.state来获取应用的状态了。\n\n{% codeblock %}\n// 示例代码\nexport default {\n computed: {\n     visibilityFilter () {\n         const state = this.$store.state\n         return state.visibilityFilter\n     }\n }\n}\n{% endcodeblock %}\n\n## 问题3\n\n第3个问题就比较简单，我们只需要为Vue组件mixin进一个dispatch方法即可。这个dispatch()方法就调用store.dispatch()方法来派发action。\n\n{% codeblock %}\n// 使用mixin为每一个组件都添加$store属性，以获取store的state和方法\n    Vue.mixin({\n        beforeCreate: function () {\n            this.$store = store._vm\n            this.$store.dispatch = (action) => {\n                store.dispatch(action)\n            }\n        }\n    })\n{% endcodeblock %}\n\n# 3、插件代码\n经过上一节的分析，vueRedux插件的代码如下：\n{% codeblock %}\n\nconst vueRedux = {}\nvueRedux.install = (Vue, { store }) => {\n    // 将redux的state放置到一个vue的实例中，\n    // 每当更新vue实例的state，就能利用vue的特性来触发组件中依赖了state的属性进行更新\n    store._vm = new Vue({\n        data: {\n          state: store.getState()\n        },\n        created () {\n            this.init()\n        },\n        methods: {\n            init () {\n                // redux状态变化\n                store.subscribe(() => {\n                    this.state = store.getState()\n                })\n            }\n        }\n    })\n    // 使用mixin为每一个组件都添加$store属性，以获取store的state和方法\n    Vue.mixin({\n        beforeCreate: function () {\n            this.$store = store._vm\n            this.$store.dispatch = (action) => {\n                store.dispatch(action)\n            }\n        }\n    })\n}\n\nexport default vueRedux\n{% endcodeblock %}\n\n# 4、最后\n\n要把这个插件应用起来，我们需要使用Vue.use()方法引入插件。\n\n{% codeblock %}\nimport Vue from 'vue'\n// 假如已经有了一个创建redux store并导出store的store.js文件\nimport store from './store'\nVue.use(vueRedux, { store })\n{% endcodeblock %}\n\n本文主要逻辑在于如何实现vueRedux这个插件，文章中的代码并不完整。具体的示例代码大家可以撮{% link 这里vue-03 https://github.com/Two-Ftry/react-essay/tree/master/vue-03  %}。\n\n此外，对于vue和redux整合，github上也有对应的库{% link vueRedux https://github.com/yang-wei/vue-redux %}。这个库和本文的思想很相近，大家要将redux应用在vue的话，可以考虑这个库。不过，当然和vue配合的最好状态管理库是vuex。","slug":"redux7-vue","published":1,"updated":"2019-01-18T04:59:58.779Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvopm000y4c41dia00msx","content":"<p>redux作为一个纯状态管理库，不单单能和react配合使用，还可以和vue、Angular、Ember、jQuery 甚至纯JavaScript结合使用。可能大家已经注意到，在redux和react配合使用时，我们还引入了一个”react-redux”库，”react-redux”就是专门为了将redux应用在react中而开发，所以你会看到react-redux使用Context、HOC这些react技术。既然redux应用可以这么广，那么本文我们就将redux应用在vue中试试看。<br>我们仍然以”待办事项”作为例子。首先要有一个基础的UI项目，使用vue把它构建起来，大家请看这里<a href=\"https://github.com/Two-Ftry/react-essay/tree/master/vue-01\" target=\"_blank\" rel=\"noopener\">vue-base</a>。具体的搭建我就不在这里细说了。</p>\n<h1 id=\"1、整合方式\"><a href=\"#1、整合方式\" class=\"headerlink\" title=\"1、整合方式\"></a>1、整合方式</h1><p>首先，我们来看，如何在vue中应用redux？这一点我们可以参考vuex这个专门为vue设计的状态管理库。vuex是以插件的方式引入vue中。vue中提供的插件增加功能的方式，允许使用者添加全局功能。</p>\n<p>vue中定义一个插件，要求插件对象有一个install方法，vue在添加插件的时候会将Vue自身作为参数传入install方法，然后将用户自定义的参数以第二个参数options传入。</p>\n<pre><code>const MyPlugin = {}\nMyPlugin.install = function (Vue, options) {\n    &#x2F;&#x2F; ...\n}</code></pre>\n<p>定义好插件之后，只需要使用Vue.use()方法便可将插件引入到vue中。<br><pre><code>import Vue from &#39;vue&#39;\nVue.use(MyPlugin, {...options})</code></pre></p>\n<p>Vue的插件功能具体能做的事情如下：</p>\n<ol>\n<li>添加全局方法或属性</li>\n<li>添加全局资源：指令/过滤器/过渡等</li>\n<li>通过全局 mixin 方法添加一些组件选项</li>\n<li>添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。</li>\n</ol>\n<p>本文我们会使用到第3点。</p>\n<pre><code>MyPlugin.install = function (Vue, options) {\n  &#x2F;&#x2F; 注入组件\n  Vue.mixin({\n    created: function () {\n      &#x2F;&#x2F; 逻辑...\n    }\n    ...\n  })\n}</code></pre>\n<h1 id=\"2、整合细节\"><a href=\"#2、整合细节\" class=\"headerlink\" title=\"2、整合细节\"></a>2、整合细节</h1><p>假如我们现在已经有了一个由redux创建的store对象。我们要考虑的几个问题是：</p>\n<ol>\n<li>vue组件如何获取到redux的state状态(即store.getState()的返回值)。</li>\n<li>当state状态变化时，如何让vue组件中使用的状态也跟着变化。</li>\n<li>vue组件中如何dispatch一个Action。</li>\n</ol>\n<h2 id=\"问题1\"><a href=\"#问题1\" class=\"headerlink\" title=\"问题1\"></a>问题1</h2><p>我们一个问题一个问题来处理。首先第1个，我们可以直接通过将store.getState()方法的返回值mixin到Vue组件中即可。</p>\n<p>我们的插件命名为vueRedux的话，那么它看起来时这样的。</p>\n<pre><code>const vueRedux = {}\nvueRedux.install = function (Vue, options) {\n  const { store } = options \n  &#x2F;&#x2F; 注入组件\n  Vue.mixin({\n    beforeCreate: function () {\n      this.$store = {}\n      this.$store.state = store.getState()\n    }\n  })\n}\nexport default vueRedux</code></pre>\n<p>上面这段代码，在Vue的beforeCreate钩子函数中，我们为组建创建了一个this.$store的空对象，然后将store.getState()的返回值保存在this.$store的state属性中。定义this.$store，主要是想将store相关的属性和方法都放在一个对象下面，方便管理。</p>\n<h2 id=\"问题2\"><a href=\"#问题2\" class=\"headerlink\" title=\"问题2\"></a>问题2</h2><p>接着我们来看第2个问题“当state状态变化时，如何让vue组件中使用的状态也跟着变化”。首先，我们都知道如果redux的state发生变化，我们可以通过store.subscribe()方法来订阅感知state的变化。那获取到新的state后怎样更新到各个组件到$store.state中去呢?</p>\n<p>这时，我们需要知道vue本身对数据的控制就是响应式的，比如说定义了一个a属性，b属性依赖于a，那么当a变化时b也会跟着变化。</p>\n<pre><code>new Vue({\n    data () {\n        return {\n            a: &#39;hello world&#39;\n        }\n    },\n    computed: {\n        b () {\n            return a + &#39; xxx&#39;\n        }\n    }\n})</code></pre>\n<p>上面这段代码，假如我修改了a的值，computed中定义的b的值也会跟着变化。基于这个理解，我们就可以来解决第2个问题了。我们可以将store.getState()的返回值定义为一个vue实例的state属性，每当检测到store的state发生变化，就更新这个vue实例的state属性。然后我们就把这个vue实例mixin到Vue组件中，不就让state变成响应式的了么？代码如下：</p>\n<pre><code>const vueRedux = {}\nvueRedux.install = (Vue, { store }) =&gt; {\n    &#x2F;&#x2F; 将redux的state放置到一个vue的实例中，\n    &#x2F;&#x2F; 每当更新vue实例的state，就能利用vue的特性来触发组件中依赖了state的属性进行更新\n    store._vm = new Vue({\n        data: {\n          state: store.getState()\n        },\n        created () {\n            this.init()\n        },\n        methods: {\n            init () {\n                &#x2F;&#x2F; redux状态变化\n                store.subscribe(() =&gt; {\n                    this.state = store.getState()\n                })\n            }\n        }\n    })\n    &#x2F;&#x2F; 使用mixin为每一个组件都添加$store属性，以获取store的state和方法\n    Vue.mixin({\n        beforeCreate: function () {\n            this.$store = store._vm\n        }\n    })\n}\n\nexport default vueRedux</code></pre>\n<p>引入这个插件后的Vue组件中，就可以通过this.$store.state来获取应用的状态了。</p>\n<pre><code>&#x2F;&#x2F; 示例代码\nexport default {\n computed: {\n     visibilityFilter () {\n         const state = this.$store.state\n         return state.visibilityFilter\n     }\n }\n}</code></pre>\n<h2 id=\"问题3\"><a href=\"#问题3\" class=\"headerlink\" title=\"问题3\"></a>问题3</h2><p>第3个问题就比较简单，我们只需要为Vue组件mixin进一个dispatch方法即可。这个dispatch()方法就调用store.dispatch()方法来派发action。</p>\n<pre><code>&#x2F;&#x2F; 使用mixin为每一个组件都添加$store属性，以获取store的state和方法\n    Vue.mixin({\n        beforeCreate: function () {\n            this.$store = store._vm\n            this.$store.dispatch = (action) =&gt; {\n                store.dispatch(action)\n            }\n        }\n    })</code></pre>\n<h1 id=\"3、插件代码\"><a href=\"#3、插件代码\" class=\"headerlink\" title=\"3、插件代码\"></a>3、插件代码</h1><p>经过上一节的分析，vueRedux插件的代码如下：<br><pre><code>\nconst vueRedux = {}\nvueRedux.install = (Vue, { store }) =&gt; {\n    &#x2F;&#x2F; 将redux的state放置到一个vue的实例中，\n    &#x2F;&#x2F; 每当更新vue实例的state，就能利用vue的特性来触发组件中依赖了state的属性进行更新\n    store._vm = new Vue({\n        data: {\n          state: store.getState()\n        },\n        created () {\n            this.init()\n        },\n        methods: {\n            init () {\n                &#x2F;&#x2F; redux状态变化\n                store.subscribe(() =&gt; {\n                    this.state = store.getState()\n                })\n            }\n        }\n    })\n    &#x2F;&#x2F; 使用mixin为每一个组件都添加$store属性，以获取store的state和方法\n    Vue.mixin({\n        beforeCreate: function () {\n            this.$store = store._vm\n            this.$store.dispatch = (action) =&gt; {\n                store.dispatch(action)\n            }\n        }\n    })\n}\n\nexport default vueRedux</code></pre></p>\n<h1 id=\"4、最后\"><a href=\"#4、最后\" class=\"headerlink\" title=\"4、最后\"></a>4、最后</h1><p>要把这个插件应用起来，我们需要使用Vue.use()方法引入插件。</p>\n<pre><code>import Vue from &#39;vue&#39;\n&#x2F;&#x2F; 假如已经有了一个创建redux store并导出store的store.js文件\nimport store from &#39;.&#x2F;store&#39;\nVue.use(vueRedux, { store })</code></pre>\n<p>本文主要逻辑在于如何实现vueRedux这个插件，文章中的代码并不完整。具体的示例代码大家可以撮<a href=\"https://github.com/Two-Ftry/react-essay/tree/master/vue-03\" target=\"_blank\" rel=\"noopener\">这里vue-03</a>。</p>\n<p>此外，对于vue和redux整合，github上也有对应的库<a href=\"https://github.com/yang-wei/vue-redux\" target=\"_blank\" rel=\"noopener\">vueRedux</a>。这个库和本文的思想很相近，大家要将redux应用在vue的话，可以考虑这个库。不过，当然和vue配合的最好状态管理库是vuex。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>redux作为一个纯状态管理库，不单单能和react配合使用，还可以和vue、Angular、Ember、jQuery 甚至纯JavaScript结合使用。可能大家已经注意到，在redux和react配合使用时，我们还引入了一个”react-redux”库，”react-redux”就是专门为了将redux应用在react中而开发，所以你会看到react-redux使用Context、HOC这些react技术。既然redux应用可以这么广，那么本文我们就将redux应用在vue中试试看。<br>我们仍然以”待办事项”作为例子。首先要有一个基础的UI项目，使用vue把它构建起来，大家请看这里<a href=\"https://github.com/Two-Ftry/react-essay/tree/master/vue-01\" target=\"_blank\" rel=\"noopener\">vue-base</a>。具体的搭建我就不在这里细说了。</p>\n<h1 id=\"1、整合方式\"><a href=\"#1、整合方式\" class=\"headerlink\" title=\"1、整合方式\"></a>1、整合方式</h1><p>首先，我们来看，如何在vue中应用redux？这一点我们可以参考vuex这个专门为vue设计的状态管理库。vuex是以插件的方式引入vue中。vue中提供的插件增加功能的方式，允许使用者添加全局功能。</p>\n<p>vue中定义一个插件，要求插件对象有一个install方法，vue在添加插件的时候会将Vue自身作为参数传入install方法，然后将用户自定义的参数以第二个参数options传入。</p>\n<pre><code>const MyPlugin = {}\nMyPlugin.install = function (Vue, options) {\n    &#x2F;&#x2F; ...\n}</code></pre>\n<p>定义好插件之后，只需要使用Vue.use()方法便可将插件引入到vue中。<br><pre><code>import Vue from &#39;vue&#39;\nVue.use(MyPlugin, {...options})</code></pre></p>\n<p>Vue的插件功能具体能做的事情如下：</p>\n<ol>\n<li>添加全局方法或属性</li>\n<li>添加全局资源：指令/过滤器/过渡等</li>\n<li>通过全局 mixin 方法添加一些组件选项</li>\n<li>添加 Vue 实例方法，通过把它们添加到 Vue.prototype 上实现。</li>\n</ol>\n<p>本文我们会使用到第3点。</p>\n<pre><code>MyPlugin.install = function (Vue, options) {\n  &#x2F;&#x2F; 注入组件\n  Vue.mixin({\n    created: function () {\n      &#x2F;&#x2F; 逻辑...\n    }\n    ...\n  })\n}</code></pre>\n<h1 id=\"2、整合细节\"><a href=\"#2、整合细节\" class=\"headerlink\" title=\"2、整合细节\"></a>2、整合细节</h1><p>假如我们现在已经有了一个由redux创建的store对象。我们要考虑的几个问题是：</p>\n<ol>\n<li>vue组件如何获取到redux的state状态(即store.getState()的返回值)。</li>\n<li>当state状态变化时，如何让vue组件中使用的状态也跟着变化。</li>\n<li>vue组件中如何dispatch一个Action。</li>\n</ol>\n<h2 id=\"问题1\"><a href=\"#问题1\" class=\"headerlink\" title=\"问题1\"></a>问题1</h2><p>我们一个问题一个问题来处理。首先第1个，我们可以直接通过将store.getState()方法的返回值mixin到Vue组件中即可。</p>\n<p>我们的插件命名为vueRedux的话，那么它看起来时这样的。</p>\n<pre><code>const vueRedux = {}\nvueRedux.install = function (Vue, options) {\n  const { store } = options \n  &#x2F;&#x2F; 注入组件\n  Vue.mixin({\n    beforeCreate: function () {\n      this.$store = {}\n      this.$store.state = store.getState()\n    }\n  })\n}\nexport default vueRedux</code></pre>\n<p>上面这段代码，在Vue的beforeCreate钩子函数中，我们为组建创建了一个this.$store的空对象，然后将store.getState()的返回值保存在this.$store的state属性中。定义this.$store，主要是想将store相关的属性和方法都放在一个对象下面，方便管理。</p>\n<h2 id=\"问题2\"><a href=\"#问题2\" class=\"headerlink\" title=\"问题2\"></a>问题2</h2><p>接着我们来看第2个问题“当state状态变化时，如何让vue组件中使用的状态也跟着变化”。首先，我们都知道如果redux的state发生变化，我们可以通过store.subscribe()方法来订阅感知state的变化。那获取到新的state后怎样更新到各个组件到$store.state中去呢?</p>\n<p>这时，我们需要知道vue本身对数据的控制就是响应式的，比如说定义了一个a属性，b属性依赖于a，那么当a变化时b也会跟着变化。</p>\n<pre><code>new Vue({\n    data () {\n        return {\n            a: &#39;hello world&#39;\n        }\n    },\n    computed: {\n        b () {\n            return a + &#39; xxx&#39;\n        }\n    }\n})</code></pre>\n<p>上面这段代码，假如我修改了a的值，computed中定义的b的值也会跟着变化。基于这个理解，我们就可以来解决第2个问题了。我们可以将store.getState()的返回值定义为一个vue实例的state属性，每当检测到store的state发生变化，就更新这个vue实例的state属性。然后我们就把这个vue实例mixin到Vue组件中，不就让state变成响应式的了么？代码如下：</p>\n<pre><code>const vueRedux = {}\nvueRedux.install = (Vue, { store }) =&gt; {\n    &#x2F;&#x2F; 将redux的state放置到一个vue的实例中，\n    &#x2F;&#x2F; 每当更新vue实例的state，就能利用vue的特性来触发组件中依赖了state的属性进行更新\n    store._vm = new Vue({\n        data: {\n          state: store.getState()\n        },\n        created () {\n            this.init()\n        },\n        methods: {\n            init () {\n                &#x2F;&#x2F; redux状态变化\n                store.subscribe(() =&gt; {\n                    this.state = store.getState()\n                })\n            }\n        }\n    })\n    &#x2F;&#x2F; 使用mixin为每一个组件都添加$store属性，以获取store的state和方法\n    Vue.mixin({\n        beforeCreate: function () {\n            this.$store = store._vm\n        }\n    })\n}\n\nexport default vueRedux</code></pre>\n<p>引入这个插件后的Vue组件中，就可以通过this.$store.state来获取应用的状态了。</p>\n<pre><code>&#x2F;&#x2F; 示例代码\nexport default {\n computed: {\n     visibilityFilter () {\n         const state = this.$store.state\n         return state.visibilityFilter\n     }\n }\n}</code></pre>\n<h2 id=\"问题3\"><a href=\"#问题3\" class=\"headerlink\" title=\"问题3\"></a>问题3</h2><p>第3个问题就比较简单，我们只需要为Vue组件mixin进一个dispatch方法即可。这个dispatch()方法就调用store.dispatch()方法来派发action。</p>\n<pre><code>&#x2F;&#x2F; 使用mixin为每一个组件都添加$store属性，以获取store的state和方法\n    Vue.mixin({\n        beforeCreate: function () {\n            this.$store = store._vm\n            this.$store.dispatch = (action) =&gt; {\n                store.dispatch(action)\n            }\n        }\n    })</code></pre>\n<h1 id=\"3、插件代码\"><a href=\"#3、插件代码\" class=\"headerlink\" title=\"3、插件代码\"></a>3、插件代码</h1><p>经过上一节的分析，vueRedux插件的代码如下：<br><pre><code>\nconst vueRedux = {}\nvueRedux.install = (Vue, { store }) =&gt; {\n    &#x2F;&#x2F; 将redux的state放置到一个vue的实例中，\n    &#x2F;&#x2F; 每当更新vue实例的state，就能利用vue的特性来触发组件中依赖了state的属性进行更新\n    store._vm = new Vue({\n        data: {\n          state: store.getState()\n        },\n        created () {\n            this.init()\n        },\n        methods: {\n            init () {\n                &#x2F;&#x2F; redux状态变化\n                store.subscribe(() =&gt; {\n                    this.state = store.getState()\n                })\n            }\n        }\n    })\n    &#x2F;&#x2F; 使用mixin为每一个组件都添加$store属性，以获取store的state和方法\n    Vue.mixin({\n        beforeCreate: function () {\n            this.$store = store._vm\n            this.$store.dispatch = (action) =&gt; {\n                store.dispatch(action)\n            }\n        }\n    })\n}\n\nexport default vueRedux</code></pre></p>\n<h1 id=\"4、最后\"><a href=\"#4、最后\" class=\"headerlink\" title=\"4、最后\"></a>4、最后</h1><p>要把这个插件应用起来，我们需要使用Vue.use()方法引入插件。</p>\n<pre><code>import Vue from &#39;vue&#39;\n&#x2F;&#x2F; 假如已经有了一个创建redux store并导出store的store.js文件\nimport store from &#39;.&#x2F;store&#39;\nVue.use(vueRedux, { store })</code></pre>\n<p>本文主要逻辑在于如何实现vueRedux这个插件，文章中的代码并不完整。具体的示例代码大家可以撮<a href=\"https://github.com/Two-Ftry/react-essay/tree/master/vue-03\" target=\"_blank\" rel=\"noopener\">这里vue-03</a>。</p>\n<p>此外，对于vue和redux整合，github上也有对应的库<a href=\"https://github.com/yang-wei/vue-redux\" target=\"_blank\" rel=\"noopener\">vueRedux</a>。这个库和本文的思想很相近，大家要将redux应用在vue的话，可以考虑这个库。不过，当然和vue配合的最好状态管理库是vuex。</p>\n"},{"title":"前端也来学AI","date":"2019-06-05T09:38:21.000Z","_content":"\n## 前端与机器学习\n\n前端与机器学习，很多时候不会有交集。但是当一个前端要去开发一个机器学习平台的UI时，交集就产生了。对一个前端来说，这是一个挑战，同时也是一个机遇。\n\n从最开始接触到机器学习平台，面对各种组件、算法不知所措时，然后就疯狂地去看博客了解如何入门机器学习。一般博客会推荐你先学习线性代数、高数、概率论，然后再开始开免费的机器学习视频，推荐的入门书籍。你会发现这是一个门槛很高技术领域。如果从线性代数、高数、概率论学习完，再来了解机器学习，估计得耗费非常大的精力。\n\n随着几个月的学习，发现有些机器学习的算法只需要简单的数学知识，就能开始入门了。从这些地方作为切入点，显得再好不过。\n\n## kNN算法\n\nkNN，英文全名 为k-NearestNeighbor，中文叫k-近邻算法。它的工作原理是：存在一个样本数据集合（训练样本集），并且样本集中每个数据都存在标签；输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行对比，然后提取出样本集中特征最相似数据的分类标签。一般来说，只选取前k个数据，这就是k-邻近算法的由来。\n\n假设有这样一组数据：\n\n```\ndata = [\n  [1, 1.1],\n  [1, 1],\n  [0, 0],\n  [0, 0.1]\n]\n// data中每个数据对应的标签\nlables = ['A', 'A', 'B', 'B']\n```\n\n当我输入数据 [0.2, 0.1]的时候，kNN算法就会判断这个点与哪个点最相近，进而得出输入数据属于哪个标签。\n那这里涉及到了什么数学知识点呢？这就要提及欧式公式，计算两个向量点xA和xB之间的距离：\n\n```\nd = √((xA0-xB0)^2+(xA1-xB1)^2) \n```\n例如，点(0,0)和(1,2)之间的距离计算为：\n\n```\n√((1-0)^2+(2-0)^2) // =>√5\n```\n\n当遇到三个或三个以上特征的时候，该公式也适用。\n\nkNN是一个非常简单的机器学习算法，我们用python实现一下。\n\n```python\nimport numpy\ndef classify0(inX, dataSet, labels, k):\n    # 获取训练样本的大小\n    dataSetSize = dataSet.shape[0]\n    # 用样本数据构建和训练数据集一样的数组，再减去训练数据集\n    diffMat = numpy.tile(inX, (dataSetSize, 1)) - dataSet\n    # 下面是应用欧式公式，先平方，再求和，最后开方\n    sqDiffMat = diffMat**2\n    sqDistances = sqDiffMat.sum(axis=1)\n    distances  = sqDistances**0.5\n    # 下面是从欧式公式计算的结果中选取k个最相似的标签\n    sortedDistIndicies = distances.argsort()\n    classCount={}\n    for i in range(k):\n        voteIlabel = labels[sortedDistIndicies[i]]\n        classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1\n    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1),reverse=True)\n    return sortedClassCount[0][0]\n```\nkNN是一个非常简单的机器学习算法，对于入门机器学习再合适不过，只需要了解欧式公式即可。然后通过这里还可以补补向量的概念。\n\n那它在实际应用中，可以应用在相亲网站的条件匹配上，同时也可以识别简单的手写数字等等。反正可以统一输出为数据，然后标签化的数据，都可以应用上它。\n\n## decisionTree算法\n\ndecisionTree，决策树算法。决策树算法，我们举邮件分类的例子来说明最好不过了。假如我们有一堆邮件，那如何将他们自动分类呢？假如邮件中包含\"王者荣耀\"的关键字自动分类为\"无聊时需要阅读的邮件\"；如果没有包含，进一步判断邮件中是否包含\"工作\"的关键字，如果有，自动分类为\"需要及时处理的邮件\"，否则分类为\"无聊时需要阅读的邮件\"。以此类推。\n\n决策树算法里面涉及到的数学概念是\"熵\"。熵定义为信息的期望值。如果待分类的事务可能分类在多个分类中，则符号Xi的信息定义为:\n\n```\n# P(Xi)为选择该分类的概率\nl(Xi)=-log2P(Xi)\n```\n\n为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值，公式如下：\n\n```\nH=- SUM1-n (P(Xi) * log2P(Xi))\n```\n\n应用这个公式，我们用python来实现计算熵的。\n\n```python\ndef caclShannonEnt (dataSet):\n    numEntries = len(dataSet)\n    # 计算类别\n    labelCounts = {}\n    for featVec in dataSet:\n      currentLabel = featVec[-1]\n      if currentLabel not in labelCounts.keys():\n        labelCounts[currentLabel] = 0\n      labelCounts[currentLabel] += 1\n    # 计算熵\n    shannonEnt = 0.0\n    for key in labelCounts:\n      prob = float(labelCounts[key])/numEntries\n      shannonEnt -= prob * log(prob, 2)\n    return shannonEnt\n```\n\n然后对于给定的一个数据集（训练数据集，最后一个列为标签），就可以根据特征划分数据，度量划分数据集的熵，以便判断当前是否正确划分了数据集。\n\n```python\n  def splitDataSet(dataSet, axis, value):\n    retDataSet = []\n    for featVec in dataSet:\n      if featVec[axis] == value:\n        reducedFeatVec = featVec[:axis]\n        reducedFeatVec.extend(featVec[axis+1:])\n        retDataSet.append(reducedFeatVec)\n    return retDataSet\n\n  def chooseBestFeatureToSplit(dataSet):\n    numFeatures = len(dataSet[0]) - 1\n    baseEntropy = caclShannonEnt(dataSet)\n    bestInfoGain = 0.0\n    bestFeature = -1\n    for i in range(numFeatures):\n      featList = [example[i] for example in dataSet]\n      uniqueVals = set(featList)\n      newEntropy = 0.0\n      for value in uniqueVals:\n        subDataSet = splitDataSet(dataSet, i, value)\n        prob = len(subDataSet)/float(len(dataSet))\n        newEntropy += prob * caclShannonEnt(subDataSet)\n      infoGain = baseEntropy - newEntropy\n      if (infoGain > bestInfoGain):\n        bestInfoGain = infoGain\n        bestFeature = i\n    return bestFeature\n\n  # 多数表决 ----------------------------------------------------------\n  def majorityCnt(classList):\n    classCount = {}\n    for vote in classList:\n      if vote not in classCount.keys():\n        classCount[vote] = 0\n      classCount[vote] += 1\n    sortedClassCount = sorted(classCount.iteritems(), key = operator.itemgetter(1), reverse = True)\n    return sortedClassCount[0][0]\n  \n  # 创建树 ---\n  def createTree(dataSet, labels):\n    classList = [example[-1] for example in dataSet]\n    if classList.count(classList[0]) == len(classList):\n      return classList[0]\n    if len(dataSet[0]) == 1:\n      return majorityCnt(classList)\n    bestFeat = chooseBestFeatureToSplit(dataSet)\n    bestFeatLabel = labels[bestFeat]\n    myTree = {bestFeatLabel:{}}\n    del(labels[bestFeat])\n    featValues = [example[bestFeat] for example in dataSet]\n    uniqueVals = set(featValues)\n    for value in uniqueVals:\n      subLabels = labels[:]\n      myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels)\n    return myTree\n```\n\n以上，就是决策树构建的代码。对于决策树，比较难以理解的是熵的概念。在了解了熵的基础上，决策树的算法逻辑也就比较简单地就写出来了。\n\n## 总结\n\n从这些简单的算法去入门机器学习，每个阶段让自己有一些产出，既能不断地学习，也能不断激励自己。然后不断补充自己的遗漏的数学知识，再去深入了解更多的机器学习算法。这样一个渐进的过程，对于了解机器学习这样高门槛的技术领域，也不妨是一条可行的道路。\n\n当然上面使用到了python，对于前端来说，还要学习一下python的基础语法。不过python来说，花一个星期左右的时间去看看文档，基本上也就入门了。","source":"_posts/前端也来学AI-20181130.md","raw":"---\ntitle: 前端也来学AI\ndate: 2019-06-05 17:38:21\ncategories: \n- Diary\n- Life\ntags:\n- AI\n---\n\n## 前端与机器学习\n\n前端与机器学习，很多时候不会有交集。但是当一个前端要去开发一个机器学习平台的UI时，交集就产生了。对一个前端来说，这是一个挑战，同时也是一个机遇。\n\n从最开始接触到机器学习平台，面对各种组件、算法不知所措时，然后就疯狂地去看博客了解如何入门机器学习。一般博客会推荐你先学习线性代数、高数、概率论，然后再开始开免费的机器学习视频，推荐的入门书籍。你会发现这是一个门槛很高技术领域。如果从线性代数、高数、概率论学习完，再来了解机器学习，估计得耗费非常大的精力。\n\n随着几个月的学习，发现有些机器学习的算法只需要简单的数学知识，就能开始入门了。从这些地方作为切入点，显得再好不过。\n\n## kNN算法\n\nkNN，英文全名 为k-NearestNeighbor，中文叫k-近邻算法。它的工作原理是：存在一个样本数据集合（训练样本集），并且样本集中每个数据都存在标签；输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行对比，然后提取出样本集中特征最相似数据的分类标签。一般来说，只选取前k个数据，这就是k-邻近算法的由来。\n\n假设有这样一组数据：\n\n```\ndata = [\n  [1, 1.1],\n  [1, 1],\n  [0, 0],\n  [0, 0.1]\n]\n// data中每个数据对应的标签\nlables = ['A', 'A', 'B', 'B']\n```\n\n当我输入数据 [0.2, 0.1]的时候，kNN算法就会判断这个点与哪个点最相近，进而得出输入数据属于哪个标签。\n那这里涉及到了什么数学知识点呢？这就要提及欧式公式，计算两个向量点xA和xB之间的距离：\n\n```\nd = √((xA0-xB0)^2+(xA1-xB1)^2) \n```\n例如，点(0,0)和(1,2)之间的距离计算为：\n\n```\n√((1-0)^2+(2-0)^2) // =>√5\n```\n\n当遇到三个或三个以上特征的时候，该公式也适用。\n\nkNN是一个非常简单的机器学习算法，我们用python实现一下。\n\n```python\nimport numpy\ndef classify0(inX, dataSet, labels, k):\n    # 获取训练样本的大小\n    dataSetSize = dataSet.shape[0]\n    # 用样本数据构建和训练数据集一样的数组，再减去训练数据集\n    diffMat = numpy.tile(inX, (dataSetSize, 1)) - dataSet\n    # 下面是应用欧式公式，先平方，再求和，最后开方\n    sqDiffMat = diffMat**2\n    sqDistances = sqDiffMat.sum(axis=1)\n    distances  = sqDistances**0.5\n    # 下面是从欧式公式计算的结果中选取k个最相似的标签\n    sortedDistIndicies = distances.argsort()\n    classCount={}\n    for i in range(k):\n        voteIlabel = labels[sortedDistIndicies[i]]\n        classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1\n    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1),reverse=True)\n    return sortedClassCount[0][0]\n```\nkNN是一个非常简单的机器学习算法，对于入门机器学习再合适不过，只需要了解欧式公式即可。然后通过这里还可以补补向量的概念。\n\n那它在实际应用中，可以应用在相亲网站的条件匹配上，同时也可以识别简单的手写数字等等。反正可以统一输出为数据，然后标签化的数据，都可以应用上它。\n\n## decisionTree算法\n\ndecisionTree，决策树算法。决策树算法，我们举邮件分类的例子来说明最好不过了。假如我们有一堆邮件，那如何将他们自动分类呢？假如邮件中包含\"王者荣耀\"的关键字自动分类为\"无聊时需要阅读的邮件\"；如果没有包含，进一步判断邮件中是否包含\"工作\"的关键字，如果有，自动分类为\"需要及时处理的邮件\"，否则分类为\"无聊时需要阅读的邮件\"。以此类推。\n\n决策树算法里面涉及到的数学概念是\"熵\"。熵定义为信息的期望值。如果待分类的事务可能分类在多个分类中，则符号Xi的信息定义为:\n\n```\n# P(Xi)为选择该分类的概率\nl(Xi)=-log2P(Xi)\n```\n\n为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值，公式如下：\n\n```\nH=- SUM1-n (P(Xi) * log2P(Xi))\n```\n\n应用这个公式，我们用python来实现计算熵的。\n\n```python\ndef caclShannonEnt (dataSet):\n    numEntries = len(dataSet)\n    # 计算类别\n    labelCounts = {}\n    for featVec in dataSet:\n      currentLabel = featVec[-1]\n      if currentLabel not in labelCounts.keys():\n        labelCounts[currentLabel] = 0\n      labelCounts[currentLabel] += 1\n    # 计算熵\n    shannonEnt = 0.0\n    for key in labelCounts:\n      prob = float(labelCounts[key])/numEntries\n      shannonEnt -= prob * log(prob, 2)\n    return shannonEnt\n```\n\n然后对于给定的一个数据集（训练数据集，最后一个列为标签），就可以根据特征划分数据，度量划分数据集的熵，以便判断当前是否正确划分了数据集。\n\n```python\n  def splitDataSet(dataSet, axis, value):\n    retDataSet = []\n    for featVec in dataSet:\n      if featVec[axis] == value:\n        reducedFeatVec = featVec[:axis]\n        reducedFeatVec.extend(featVec[axis+1:])\n        retDataSet.append(reducedFeatVec)\n    return retDataSet\n\n  def chooseBestFeatureToSplit(dataSet):\n    numFeatures = len(dataSet[0]) - 1\n    baseEntropy = caclShannonEnt(dataSet)\n    bestInfoGain = 0.0\n    bestFeature = -1\n    for i in range(numFeatures):\n      featList = [example[i] for example in dataSet]\n      uniqueVals = set(featList)\n      newEntropy = 0.0\n      for value in uniqueVals:\n        subDataSet = splitDataSet(dataSet, i, value)\n        prob = len(subDataSet)/float(len(dataSet))\n        newEntropy += prob * caclShannonEnt(subDataSet)\n      infoGain = baseEntropy - newEntropy\n      if (infoGain > bestInfoGain):\n        bestInfoGain = infoGain\n        bestFeature = i\n    return bestFeature\n\n  # 多数表决 ----------------------------------------------------------\n  def majorityCnt(classList):\n    classCount = {}\n    for vote in classList:\n      if vote not in classCount.keys():\n        classCount[vote] = 0\n      classCount[vote] += 1\n    sortedClassCount = sorted(classCount.iteritems(), key = operator.itemgetter(1), reverse = True)\n    return sortedClassCount[0][0]\n  \n  # 创建树 ---\n  def createTree(dataSet, labels):\n    classList = [example[-1] for example in dataSet]\n    if classList.count(classList[0]) == len(classList):\n      return classList[0]\n    if len(dataSet[0]) == 1:\n      return majorityCnt(classList)\n    bestFeat = chooseBestFeatureToSplit(dataSet)\n    bestFeatLabel = labels[bestFeat]\n    myTree = {bestFeatLabel:{}}\n    del(labels[bestFeat])\n    featValues = [example[bestFeat] for example in dataSet]\n    uniqueVals = set(featValues)\n    for value in uniqueVals:\n      subLabels = labels[:]\n      myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels)\n    return myTree\n```\n\n以上，就是决策树构建的代码。对于决策树，比较难以理解的是熵的概念。在了解了熵的基础上，决策树的算法逻辑也就比较简单地就写出来了。\n\n## 总结\n\n从这些简单的算法去入门机器学习，每个阶段让自己有一些产出，既能不断地学习，也能不断激励自己。然后不断补充自己的遗漏的数学知识，再去深入了解更多的机器学习算法。这样一个渐进的过程，对于了解机器学习这样高门槛的技术领域，也不妨是一条可行的道路。\n\n当然上面使用到了python，对于前端来说，还要学习一下python的基础语法。不过python来说，花一个星期左右的时间去看看文档，基本上也就入门了。","slug":"前端也来学AI","published":1,"updated":"2019-07-04T17:18:48.110Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvopo00104c41jd2180i4","content":"<h2 id=\"前端与机器学习\"><a href=\"#前端与机器学习\" class=\"headerlink\" title=\"前端与机器学习\"></a>前端与机器学习</h2><p>前端与机器学习，很多时候不会有交集。但是当一个前端要去开发一个机器学习平台的UI时，交集就产生了。对一个前端来说，这是一个挑战，同时也是一个机遇。</p>\n<p>从最开始接触到机器学习平台，面对各种组件、算法不知所措时，然后就疯狂地去看博客了解如何入门机器学习。一般博客会推荐你先学习线性代数、高数、概率论，然后再开始开免费的机器学习视频，推荐的入门书籍。你会发现这是一个门槛很高技术领域。如果从线性代数、高数、概率论学习完，再来了解机器学习，估计得耗费非常大的精力。</p>\n<p>随着几个月的学习，发现有些机器学习的算法只需要简单的数学知识，就能开始入门了。从这些地方作为切入点，显得再好不过。</p>\n<h2 id=\"kNN算法\"><a href=\"#kNN算法\" class=\"headerlink\" title=\"kNN算法\"></a>kNN算法</h2><p>kNN，英文全名 为k-NearestNeighbor，中文叫k-近邻算法。它的工作原理是：存在一个样本数据集合（训练样本集），并且样本集中每个数据都存在标签；输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行对比，然后提取出样本集中特征最相似数据的分类标签。一般来说，只选取前k个数据，这就是k-邻近算法的由来。</p>\n<p>假设有这样一组数据：</p>\n<pre><code>data = [\n  [1, 1.1],\n  [1, 1],\n  [0, 0],\n  [0, 0.1]\n]\n// data中每个数据对应的标签\nlables = [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;]\n</code></pre><p>当我输入数据 [0.2, 0.1]的时候，kNN算法就会判断这个点与哪个点最相近，进而得出输入数据属于哪个标签。<br>那这里涉及到了什么数学知识点呢？这就要提及欧式公式，计算两个向量点xA和xB之间的距离：</p>\n<pre><code>d = √((xA0-xB0)^2+(xA1-xB1)^2) \n</code></pre><p>例如，点(0,0)和(1,2)之间的距离计算为：</p>\n<pre><code>√((1-0)^2+(2-0)^2) // =&gt;√5\n</code></pre><p>当遇到三个或三个以上特征的时候，该公式也适用。</p>\n<p>kNN是一个非常简单的机器学习算法，我们用python实现一下。</p>\n<pre><code class=\"python\">import numpy\ndef classify0(inX, dataSet, labels, k):\n    # 获取训练样本的大小\n    dataSetSize = dataSet.shape[0]\n    # 用样本数据构建和训练数据集一样的数组，再减去训练数据集\n    diffMat = numpy.tile(inX, (dataSetSize, 1)) - dataSet\n    # 下面是应用欧式公式，先平方，再求和，最后开方\n    sqDiffMat = diffMat**2\n    sqDistances = sqDiffMat.sum(axis=1)\n    distances  = sqDistances**0.5\n    # 下面是从欧式公式计算的结果中选取k个最相似的标签\n    sortedDistIndicies = distances.argsort()\n    classCount={}\n    for i in range(k):\n        voteIlabel = labels[sortedDistIndicies[i]]\n        classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1\n    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1),reverse=True)\n    return sortedClassCount[0][0]\n</code></pre>\n<p>kNN是一个非常简单的机器学习算法，对于入门机器学习再合适不过，只需要了解欧式公式即可。然后通过这里还可以补补向量的概念。</p>\n<p>那它在实际应用中，可以应用在相亲网站的条件匹配上，同时也可以识别简单的手写数字等等。反正可以统一输出为数据，然后标签化的数据，都可以应用上它。</p>\n<h2 id=\"decisionTree算法\"><a href=\"#decisionTree算法\" class=\"headerlink\" title=\"decisionTree算法\"></a>decisionTree算法</h2><p>decisionTree，决策树算法。决策树算法，我们举邮件分类的例子来说明最好不过了。假如我们有一堆邮件，那如何将他们自动分类呢？假如邮件中包含”王者荣耀”的关键字自动分类为”无聊时需要阅读的邮件”；如果没有包含，进一步判断邮件中是否包含”工作”的关键字，如果有，自动分类为”需要及时处理的邮件”，否则分类为”无聊时需要阅读的邮件”。以此类推。</p>\n<p>决策树算法里面涉及到的数学概念是”熵”。熵定义为信息的期望值。如果待分类的事务可能分类在多个分类中，则符号Xi的信息定义为:</p>\n<pre><code># P(Xi)为选择该分类的概率\nl(Xi)=-log2P(Xi)\n</code></pre><p>为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值，公式如下：</p>\n<pre><code>H=- SUM1-n (P(Xi) * log2P(Xi))\n</code></pre><p>应用这个公式，我们用python来实现计算熵的。</p>\n<pre><code class=\"python\">def caclShannonEnt (dataSet):\n    numEntries = len(dataSet)\n    # 计算类别\n    labelCounts = {}\n    for featVec in dataSet:\n      currentLabel = featVec[-1]\n      if currentLabel not in labelCounts.keys():\n        labelCounts[currentLabel] = 0\n      labelCounts[currentLabel] += 1\n    # 计算熵\n    shannonEnt = 0.0\n    for key in labelCounts:\n      prob = float(labelCounts[key])/numEntries\n      shannonEnt -= prob * log(prob, 2)\n    return shannonEnt\n</code></pre>\n<p>然后对于给定的一个数据集（训练数据集，最后一个列为标签），就可以根据特征划分数据，度量划分数据集的熵，以便判断当前是否正确划分了数据集。</p>\n<pre><code class=\"python\">  def splitDataSet(dataSet, axis, value):\n    retDataSet = []\n    for featVec in dataSet:\n      if featVec[axis] == value:\n        reducedFeatVec = featVec[:axis]\n        reducedFeatVec.extend(featVec[axis+1:])\n        retDataSet.append(reducedFeatVec)\n    return retDataSet\n\n  def chooseBestFeatureToSplit(dataSet):\n    numFeatures = len(dataSet[0]) - 1\n    baseEntropy = caclShannonEnt(dataSet)\n    bestInfoGain = 0.0\n    bestFeature = -1\n    for i in range(numFeatures):\n      featList = [example[i] for example in dataSet]\n      uniqueVals = set(featList)\n      newEntropy = 0.0\n      for value in uniqueVals:\n        subDataSet = splitDataSet(dataSet, i, value)\n        prob = len(subDataSet)/float(len(dataSet))\n        newEntropy += prob * caclShannonEnt(subDataSet)\n      infoGain = baseEntropy - newEntropy\n      if (infoGain &gt; bestInfoGain):\n        bestInfoGain = infoGain\n        bestFeature = i\n    return bestFeature\n\n  # 多数表决 ----------------------------------------------------------\n  def majorityCnt(classList):\n    classCount = {}\n    for vote in classList:\n      if vote not in classCount.keys():\n        classCount[vote] = 0\n      classCount[vote] += 1\n    sortedClassCount = sorted(classCount.iteritems(), key = operator.itemgetter(1), reverse = True)\n    return sortedClassCount[0][0]\n\n  # 创建树 ---\n  def createTree(dataSet, labels):\n    classList = [example[-1] for example in dataSet]\n    if classList.count(classList[0]) == len(classList):\n      return classList[0]\n    if len(dataSet[0]) == 1:\n      return majorityCnt(classList)\n    bestFeat = chooseBestFeatureToSplit(dataSet)\n    bestFeatLabel = labels[bestFeat]\n    myTree = {bestFeatLabel:{}}\n    del(labels[bestFeat])\n    featValues = [example[bestFeat] for example in dataSet]\n    uniqueVals = set(featValues)\n    for value in uniqueVals:\n      subLabels = labels[:]\n      myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels)\n    return myTree\n</code></pre>\n<p>以上，就是决策树构建的代码。对于决策树，比较难以理解的是熵的概念。在了解了熵的基础上，决策树的算法逻辑也就比较简单地就写出来了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>从这些简单的算法去入门机器学习，每个阶段让自己有一些产出，既能不断地学习，也能不断激励自己。然后不断补充自己的遗漏的数学知识，再去深入了解更多的机器学习算法。这样一个渐进的过程，对于了解机器学习这样高门槛的技术领域，也不妨是一条可行的道路。</p>\n<p>当然上面使用到了python，对于前端来说，还要学习一下python的基础语法。不过python来说，花一个星期左右的时间去看看文档，基本上也就入门了。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前端与机器学习\"><a href=\"#前端与机器学习\" class=\"headerlink\" title=\"前端与机器学习\"></a>前端与机器学习</h2><p>前端与机器学习，很多时候不会有交集。但是当一个前端要去开发一个机器学习平台的UI时，交集就产生了。对一个前端来说，这是一个挑战，同时也是一个机遇。</p>\n<p>从最开始接触到机器学习平台，面对各种组件、算法不知所措时，然后就疯狂地去看博客了解如何入门机器学习。一般博客会推荐你先学习线性代数、高数、概率论，然后再开始开免费的机器学习视频，推荐的入门书籍。你会发现这是一个门槛很高技术领域。如果从线性代数、高数、概率论学习完，再来了解机器学习，估计得耗费非常大的精力。</p>\n<p>随着几个月的学习，发现有些机器学习的算法只需要简单的数学知识，就能开始入门了。从这些地方作为切入点，显得再好不过。</p>\n<h2 id=\"kNN算法\"><a href=\"#kNN算法\" class=\"headerlink\" title=\"kNN算法\"></a>kNN算法</h2><p>kNN，英文全名 为k-NearestNeighbor，中文叫k-近邻算法。它的工作原理是：存在一个样本数据集合（训练样本集），并且样本集中每个数据都存在标签；输入没有标签的新数据后，将新数据的每个特征与样本集中数据对应的特征进行对比，然后提取出样本集中特征最相似数据的分类标签。一般来说，只选取前k个数据，这就是k-邻近算法的由来。</p>\n<p>假设有这样一组数据：</p>\n<pre><code>data = [\n  [1, 1.1],\n  [1, 1],\n  [0, 0],\n  [0, 0.1]\n]\n// data中每个数据对应的标签\nlables = [&#39;A&#39;, &#39;A&#39;, &#39;B&#39;, &#39;B&#39;]\n</code></pre><p>当我输入数据 [0.2, 0.1]的时候，kNN算法就会判断这个点与哪个点最相近，进而得出输入数据属于哪个标签。<br>那这里涉及到了什么数学知识点呢？这就要提及欧式公式，计算两个向量点xA和xB之间的距离：</p>\n<pre><code>d = √((xA0-xB0)^2+(xA1-xB1)^2) \n</code></pre><p>例如，点(0,0)和(1,2)之间的距离计算为：</p>\n<pre><code>√((1-0)^2+(2-0)^2) // =&gt;√5\n</code></pre><p>当遇到三个或三个以上特征的时候，该公式也适用。</p>\n<p>kNN是一个非常简单的机器学习算法，我们用python实现一下。</p>\n<pre><code class=\"python\">import numpy\ndef classify0(inX, dataSet, labels, k):\n    # 获取训练样本的大小\n    dataSetSize = dataSet.shape[0]\n    # 用样本数据构建和训练数据集一样的数组，再减去训练数据集\n    diffMat = numpy.tile(inX, (dataSetSize, 1)) - dataSet\n    # 下面是应用欧式公式，先平方，再求和，最后开方\n    sqDiffMat = diffMat**2\n    sqDistances = sqDiffMat.sum(axis=1)\n    distances  = sqDistances**0.5\n    # 下面是从欧式公式计算的结果中选取k个最相似的标签\n    sortedDistIndicies = distances.argsort()\n    classCount={}\n    for i in range(k):\n        voteIlabel = labels[sortedDistIndicies[i]]\n        classCount[voteIlabel] = classCount.get(voteIlabel, 0) + 1\n    sortedClassCount = sorted(classCount.items(), key=operator.itemgetter(1),reverse=True)\n    return sortedClassCount[0][0]\n</code></pre>\n<p>kNN是一个非常简单的机器学习算法，对于入门机器学习再合适不过，只需要了解欧式公式即可。然后通过这里还可以补补向量的概念。</p>\n<p>那它在实际应用中，可以应用在相亲网站的条件匹配上，同时也可以识别简单的手写数字等等。反正可以统一输出为数据，然后标签化的数据，都可以应用上它。</p>\n<h2 id=\"decisionTree算法\"><a href=\"#decisionTree算法\" class=\"headerlink\" title=\"decisionTree算法\"></a>decisionTree算法</h2><p>decisionTree，决策树算法。决策树算法，我们举邮件分类的例子来说明最好不过了。假如我们有一堆邮件，那如何将他们自动分类呢？假如邮件中包含”王者荣耀”的关键字自动分类为”无聊时需要阅读的邮件”；如果没有包含，进一步判断邮件中是否包含”工作”的关键字，如果有，自动分类为”需要及时处理的邮件”，否则分类为”无聊时需要阅读的邮件”。以此类推。</p>\n<p>决策树算法里面涉及到的数学概念是”熵”。熵定义为信息的期望值。如果待分类的事务可能分类在多个分类中，则符号Xi的信息定义为:</p>\n<pre><code># P(Xi)为选择该分类的概率\nl(Xi)=-log2P(Xi)\n</code></pre><p>为了计算熵，我们需要计算所有类别所有可能值包含的信息期望值，公式如下：</p>\n<pre><code>H=- SUM1-n (P(Xi) * log2P(Xi))\n</code></pre><p>应用这个公式，我们用python来实现计算熵的。</p>\n<pre><code class=\"python\">def caclShannonEnt (dataSet):\n    numEntries = len(dataSet)\n    # 计算类别\n    labelCounts = {}\n    for featVec in dataSet:\n      currentLabel = featVec[-1]\n      if currentLabel not in labelCounts.keys():\n        labelCounts[currentLabel] = 0\n      labelCounts[currentLabel] += 1\n    # 计算熵\n    shannonEnt = 0.0\n    for key in labelCounts:\n      prob = float(labelCounts[key])/numEntries\n      shannonEnt -= prob * log(prob, 2)\n    return shannonEnt\n</code></pre>\n<p>然后对于给定的一个数据集（训练数据集，最后一个列为标签），就可以根据特征划分数据，度量划分数据集的熵，以便判断当前是否正确划分了数据集。</p>\n<pre><code class=\"python\">  def splitDataSet(dataSet, axis, value):\n    retDataSet = []\n    for featVec in dataSet:\n      if featVec[axis] == value:\n        reducedFeatVec = featVec[:axis]\n        reducedFeatVec.extend(featVec[axis+1:])\n        retDataSet.append(reducedFeatVec)\n    return retDataSet\n\n  def chooseBestFeatureToSplit(dataSet):\n    numFeatures = len(dataSet[0]) - 1\n    baseEntropy = caclShannonEnt(dataSet)\n    bestInfoGain = 0.0\n    bestFeature = -1\n    for i in range(numFeatures):\n      featList = [example[i] for example in dataSet]\n      uniqueVals = set(featList)\n      newEntropy = 0.0\n      for value in uniqueVals:\n        subDataSet = splitDataSet(dataSet, i, value)\n        prob = len(subDataSet)/float(len(dataSet))\n        newEntropy += prob * caclShannonEnt(subDataSet)\n      infoGain = baseEntropy - newEntropy\n      if (infoGain &gt; bestInfoGain):\n        bestInfoGain = infoGain\n        bestFeature = i\n    return bestFeature\n\n  # 多数表决 ----------------------------------------------------------\n  def majorityCnt(classList):\n    classCount = {}\n    for vote in classList:\n      if vote not in classCount.keys():\n        classCount[vote] = 0\n      classCount[vote] += 1\n    sortedClassCount = sorted(classCount.iteritems(), key = operator.itemgetter(1), reverse = True)\n    return sortedClassCount[0][0]\n\n  # 创建树 ---\n  def createTree(dataSet, labels):\n    classList = [example[-1] for example in dataSet]\n    if classList.count(classList[0]) == len(classList):\n      return classList[0]\n    if len(dataSet[0]) == 1:\n      return majorityCnt(classList)\n    bestFeat = chooseBestFeatureToSplit(dataSet)\n    bestFeatLabel = labels[bestFeat]\n    myTree = {bestFeatLabel:{}}\n    del(labels[bestFeat])\n    featValues = [example[bestFeat] for example in dataSet]\n    uniqueVals = set(featValues)\n    for value in uniqueVals:\n      subLabels = labels[:]\n      myTree[bestFeatLabel][value] = createTree(splitDataSet(dataSet, bestFeat, value), subLabels)\n    return myTree\n</code></pre>\n<p>以上，就是决策树构建的代码。对于决策树，比较难以理解的是熵的概念。在了解了熵的基础上，决策树的算法逻辑也就比较简单地就写出来了。</p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>从这些简单的算法去入门机器学习，每个阶段让自己有一些产出，既能不断地学习，也能不断激励自己。然后不断补充自己的遗漏的数学知识，再去深入了解更多的机器学习算法。这样一个渐进的过程，对于了解机器学习这样高门槛的技术领域，也不妨是一条可行的道路。</p>\n<p>当然上面使用到了python，对于前端来说，还要学习一下python的基础语法。不过python来说，花一个星期左右的时间去看看文档，基本上也就入门了。</p>\n"},{"title":"redux(九)-测试","date":"2019-02-11T16:25:08.000Z","_content":"\n测试，目前在我们的开发中并不很受重视。特别是在项目紧张的时候，更是被晾在一边。但是这项技能我们还是得学一学。那么对于redux的测试，我们该如何开展呢？我们都知道，redux有几个重要的概念，分别为action、reducer、store这三个概念。我们可以分别从这几个方面来开展测试。不过，store是将action和reducer联系起来的对象，通过redux提供的createStore()方法创建，我们并不需要编写有关store的实现代码，所以不需要对store编写测试代码。\n\n在工具的选择上，我们选择{% link Jest  https://jestjs.io/docs/en/getting-started %}来作为测试引擎。如果项目中使用来babel，还需要安装babel-jest。\n\n打开命令行工具，进入到项目根目录，输入如下两条命令。\n\n{% codeblock %}\n> npm install -D jest\n> npm install -D babel-jest\n{% endcodeblock %}\n\n接着在package.json文件中添加脚本：\n\n{% codeblock %}\n\"scripts\": {\n    \"test\": \"jest\",\n    \"test:watch\": \"npm run test -- --watch\"\n}\n{% endcodeblock %}\n\n然后运行 npm test 就能单次运行了，或者也可以使用 npm run test:watch 在每次有文件改变时自动执行测试。\n\n为了和项目的实现代码分开，在项目根目录下创建 test 目录，用来编写测试代码。\n\n## 1、action\n\naction是一个函数，会返回一个普通的js对象，所以对于action的测试特别简单，针对它的返回看看是否符合预期即可。\n\n示例action\n\n{% codeblock %}\nexport function addTodo(text) {\n  return { type: 'ADD_TODO', text }\n}\n{% endcodeblock %}\n\n在test目录下创建 actions.test.js 文件来测试addTodo这个action，如下：\n\n{% codeblock %}\ndescribe('test action', () => {\n    it('test addTodo', () => {\n        const text = 'item1'\n        expect(addTodo(text)).toEqual({\n            type: 'ADD_TODO',\n            text,\n        })\n    })\n})\n{% endcodeblock %}\n\n## 2、异步action\n\n对于异步action，可能通过redux-thunk、redux-promise这些中间件来实现。它不再是单纯的函数调用，所以测试用例编写起来就复杂很多。那具体如何实现呢。\n\n首先使用redux-mock-store来模拟redux的store。而在异步action中，我们经常会发送http请求，我们还需要模拟http请求。\n\n### 2.1 redux-mock-store\n\nredux-mock-store可以创建一个mock store，并可像redux一样在创建时添加各种中间件。当使用mock store来dispatch一个异步action时，当这个异步action执行完成后，可用mock store的getActions()方法来获取这个异步action产生的普通action形成的数组，利用这个数组的值，我们就可以进行测试啦。\n\n下来先来编写mockStore的创建代码。\n\n{% codeblock %}\nimport configureStore from 'redux-mock-store'\nimport thunk from 'redux-thunk'\nconst middlewares = [thunk]\nconst mockStore = configureStore(middlewares)\n{% endcodeblock %}\n\n### 2.2 nock\n\nnock是一个模拟http请求并返回值的库。在异步action中经常要配合nock来编写测试代码。其语法如下：\n\n{% codeblock %}\nnock('http://localhost')\n    .get('/getTodos')\n    .reply(200, {\n        body: {\n            todos: [\n                {\n                    text: 'todo-item',\n                    completed: true,\n                },\n            ]\n        }\n    })\n{% endcodeblock %}\n\n当了解了redux-mock-store和nock，就可以来编写异步action的测试代码了。\n\n示例异步action:\n\n{% codeblock %}\nexport function setLoading(loading) {\n  return {\n    type: 'SET_LOADING',\n    loading,\n  }\n}\n\n// 初始化todos\nexport function initTodos(list) {\n  return {\n    type: 'INIT_TODOS',\n    list,\n  }\n}\n\nexport function dispatchInitTodos() {\n  return (dispatch) => {\n    dispatch(setLoading(true))\n    return getTodos().then((data) => {\n      dispatch(initTodos(data.body.todos))\n      dispatch(setLoading(false))\n    }, (err) => {\n      dispatch(setLoading(false))\n    })\n  }\n}\n{% endcodeblock %}\n\n在test目录下创建 asyncActions.test.js文件， 添加测试代码如下：\n\n{% codeblock %}\n\nimport configureStore from 'redux-mock-store'\nimport thunk from 'redux-thunk'\nimport nock from 'nock'\n\nimport { dispatchInitTodos } from '../src/store/actions'\nconst middlewares = [thunk]\nconst mockStore = configureStore(middlewares)\n\ndescribe('async action test', () => {\n    it('test getTodos', () => {\n        nock('http://localhost', {\n            allowUnmocked: true,\n        })\n        .get('/getTodos')\n        .reply(200, {\n            body: {\n                todos: [\n                    {\n                        text: 'todo-item',\n                        completed: true,\n                    },\n                ]\n            }\n        })\n        const actionTypes = [\n            {\n                type: 'SET_LOADING',\n                loading: true,\n            },\n            {\n                type: 'INIT_TODOS',\n                list: [\n                    {\n                        text: 'todo-item',\n                        completed: true,\n                    },\n                ],\n            },\n            {\n                type: 'SET_LOADING',\n                loading: false,\n            }\n        ]\n\n        const store = mockStore({\n            todos: [],\n        })\n\n        return store.dispatch(dispatchInitTodos()).then(() => {\n            const actionsResult = store.getActions()\n            expect(actionsResult).toEqual(actionTypes)\n        })\n    })\n})\n{% endcodeblock %}\n\n## 3、reducers\n\nreducer是一个函数，将action应用在state并返回新的state。我们按照函数调用的方式编写测试用例即可。\n\n示例reducer:\n\n{% codeblock %}\n// 待办事项的过滤条件\nexport function visibilityFilter(state = 'SHOW_ALL', action) {\n    switch (action.type) {\n        case 'SET_VISIBILITY_FILTER':\n            return action.filter\n        default:\n            return state\n    }\n}\n{% endcodeblock %}\n\n在test目录下创建reducers.test.js，添加测试代码如下：\n\n{% codeblock %}\ndescribe('reducers test', () => {\n    it('test visibilityFilter', () => {\n        // 初始值\n        expect(visibilityFilter(undefined, {})).toEqual('SHOW_ALL')\n        // 有action值\n        expect(visibilityFilter(undefined, {\n            type: 'SET_VISIBILITY_FILTER',\n            filter: 'SHOW_ACTIVE'\n        })).toEqual('SHOW_ACTIVE')\n        expect(visibilityFilter(undefined, {\n            type: 'SET_VISIBILITY_FILTER',\n            filter: 'SHOW_COMPLETED'\n        })).toEqual('SHOW_COMPLETED')\n    })\n})\n{% endcodeblock %}","source":"_posts/redux9-test-20190212.md","raw":"---\ntitle: redux(九)-测试\ndate: 2019-02-12 00:25:08\ntags: redux jest react\n---\n\n测试，目前在我们的开发中并不很受重视。特别是在项目紧张的时候，更是被晾在一边。但是这项技能我们还是得学一学。那么对于redux的测试，我们该如何开展呢？我们都知道，redux有几个重要的概念，分别为action、reducer、store这三个概念。我们可以分别从这几个方面来开展测试。不过，store是将action和reducer联系起来的对象，通过redux提供的createStore()方法创建，我们并不需要编写有关store的实现代码，所以不需要对store编写测试代码。\n\n在工具的选择上，我们选择{% link Jest  https://jestjs.io/docs/en/getting-started %}来作为测试引擎。如果项目中使用来babel，还需要安装babel-jest。\n\n打开命令行工具，进入到项目根目录，输入如下两条命令。\n\n{% codeblock %}\n> npm install -D jest\n> npm install -D babel-jest\n{% endcodeblock %}\n\n接着在package.json文件中添加脚本：\n\n{% codeblock %}\n\"scripts\": {\n    \"test\": \"jest\",\n    \"test:watch\": \"npm run test -- --watch\"\n}\n{% endcodeblock %}\n\n然后运行 npm test 就能单次运行了，或者也可以使用 npm run test:watch 在每次有文件改变时自动执行测试。\n\n为了和项目的实现代码分开，在项目根目录下创建 test 目录，用来编写测试代码。\n\n## 1、action\n\naction是一个函数，会返回一个普通的js对象，所以对于action的测试特别简单，针对它的返回看看是否符合预期即可。\n\n示例action\n\n{% codeblock %}\nexport function addTodo(text) {\n  return { type: 'ADD_TODO', text }\n}\n{% endcodeblock %}\n\n在test目录下创建 actions.test.js 文件来测试addTodo这个action，如下：\n\n{% codeblock %}\ndescribe('test action', () => {\n    it('test addTodo', () => {\n        const text = 'item1'\n        expect(addTodo(text)).toEqual({\n            type: 'ADD_TODO',\n            text,\n        })\n    })\n})\n{% endcodeblock %}\n\n## 2、异步action\n\n对于异步action，可能通过redux-thunk、redux-promise这些中间件来实现。它不再是单纯的函数调用，所以测试用例编写起来就复杂很多。那具体如何实现呢。\n\n首先使用redux-mock-store来模拟redux的store。而在异步action中，我们经常会发送http请求，我们还需要模拟http请求。\n\n### 2.1 redux-mock-store\n\nredux-mock-store可以创建一个mock store，并可像redux一样在创建时添加各种中间件。当使用mock store来dispatch一个异步action时，当这个异步action执行完成后，可用mock store的getActions()方法来获取这个异步action产生的普通action形成的数组，利用这个数组的值，我们就可以进行测试啦。\n\n下来先来编写mockStore的创建代码。\n\n{% codeblock %}\nimport configureStore from 'redux-mock-store'\nimport thunk from 'redux-thunk'\nconst middlewares = [thunk]\nconst mockStore = configureStore(middlewares)\n{% endcodeblock %}\n\n### 2.2 nock\n\nnock是一个模拟http请求并返回值的库。在异步action中经常要配合nock来编写测试代码。其语法如下：\n\n{% codeblock %}\nnock('http://localhost')\n    .get('/getTodos')\n    .reply(200, {\n        body: {\n            todos: [\n                {\n                    text: 'todo-item',\n                    completed: true,\n                },\n            ]\n        }\n    })\n{% endcodeblock %}\n\n当了解了redux-mock-store和nock，就可以来编写异步action的测试代码了。\n\n示例异步action:\n\n{% codeblock %}\nexport function setLoading(loading) {\n  return {\n    type: 'SET_LOADING',\n    loading,\n  }\n}\n\n// 初始化todos\nexport function initTodos(list) {\n  return {\n    type: 'INIT_TODOS',\n    list,\n  }\n}\n\nexport function dispatchInitTodos() {\n  return (dispatch) => {\n    dispatch(setLoading(true))\n    return getTodos().then((data) => {\n      dispatch(initTodos(data.body.todos))\n      dispatch(setLoading(false))\n    }, (err) => {\n      dispatch(setLoading(false))\n    })\n  }\n}\n{% endcodeblock %}\n\n在test目录下创建 asyncActions.test.js文件， 添加测试代码如下：\n\n{% codeblock %}\n\nimport configureStore from 'redux-mock-store'\nimport thunk from 'redux-thunk'\nimport nock from 'nock'\n\nimport { dispatchInitTodos } from '../src/store/actions'\nconst middlewares = [thunk]\nconst mockStore = configureStore(middlewares)\n\ndescribe('async action test', () => {\n    it('test getTodos', () => {\n        nock('http://localhost', {\n            allowUnmocked: true,\n        })\n        .get('/getTodos')\n        .reply(200, {\n            body: {\n                todos: [\n                    {\n                        text: 'todo-item',\n                        completed: true,\n                    },\n                ]\n            }\n        })\n        const actionTypes = [\n            {\n                type: 'SET_LOADING',\n                loading: true,\n            },\n            {\n                type: 'INIT_TODOS',\n                list: [\n                    {\n                        text: 'todo-item',\n                        completed: true,\n                    },\n                ],\n            },\n            {\n                type: 'SET_LOADING',\n                loading: false,\n            }\n        ]\n\n        const store = mockStore({\n            todos: [],\n        })\n\n        return store.dispatch(dispatchInitTodos()).then(() => {\n            const actionsResult = store.getActions()\n            expect(actionsResult).toEqual(actionTypes)\n        })\n    })\n})\n{% endcodeblock %}\n\n## 3、reducers\n\nreducer是一个函数，将action应用在state并返回新的state。我们按照函数调用的方式编写测试用例即可。\n\n示例reducer:\n\n{% codeblock %}\n// 待办事项的过滤条件\nexport function visibilityFilter(state = 'SHOW_ALL', action) {\n    switch (action.type) {\n        case 'SET_VISIBILITY_FILTER':\n            return action.filter\n        default:\n            return state\n    }\n}\n{% endcodeblock %}\n\n在test目录下创建reducers.test.js，添加测试代码如下：\n\n{% codeblock %}\ndescribe('reducers test', () => {\n    it('test visibilityFilter', () => {\n        // 初始值\n        expect(visibilityFilter(undefined, {})).toEqual('SHOW_ALL')\n        // 有action值\n        expect(visibilityFilter(undefined, {\n            type: 'SET_VISIBILITY_FILTER',\n            filter: 'SHOW_ACTIVE'\n        })).toEqual('SHOW_ACTIVE')\n        expect(visibilityFilter(undefined, {\n            type: 'SET_VISIBILITY_FILTER',\n            filter: 'SHOW_COMPLETED'\n        })).toEqual('SHOW_COMPLETED')\n    })\n})\n{% endcodeblock %}","slug":"redux9-test","published":1,"updated":"2019-02-18T05:20:31.803Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvopp00124c41m1acbbj9","content":"<p>测试，目前在我们的开发中并不很受重视。特别是在项目紧张的时候，更是被晾在一边。但是这项技能我们还是得学一学。那么对于redux的测试，我们该如何开展呢？我们都知道，redux有几个重要的概念，分别为action、reducer、store这三个概念。我们可以分别从这几个方面来开展测试。不过，store是将action和reducer联系起来的对象，通过redux提供的createStore()方法创建，我们并不需要编写有关store的实现代码，所以不需要对store编写测试代码。</p>\n<p>在工具的选择上，我们选择<a href=\"https://jestjs.io/docs/en/getting-started\" target=\"_blank\" rel=\"noopener\">Jest</a>来作为测试引擎。如果项目中使用来babel，还需要安装babel-jest。</p>\n<p>打开命令行工具，进入到项目根目录，输入如下两条命令。</p>\n<pre><code>&gt; npm install -D jest\n&gt; npm install -D babel-jest</code></pre>\n<p>接着在package.json文件中添加脚本：</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;test&quot;: &quot;jest&quot;,\n    &quot;test:watch&quot;: &quot;npm run test -- --watch&quot;\n}</code></pre>\n<p>然后运行 npm test 就能单次运行了，或者也可以使用 npm run test:watch 在每次有文件改变时自动执行测试。</p>\n<p>为了和项目的实现代码分开，在项目根目录下创建 test 目录，用来编写测试代码。</p>\n<h2 id=\"1、action\"><a href=\"#1、action\" class=\"headerlink\" title=\"1、action\"></a>1、action</h2><p>action是一个函数，会返回一个普通的js对象，所以对于action的测试特别简单，针对它的返回看看是否符合预期即可。</p>\n<p>示例action</p>\n<pre><code>export function addTodo(text) {\n  return { type: &#39;ADD_TODO&#39;, text }\n}</code></pre>\n<p>在test目录下创建 actions.test.js 文件来测试addTodo这个action，如下：</p>\n<pre><code>describe(&#39;test action&#39;, () =&gt; {\n    it(&#39;test addTodo&#39;, () =&gt; {\n        const text = &#39;item1&#39;\n        expect(addTodo(text)).toEqual({\n            type: &#39;ADD_TODO&#39;,\n            text,\n        })\n    })\n})</code></pre>\n<h2 id=\"2、异步action\"><a href=\"#2、异步action\" class=\"headerlink\" title=\"2、异步action\"></a>2、异步action</h2><p>对于异步action，可能通过redux-thunk、redux-promise这些中间件来实现。它不再是单纯的函数调用，所以测试用例编写起来就复杂很多。那具体如何实现呢。</p>\n<p>首先使用redux-mock-store来模拟redux的store。而在异步action中，我们经常会发送http请求，我们还需要模拟http请求。</p>\n<h3 id=\"2-1-redux-mock-store\"><a href=\"#2-1-redux-mock-store\" class=\"headerlink\" title=\"2.1 redux-mock-store\"></a>2.1 redux-mock-store</h3><p>redux-mock-store可以创建一个mock store，并可像redux一样在创建时添加各种中间件。当使用mock store来dispatch一个异步action时，当这个异步action执行完成后，可用mock store的getActions()方法来获取这个异步action产生的普通action形成的数组，利用这个数组的值，我们就可以进行测试啦。</p>\n<p>下来先来编写mockStore的创建代码。</p>\n<pre><code>import configureStore from &#39;redux-mock-store&#39;\nimport thunk from &#39;redux-thunk&#39;\nconst middlewares = [thunk]\nconst mockStore = configureStore(middlewares)</code></pre>\n<h3 id=\"2-2-nock\"><a href=\"#2-2-nock\" class=\"headerlink\" title=\"2.2 nock\"></a>2.2 nock</h3><p>nock是一个模拟http请求并返回值的库。在异步action中经常要配合nock来编写测试代码。其语法如下：</p>\n<pre><code>nock(&#39;http:&#x2F;&#x2F;localhost&#39;)\n    .get(&#39;&#x2F;getTodos&#39;)\n    .reply(200, {\n        body: {\n            todos: [\n                {\n                    text: &#39;todo-item&#39;,\n                    completed: true,\n                },\n            ]\n        }\n    })</code></pre>\n<p>当了解了redux-mock-store和nock，就可以来编写异步action的测试代码了。</p>\n<p>示例异步action:</p>\n<pre><code>export function setLoading(loading) {\n  return {\n    type: &#39;SET_LOADING&#39;,\n    loading,\n  }\n}\n\n&#x2F;&#x2F; 初始化todos\nexport function initTodos(list) {\n  return {\n    type: &#39;INIT_TODOS&#39;,\n    list,\n  }\n}\n\nexport function dispatchInitTodos() {\n  return (dispatch) =&gt; {\n    dispatch(setLoading(true))\n    return getTodos().then((data) =&gt; {\n      dispatch(initTodos(data.body.todos))\n      dispatch(setLoading(false))\n    }, (err) =&gt; {\n      dispatch(setLoading(false))\n    })\n  }\n}</code></pre>\n<p>在test目录下创建 asyncActions.test.js文件， 添加测试代码如下：</p>\n<pre><code>\nimport configureStore from &#39;redux-mock-store&#39;\nimport thunk from &#39;redux-thunk&#39;\nimport nock from &#39;nock&#39;\n\nimport { dispatchInitTodos } from &#39;..&#x2F;src&#x2F;store&#x2F;actions&#39;\nconst middlewares = [thunk]\nconst mockStore = configureStore(middlewares)\n\ndescribe(&#39;async action test&#39;, () =&gt; {\n    it(&#39;test getTodos&#39;, () =&gt; {\n        nock(&#39;http:&#x2F;&#x2F;localhost&#39;, {\n            allowUnmocked: true,\n        })\n        .get(&#39;&#x2F;getTodos&#39;)\n        .reply(200, {\n            body: {\n                todos: [\n                    {\n                        text: &#39;todo-item&#39;,\n                        completed: true,\n                    },\n                ]\n            }\n        })\n        const actionTypes = [\n            {\n                type: &#39;SET_LOADING&#39;,\n                loading: true,\n            },\n            {\n                type: &#39;INIT_TODOS&#39;,\n                list: [\n                    {\n                        text: &#39;todo-item&#39;,\n                        completed: true,\n                    },\n                ],\n            },\n            {\n                type: &#39;SET_LOADING&#39;,\n                loading: false,\n            }\n        ]\n\n        const store = mockStore({\n            todos: [],\n        })\n\n        return store.dispatch(dispatchInitTodos()).then(() =&gt; {\n            const actionsResult = store.getActions()\n            expect(actionsResult).toEqual(actionTypes)\n        })\n    })\n})</code></pre>\n<h2 id=\"3、reducers\"><a href=\"#3、reducers\" class=\"headerlink\" title=\"3、reducers\"></a>3、reducers</h2><p>reducer是一个函数，将action应用在state并返回新的state。我们按照函数调用的方式编写测试用例即可。</p>\n<p>示例reducer:</p>\n<pre><code>&#x2F;&#x2F; 待办事项的过滤条件\nexport function visibilityFilter(state = &#39;SHOW_ALL&#39;, action) {\n    switch (action.type) {\n        case &#39;SET_VISIBILITY_FILTER&#39;:\n            return action.filter\n        default:\n            return state\n    }\n}</code></pre>\n<p>在test目录下创建reducers.test.js，添加测试代码如下：</p>\n<pre><code>describe(&#39;reducers test&#39;, () =&gt; {\n    it(&#39;test visibilityFilter&#39;, () =&gt; {\n        &#x2F;&#x2F; 初始值\n        expect(visibilityFilter(undefined, {})).toEqual(&#39;SHOW_ALL&#39;)\n        &#x2F;&#x2F; 有action值\n        expect(visibilityFilter(undefined, {\n            type: &#39;SET_VISIBILITY_FILTER&#39;,\n            filter: &#39;SHOW_ACTIVE&#39;\n        })).toEqual(&#39;SHOW_ACTIVE&#39;)\n        expect(visibilityFilter(undefined, {\n            type: &#39;SET_VISIBILITY_FILTER&#39;,\n            filter: &#39;SHOW_COMPLETED&#39;\n        })).toEqual(&#39;SHOW_COMPLETED&#39;)\n    })\n})</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>测试，目前在我们的开发中并不很受重视。特别是在项目紧张的时候，更是被晾在一边。但是这项技能我们还是得学一学。那么对于redux的测试，我们该如何开展呢？我们都知道，redux有几个重要的概念，分别为action、reducer、store这三个概念。我们可以分别从这几个方面来开展测试。不过，store是将action和reducer联系起来的对象，通过redux提供的createStore()方法创建，我们并不需要编写有关store的实现代码，所以不需要对store编写测试代码。</p>\n<p>在工具的选择上，我们选择<a href=\"https://jestjs.io/docs/en/getting-started\" target=\"_blank\" rel=\"noopener\">Jest</a>来作为测试引擎。如果项目中使用来babel，还需要安装babel-jest。</p>\n<p>打开命令行工具，进入到项目根目录，输入如下两条命令。</p>\n<pre><code>&gt; npm install -D jest\n&gt; npm install -D babel-jest</code></pre>\n<p>接着在package.json文件中添加脚本：</p>\n<pre><code>&quot;scripts&quot;: {\n    &quot;test&quot;: &quot;jest&quot;,\n    &quot;test:watch&quot;: &quot;npm run test -- --watch&quot;\n}</code></pre>\n<p>然后运行 npm test 就能单次运行了，或者也可以使用 npm run test:watch 在每次有文件改变时自动执行测试。</p>\n<p>为了和项目的实现代码分开，在项目根目录下创建 test 目录，用来编写测试代码。</p>\n<h2 id=\"1、action\"><a href=\"#1、action\" class=\"headerlink\" title=\"1、action\"></a>1、action</h2><p>action是一个函数，会返回一个普通的js对象，所以对于action的测试特别简单，针对它的返回看看是否符合预期即可。</p>\n<p>示例action</p>\n<pre><code>export function addTodo(text) {\n  return { type: &#39;ADD_TODO&#39;, text }\n}</code></pre>\n<p>在test目录下创建 actions.test.js 文件来测试addTodo这个action，如下：</p>\n<pre><code>describe(&#39;test action&#39;, () =&gt; {\n    it(&#39;test addTodo&#39;, () =&gt; {\n        const text = &#39;item1&#39;\n        expect(addTodo(text)).toEqual({\n            type: &#39;ADD_TODO&#39;,\n            text,\n        })\n    })\n})</code></pre>\n<h2 id=\"2、异步action\"><a href=\"#2、异步action\" class=\"headerlink\" title=\"2、异步action\"></a>2、异步action</h2><p>对于异步action，可能通过redux-thunk、redux-promise这些中间件来实现。它不再是单纯的函数调用，所以测试用例编写起来就复杂很多。那具体如何实现呢。</p>\n<p>首先使用redux-mock-store来模拟redux的store。而在异步action中，我们经常会发送http请求，我们还需要模拟http请求。</p>\n<h3 id=\"2-1-redux-mock-store\"><a href=\"#2-1-redux-mock-store\" class=\"headerlink\" title=\"2.1 redux-mock-store\"></a>2.1 redux-mock-store</h3><p>redux-mock-store可以创建一个mock store，并可像redux一样在创建时添加各种中间件。当使用mock store来dispatch一个异步action时，当这个异步action执行完成后，可用mock store的getActions()方法来获取这个异步action产生的普通action形成的数组，利用这个数组的值，我们就可以进行测试啦。</p>\n<p>下来先来编写mockStore的创建代码。</p>\n<pre><code>import configureStore from &#39;redux-mock-store&#39;\nimport thunk from &#39;redux-thunk&#39;\nconst middlewares = [thunk]\nconst mockStore = configureStore(middlewares)</code></pre>\n<h3 id=\"2-2-nock\"><a href=\"#2-2-nock\" class=\"headerlink\" title=\"2.2 nock\"></a>2.2 nock</h3><p>nock是一个模拟http请求并返回值的库。在异步action中经常要配合nock来编写测试代码。其语法如下：</p>\n<pre><code>nock(&#39;http:&#x2F;&#x2F;localhost&#39;)\n    .get(&#39;&#x2F;getTodos&#39;)\n    .reply(200, {\n        body: {\n            todos: [\n                {\n                    text: &#39;todo-item&#39;,\n                    completed: true,\n                },\n            ]\n        }\n    })</code></pre>\n<p>当了解了redux-mock-store和nock，就可以来编写异步action的测试代码了。</p>\n<p>示例异步action:</p>\n<pre><code>export function setLoading(loading) {\n  return {\n    type: &#39;SET_LOADING&#39;,\n    loading,\n  }\n}\n\n&#x2F;&#x2F; 初始化todos\nexport function initTodos(list) {\n  return {\n    type: &#39;INIT_TODOS&#39;,\n    list,\n  }\n}\n\nexport function dispatchInitTodos() {\n  return (dispatch) =&gt; {\n    dispatch(setLoading(true))\n    return getTodos().then((data) =&gt; {\n      dispatch(initTodos(data.body.todos))\n      dispatch(setLoading(false))\n    }, (err) =&gt; {\n      dispatch(setLoading(false))\n    })\n  }\n}</code></pre>\n<p>在test目录下创建 asyncActions.test.js文件， 添加测试代码如下：</p>\n<pre><code>\nimport configureStore from &#39;redux-mock-store&#39;\nimport thunk from &#39;redux-thunk&#39;\nimport nock from &#39;nock&#39;\n\nimport { dispatchInitTodos } from &#39;..&#x2F;src&#x2F;store&#x2F;actions&#39;\nconst middlewares = [thunk]\nconst mockStore = configureStore(middlewares)\n\ndescribe(&#39;async action test&#39;, () =&gt; {\n    it(&#39;test getTodos&#39;, () =&gt; {\n        nock(&#39;http:&#x2F;&#x2F;localhost&#39;, {\n            allowUnmocked: true,\n        })\n        .get(&#39;&#x2F;getTodos&#39;)\n        .reply(200, {\n            body: {\n                todos: [\n                    {\n                        text: &#39;todo-item&#39;,\n                        completed: true,\n                    },\n                ]\n            }\n        })\n        const actionTypes = [\n            {\n                type: &#39;SET_LOADING&#39;,\n                loading: true,\n            },\n            {\n                type: &#39;INIT_TODOS&#39;,\n                list: [\n                    {\n                        text: &#39;todo-item&#39;,\n                        completed: true,\n                    },\n                ],\n            },\n            {\n                type: &#39;SET_LOADING&#39;,\n                loading: false,\n            }\n        ]\n\n        const store = mockStore({\n            todos: [],\n        })\n\n        return store.dispatch(dispatchInitTodos()).then(() =&gt; {\n            const actionsResult = store.getActions()\n            expect(actionsResult).toEqual(actionTypes)\n        })\n    })\n})</code></pre>\n<h2 id=\"3、reducers\"><a href=\"#3、reducers\" class=\"headerlink\" title=\"3、reducers\"></a>3、reducers</h2><p>reducer是一个函数，将action应用在state并返回新的state。我们按照函数调用的方式编写测试用例即可。</p>\n<p>示例reducer:</p>\n<pre><code>&#x2F;&#x2F; 待办事项的过滤条件\nexport function visibilityFilter(state = &#39;SHOW_ALL&#39;, action) {\n    switch (action.type) {\n        case &#39;SET_VISIBILITY_FILTER&#39;:\n            return action.filter\n        default:\n            return state\n    }\n}</code></pre>\n<p>在test目录下创建reducers.test.js，添加测试代码如下：</p>\n<pre><code>describe(&#39;reducers test&#39;, () =&gt; {\n    it(&#39;test visibilityFilter&#39;, () =&gt; {\n        &#x2F;&#x2F; 初始值\n        expect(visibilityFilter(undefined, {})).toEqual(&#39;SHOW_ALL&#39;)\n        &#x2F;&#x2F; 有action值\n        expect(visibilityFilter(undefined, {\n            type: &#39;SET_VISIBILITY_FILTER&#39;,\n            filter: &#39;SHOW_ACTIVE&#39;\n        })).toEqual(&#39;SHOW_ACTIVE&#39;)\n        expect(visibilityFilter(undefined, {\n            type: &#39;SET_VISIBILITY_FILTER&#39;,\n            filter: &#39;SHOW_COMPLETED&#39;\n        })).toEqual(&#39;SHOW_COMPLETED&#39;)\n    })\n})</code></pre>"},{"title":"redux(一)-初识redux","date":"2018-12-01T06:29:09.000Z","_content":"\nredux是一个状态管理库。核心概念，包括：action、reducer和store。\n\n1. action： 是把数据从应用传到store的有效载荷。\n2. reducer: 指定了应用状态的变化如何相应action，并发送到store。\n3. store: 把action和reducer联系到一起的对象。\n\n但是单单了解这三个概念和它们的内在联系还是不足够的。我们还需要了解state的由来，以及如何获取state、更新state；state和store又是什么区别。\n\n下面，我们一步一步来深入学习这三个概念。\n\n{% blockquote %}\n在文章中，我们会以\"待办事项\"为例子展开讲解redux。待办事项的需求如下：\n1. 一个待办事项的列表(用todos数组存储)\n   todos数组中的元素为待办事项内容，包含两个字段:\n   {% codeblock %}\n   {\n       text: '待办事项1', // string\n       completed: false,// boolean 是否完成的状态\n   }\n   {% endcodeblock %}\n2. 一个过滤条件filter，filter是一个字符串，标明目前需要将哪些待办事项展现出来\n   {% codeblock %}\n    SHOW_ALL: 展示全部待办事项\n    SHOW_COMPLETED: 展示已完成的待办事项\n    SHOW_ACTIVE: 展示未完成的待办事项\n   {% endcodeblock %}\n{% endblockquote %}\n\n## 1、 Action\n\nAction 是把数据从应用传到store的有效载荷。Action本质上是一个普通的javascript对象。Action有一个约定，它必须包含 **\"type\"** 属性。\n\n{% codeblock %}\n{\n    type: 'ADD_TODO',\n    text: 'something',\n}\n{% endcodeblock %}\n\n在实际应用中，我们会编写生成Action的方法，即 *Action* 创建函数，方便传递Action。\n\n{% codeblock %}\n// actions.js\n// 添加待办事项\nexport function addTodo(text) {\n  return { type: 'ADD_TODO', text }\n}\n// 对index对应待办事项的状态进行取反操作\nexport function toggleTodo(index) {\n  return { type: 'TOGGLE_TODO', index }\n}\n// 更改过滤条件\nexport function setVisibilityFilter(filter) {\n  return { type: 'SET_VISIBILITY_FILTER', filter }\n}\n{% endcodeblock %}\n\n在actions.js中，定义了三个Action创建函数，addTodo将待办事项添加到应用状态中，toggleTodo函数会更改index对应的事项的状态（未完成／已完成），setVisibilityFilter设置过滤条件。\n\n## 2、 Reducer\n\nreducer会响应接收到的action，然后改变对应的应用状态。reducer实际上是一个函数，这个函数包含两个参数，第一个参数为state，第二个参数为action。\n\n{% codeblock %}\n// reducers.js\n// 待办事项的过滤条件\nfunction visibilityFilter(state = 'SHOW_ALL', action) {\n  switch (action.type) {\n    case 'SET_VISIBILITY_FILTER':\n      return action.filter\n    default:\n      return state\n  }\n}\n{% endcodeblock %}\n\n在这里，参数state=[]的写法为es6语法，表明将state初始化为一个空数组。reducer的返回值组成了应用的状态（即\"总state\",下面写到\"应用的状态\"的时候指的就是\"总state\"）。每一次调用reducer，参数state(即\"子state\"，\"子state\"构成了\"总state\")的值为对应reducer对应状态的上一个值，该reducer的返回值又将更新到应用的状态中。如果是第一次调用reducer，参数state则为初始值。参数action则是上面介绍的一个带有type属性的普通javascript对象。\n\n我们来细看visibilityFilter函数的逻辑，它使用switch语句，根据action.type来区分处理不同的action。如果action.type等于'SET_VISIBILITY_FILTER',它将action.filter返回，作为这个\"子state\"的新值；如果action.type不等于'SET_VISIBILITY_FILTER'，则将state原样返回，不做处理。\n\n如果仅有一个reducer，那么这个reducer的返回值就是应用的状态。不过在一般的应用中，为了便于阅读和维护，都会有多个reducer。然后再通过redux提供的全局方法 combineReducers 将reducer组合起来，构成最终的应用状态。combineReducers函数接收一个Object对象参数，该对象的key值可以设置任意多个，key值对应的value值为一个reducer。\n\n{% codeblock %}\n// reducers.js\nimport { combineReducers } from 'redux'\n// 待办事项的过滤条件\nfunction visibilityFilter(state = 'SHOW_ALL', action) {\n    switch (action.type) {\n      case 'SET_VISIBILITY_FILTER':\n        return action.filter\n      default:\n        return state\n    }\n  }\n  // 待办事项列表reducer\n  function todos(state = [], action) {\n      switch (action.type) {\n          // 添加待办事项\n          case 'ADD_TODO':\n              return [...state, {\n                  text: action.text,\n                  completed: false,\n              }]\n          break\n          // 对index对应待办事项的状态进行取反操作\n          case 'TOGGLE_TODO':\n              const data = state.map((todo, index) => {\n                  return {\n                      ...todo,\n                      completed: index === action.index ? !todo.completed : todo.completed\n                  }\n              })\n              return data\n          break\n          default:\n              return state\n      }\n  }\n  \n  const rootReducer = combineReducers({\n      visibilityFilter,\n      todos\n  })\n  \n  export default rootReducer\n{% endcodeblock %}\n\nreducers.js中，最终导出的是一个合并的reducer(rootReducer)。rootReducer最终的结构(即应用状态的结构)如下：\n\n{% codeblock %}\n{\n    visibilityFilter: 'SHOW_ALL',\n    todos: [],\n}\n{% endcodeblock %}\n\n应用状态由reducers的返回值构成，但是在代码中我们不会直观地看到上面这个结构。这个结构需要我们结合各个reducer，根据它的第一个参数state或者返回值分析出来。在我们学习更高级框架(如dva)的时候，会看到如果应用的状态能够直接配置，那么我们对应用状态的维护将会变得更加简便和直观。\n\nreducer的触发时机，就是当使用redux提供的dispatch方法派发一个action时触发。但是dispatch方法不是redux的全局方法，它是store实例的方法，接下来我们就介绍store。\n\n## 3、 Store\n\nstore是把action和reducer联系到一起的对象。这里我们要注意和state区别开来，state由reducer的返回值组成，是整个应用的状态。store则是由redux提供的createStore方法创建的一个实例，createStore的参数就是reducers。\n\n{% codeblock %}\n// index.js\nimport { createStore } from 'redux'\nimport rootReducer from './reducers.js'\nconst store = createStore(rootReducer)\n{% endcodeblock %}\n\nstore创建之后，获取应用状态信息、更新应用状态等操作都是通过store实例的方法来实现。\n\n1. 获取应用状态：提供 getState() 方法获取 state；\n2. 更新应用状态：提供 dispatch(action) 方法更新 state；\n3. 订阅：通过 subscribe(listener) 注册监听器。\n\n以上，便介绍完了redux的几个重要概念。接下来，我们来验证一下。redux是一个状态管理库，它本身是不涉及UI，所以验证工作我们就通过console.log方法打印出state来验证。这可以通过subscribe方法来实现，当state方法变化时，subscribe方法的回调函数参数就会被调用。\n\n在index.js中补充验证代码，如下：\n\n{% codeblock %}\n// index.js\nimport { createStore } from 'redux'\nimport { addTodo, toggleTodo, setVisibilityFilter } from './actions.js'\nimport rootReducer from './reducers.js'\nconst store = createStore(rootReducer)\n\n// 验证\nstore.subscribe(() => {\n    console.log(store.getState())\n})\n// 打印初始状态\nconsole.log('初始状态', store.getState())\n\nstore.dispatch(addTodo('Learn Action'))\nstore.dispatch(addTodo('Learn reducer'))\nstore.dispatch(addTodo('Learn state'))\nstore.dispatch(addTodo('Learn store'))\nstore.dispatch(toggleTodo(0))\nstore.dispatch(toggleTodo(1))\nstore.dispatch(setVisibilityFilter('SHOW_COMPLETED'))\n\n{% endcodeblock %}\n\n## 4、把代码跑起来\n\n上面的样例代码包含3个文件: actions.js、reducers.js以及index.js。样例代码依赖于redux npm包，并使用了一些es6语法，想要把代码跑起来，我们使用webpack对这几个文件进行打包处理，让它成为浏览器可加载解析的文件。具体请参考{% link redux-01 https://github.com/Two-Ftry/react-essay/tree/master/redux-01 %}，里面对构建步骤进行了详细的说明。\n\n\n![result](result-20181213.png)","source":"_posts/redux.md","raw":"---\ntitle: redux(一)-初识redux\ndate: 2018-12-01 14:29:09\ncategories: \n- redux\ntags: \n- redux\n---\n\nredux是一个状态管理库。核心概念，包括：action、reducer和store。\n\n1. action： 是把数据从应用传到store的有效载荷。\n2. reducer: 指定了应用状态的变化如何相应action，并发送到store。\n3. store: 把action和reducer联系到一起的对象。\n\n但是单单了解这三个概念和它们的内在联系还是不足够的。我们还需要了解state的由来，以及如何获取state、更新state；state和store又是什么区别。\n\n下面，我们一步一步来深入学习这三个概念。\n\n{% blockquote %}\n在文章中，我们会以\"待办事项\"为例子展开讲解redux。待办事项的需求如下：\n1. 一个待办事项的列表(用todos数组存储)\n   todos数组中的元素为待办事项内容，包含两个字段:\n   {% codeblock %}\n   {\n       text: '待办事项1', // string\n       completed: false,// boolean 是否完成的状态\n   }\n   {% endcodeblock %}\n2. 一个过滤条件filter，filter是一个字符串，标明目前需要将哪些待办事项展现出来\n   {% codeblock %}\n    SHOW_ALL: 展示全部待办事项\n    SHOW_COMPLETED: 展示已完成的待办事项\n    SHOW_ACTIVE: 展示未完成的待办事项\n   {% endcodeblock %}\n{% endblockquote %}\n\n## 1、 Action\n\nAction 是把数据从应用传到store的有效载荷。Action本质上是一个普通的javascript对象。Action有一个约定，它必须包含 **\"type\"** 属性。\n\n{% codeblock %}\n{\n    type: 'ADD_TODO',\n    text: 'something',\n}\n{% endcodeblock %}\n\n在实际应用中，我们会编写生成Action的方法，即 *Action* 创建函数，方便传递Action。\n\n{% codeblock %}\n// actions.js\n// 添加待办事项\nexport function addTodo(text) {\n  return { type: 'ADD_TODO', text }\n}\n// 对index对应待办事项的状态进行取反操作\nexport function toggleTodo(index) {\n  return { type: 'TOGGLE_TODO', index }\n}\n// 更改过滤条件\nexport function setVisibilityFilter(filter) {\n  return { type: 'SET_VISIBILITY_FILTER', filter }\n}\n{% endcodeblock %}\n\n在actions.js中，定义了三个Action创建函数，addTodo将待办事项添加到应用状态中，toggleTodo函数会更改index对应的事项的状态（未完成／已完成），setVisibilityFilter设置过滤条件。\n\n## 2、 Reducer\n\nreducer会响应接收到的action，然后改变对应的应用状态。reducer实际上是一个函数，这个函数包含两个参数，第一个参数为state，第二个参数为action。\n\n{% codeblock %}\n// reducers.js\n// 待办事项的过滤条件\nfunction visibilityFilter(state = 'SHOW_ALL', action) {\n  switch (action.type) {\n    case 'SET_VISIBILITY_FILTER':\n      return action.filter\n    default:\n      return state\n  }\n}\n{% endcodeblock %}\n\n在这里，参数state=[]的写法为es6语法，表明将state初始化为一个空数组。reducer的返回值组成了应用的状态（即\"总state\",下面写到\"应用的状态\"的时候指的就是\"总state\"）。每一次调用reducer，参数state(即\"子state\"，\"子state\"构成了\"总state\")的值为对应reducer对应状态的上一个值，该reducer的返回值又将更新到应用的状态中。如果是第一次调用reducer，参数state则为初始值。参数action则是上面介绍的一个带有type属性的普通javascript对象。\n\n我们来细看visibilityFilter函数的逻辑，它使用switch语句，根据action.type来区分处理不同的action。如果action.type等于'SET_VISIBILITY_FILTER',它将action.filter返回，作为这个\"子state\"的新值；如果action.type不等于'SET_VISIBILITY_FILTER'，则将state原样返回，不做处理。\n\n如果仅有一个reducer，那么这个reducer的返回值就是应用的状态。不过在一般的应用中，为了便于阅读和维护，都会有多个reducer。然后再通过redux提供的全局方法 combineReducers 将reducer组合起来，构成最终的应用状态。combineReducers函数接收一个Object对象参数，该对象的key值可以设置任意多个，key值对应的value值为一个reducer。\n\n{% codeblock %}\n// reducers.js\nimport { combineReducers } from 'redux'\n// 待办事项的过滤条件\nfunction visibilityFilter(state = 'SHOW_ALL', action) {\n    switch (action.type) {\n      case 'SET_VISIBILITY_FILTER':\n        return action.filter\n      default:\n        return state\n    }\n  }\n  // 待办事项列表reducer\n  function todos(state = [], action) {\n      switch (action.type) {\n          // 添加待办事项\n          case 'ADD_TODO':\n              return [...state, {\n                  text: action.text,\n                  completed: false,\n              }]\n          break\n          // 对index对应待办事项的状态进行取反操作\n          case 'TOGGLE_TODO':\n              const data = state.map((todo, index) => {\n                  return {\n                      ...todo,\n                      completed: index === action.index ? !todo.completed : todo.completed\n                  }\n              })\n              return data\n          break\n          default:\n              return state\n      }\n  }\n  \n  const rootReducer = combineReducers({\n      visibilityFilter,\n      todos\n  })\n  \n  export default rootReducer\n{% endcodeblock %}\n\nreducers.js中，最终导出的是一个合并的reducer(rootReducer)。rootReducer最终的结构(即应用状态的结构)如下：\n\n{% codeblock %}\n{\n    visibilityFilter: 'SHOW_ALL',\n    todos: [],\n}\n{% endcodeblock %}\n\n应用状态由reducers的返回值构成，但是在代码中我们不会直观地看到上面这个结构。这个结构需要我们结合各个reducer，根据它的第一个参数state或者返回值分析出来。在我们学习更高级框架(如dva)的时候，会看到如果应用的状态能够直接配置，那么我们对应用状态的维护将会变得更加简便和直观。\n\nreducer的触发时机，就是当使用redux提供的dispatch方法派发一个action时触发。但是dispatch方法不是redux的全局方法，它是store实例的方法，接下来我们就介绍store。\n\n## 3、 Store\n\nstore是把action和reducer联系到一起的对象。这里我们要注意和state区别开来，state由reducer的返回值组成，是整个应用的状态。store则是由redux提供的createStore方法创建的一个实例，createStore的参数就是reducers。\n\n{% codeblock %}\n// index.js\nimport { createStore } from 'redux'\nimport rootReducer from './reducers.js'\nconst store = createStore(rootReducer)\n{% endcodeblock %}\n\nstore创建之后，获取应用状态信息、更新应用状态等操作都是通过store实例的方法来实现。\n\n1. 获取应用状态：提供 getState() 方法获取 state；\n2. 更新应用状态：提供 dispatch(action) 方法更新 state；\n3. 订阅：通过 subscribe(listener) 注册监听器。\n\n以上，便介绍完了redux的几个重要概念。接下来，我们来验证一下。redux是一个状态管理库，它本身是不涉及UI，所以验证工作我们就通过console.log方法打印出state来验证。这可以通过subscribe方法来实现，当state方法变化时，subscribe方法的回调函数参数就会被调用。\n\n在index.js中补充验证代码，如下：\n\n{% codeblock %}\n// index.js\nimport { createStore } from 'redux'\nimport { addTodo, toggleTodo, setVisibilityFilter } from './actions.js'\nimport rootReducer from './reducers.js'\nconst store = createStore(rootReducer)\n\n// 验证\nstore.subscribe(() => {\n    console.log(store.getState())\n})\n// 打印初始状态\nconsole.log('初始状态', store.getState())\n\nstore.dispatch(addTodo('Learn Action'))\nstore.dispatch(addTodo('Learn reducer'))\nstore.dispatch(addTodo('Learn state'))\nstore.dispatch(addTodo('Learn store'))\nstore.dispatch(toggleTodo(0))\nstore.dispatch(toggleTodo(1))\nstore.dispatch(setVisibilityFilter('SHOW_COMPLETED'))\n\n{% endcodeblock %}\n\n## 4、把代码跑起来\n\n上面的样例代码包含3个文件: actions.js、reducers.js以及index.js。样例代码依赖于redux npm包，并使用了一些es6语法，想要把代码跑起来，我们使用webpack对这几个文件进行打包处理，让它成为浏览器可加载解析的文件。具体请参考{% link redux-01 https://github.com/Two-Ftry/react-essay/tree/master/redux-01 %}，里面对构建步骤进行了详细的说明。\n\n\n![result](result-20181213.png)","slug":"redux","published":1,"updated":"2019-01-10T02:57:10.689Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvoq0001i4c41kwmkfpb6","content":"<p>redux是一个状态管理库。核心概念，包括：action、reducer和store。</p>\n<ol>\n<li>action： 是把数据从应用传到store的有效载荷。</li>\n<li>reducer: 指定了应用状态的变化如何相应action，并发送到store。</li>\n<li>store: 把action和reducer联系到一起的对象。</li>\n</ol>\n<p>但是单单了解这三个概念和它们的内在联系还是不足够的。我们还需要了解state的由来，以及如何获取state、更新state；state和store又是什么区别。</p>\n<p>下面，我们一步一步来深入学习这三个概念。</p>\n<blockquote><p>在文章中，我们会以”待办事项”为例子展开讲解redux。待办事项的需求如下：</p>\n<ol>\n<li>一个待办事项的列表(用todos数组存储)<br>todos数组中的元素为待办事项内容，包含两个字段:<pre><code>{\n text: &#39;待办事项1&#39;, &#x2F;&#x2F; string\n completed: false,&#x2F;&#x2F; boolean 是否完成的状态\n}</code></pre></li>\n<li>一个过滤条件filter，filter是一个字符串，标明目前需要将哪些待办事项展现出来<pre><code>SHOW_ALL: 展示全部待办事项\nSHOW_COMPLETED: 展示已完成的待办事项\nSHOW_ACTIVE: 展示未完成的待办事项\n</code></pre></li>\n</ol>\n</blockquote>\n<h2 id=\"1、-Action\"><a href=\"#1、-Action\" class=\"headerlink\" title=\"1、 Action\"></a>1、 Action</h2><p>Action 是把数据从应用传到store的有效载荷。Action本质上是一个普通的javascript对象。Action有一个约定，它必须包含 <strong>“type”</strong> 属性。</p>\n<pre><code>{\n    type: &#39;ADD_TODO&#39;,\n    text: &#39;something&#39;,\n}</code></pre>\n<p>在实际应用中，我们会编写生成Action的方法，即 <em>Action</em> 创建函数，方便传递Action。</p>\n<pre><code>&#x2F;&#x2F; actions.js\n&#x2F;&#x2F; 添加待办事项\nexport function addTodo(text) {\n  return { type: &#39;ADD_TODO&#39;, text }\n}\n&#x2F;&#x2F; 对index对应待办事项的状态进行取反操作\nexport function toggleTodo(index) {\n  return { type: &#39;TOGGLE_TODO&#39;, index }\n}\n&#x2F;&#x2F; 更改过滤条件\nexport function setVisibilityFilter(filter) {\n  return { type: &#39;SET_VISIBILITY_FILTER&#39;, filter }\n}</code></pre>\n<p>在actions.js中，定义了三个Action创建函数，addTodo将待办事项添加到应用状态中，toggleTodo函数会更改index对应的事项的状态（未完成／已完成），setVisibilityFilter设置过滤条件。</p>\n<h2 id=\"2、-Reducer\"><a href=\"#2、-Reducer\" class=\"headerlink\" title=\"2、 Reducer\"></a>2、 Reducer</h2><p>reducer会响应接收到的action，然后改变对应的应用状态。reducer实际上是一个函数，这个函数包含两个参数，第一个参数为state，第二个参数为action。</p>\n<pre><code>&#x2F;&#x2F; reducers.js\n&#x2F;&#x2F; 待办事项的过滤条件\nfunction visibilityFilter(state = &#39;SHOW_ALL&#39;, action) {\n  switch (action.type) {\n    case &#39;SET_VISIBILITY_FILTER&#39;:\n      return action.filter\n    default:\n      return state\n  }\n}</code></pre>\n<p>在这里，参数state=[]的写法为es6语法，表明将state初始化为一个空数组。reducer的返回值组成了应用的状态（即”总state”,下面写到”应用的状态”的时候指的就是”总state”）。每一次调用reducer，参数state(即”子state”，”子state”构成了”总state”)的值为对应reducer对应状态的上一个值，该reducer的返回值又将更新到应用的状态中。如果是第一次调用reducer，参数state则为初始值。参数action则是上面介绍的一个带有type属性的普通javascript对象。</p>\n<p>我们来细看visibilityFilter函数的逻辑，它使用switch语句，根据action.type来区分处理不同的action。如果action.type等于’SET_VISIBILITY_FILTER’,它将action.filter返回，作为这个”子state”的新值；如果action.type不等于’SET_VISIBILITY_FILTER’，则将state原样返回，不做处理。</p>\n<p>如果仅有一个reducer，那么这个reducer的返回值就是应用的状态。不过在一般的应用中，为了便于阅读和维护，都会有多个reducer。然后再通过redux提供的全局方法 combineReducers 将reducer组合起来，构成最终的应用状态。combineReducers函数接收一个Object对象参数，该对象的key值可以设置任意多个，key值对应的value值为一个reducer。</p>\n<pre><code>&#x2F;&#x2F; reducers.js\nimport { combineReducers } from &#39;redux&#39;\n&#x2F;&#x2F; 待办事项的过滤条件\nfunction visibilityFilter(state = &#39;SHOW_ALL&#39;, action) {\n    switch (action.type) {\n      case &#39;SET_VISIBILITY_FILTER&#39;:\n        return action.filter\n      default:\n        return state\n    }\n  }\n  &#x2F;&#x2F; 待办事项列表reducer\n  function todos(state = [], action) {\n      switch (action.type) {\n          &#x2F;&#x2F; 添加待办事项\n          case &#39;ADD_TODO&#39;:\n              return [...state, {\n                  text: action.text,\n                  completed: false,\n              }]\n          break\n          &#x2F;&#x2F; 对index对应待办事项的状态进行取反操作\n          case &#39;TOGGLE_TODO&#39;:\n              const data = state.map((todo, index) =&gt; {\n                  return {\n                      ...todo,\n                      completed: index === action.index ? !todo.completed : todo.completed\n                  }\n              })\n              return data\n          break\n          default:\n              return state\n      }\n  }\n  \n  const rootReducer = combineReducers({\n      visibilityFilter,\n      todos\n  })\n  \n  export default rootReducer</code></pre>\n<p>reducers.js中，最终导出的是一个合并的reducer(rootReducer)。rootReducer最终的结构(即应用状态的结构)如下：</p>\n<pre><code>{\n    visibilityFilter: &#39;SHOW_ALL&#39;,\n    todos: [],\n}</code></pre>\n<p>应用状态由reducers的返回值构成，但是在代码中我们不会直观地看到上面这个结构。这个结构需要我们结合各个reducer，根据它的第一个参数state或者返回值分析出来。在我们学习更高级框架(如dva)的时候，会看到如果应用的状态能够直接配置，那么我们对应用状态的维护将会变得更加简便和直观。</p>\n<p>reducer的触发时机，就是当使用redux提供的dispatch方法派发一个action时触发。但是dispatch方法不是redux的全局方法，它是store实例的方法，接下来我们就介绍store。</p>\n<h2 id=\"3、-Store\"><a href=\"#3、-Store\" class=\"headerlink\" title=\"3、 Store\"></a>3、 Store</h2><p>store是把action和reducer联系到一起的对象。这里我们要注意和state区别开来，state由reducer的返回值组成，是整个应用的状态。store则是由redux提供的createStore方法创建的一个实例，createStore的参数就是reducers。</p>\n<pre><code>&#x2F;&#x2F; index.js\nimport { createStore } from &#39;redux&#39;\nimport rootReducer from &#39;.&#x2F;reducers.js&#39;\nconst store = createStore(rootReducer)</code></pre>\n<p>store创建之后，获取应用状态信息、更新应用状态等操作都是通过store实例的方法来实现。</p>\n<ol>\n<li>获取应用状态：提供 getState() 方法获取 state；</li>\n<li>更新应用状态：提供 dispatch(action) 方法更新 state；</li>\n<li>订阅：通过 subscribe(listener) 注册监听器。</li>\n</ol>\n<p>以上，便介绍完了redux的几个重要概念。接下来，我们来验证一下。redux是一个状态管理库，它本身是不涉及UI，所以验证工作我们就通过console.log方法打印出state来验证。这可以通过subscribe方法来实现，当state方法变化时，subscribe方法的回调函数参数就会被调用。</p>\n<p>在index.js中补充验证代码，如下：</p>\n<pre><code>&#x2F;&#x2F; index.js\nimport { createStore } from &#39;redux&#39;\nimport { addTodo, toggleTodo, setVisibilityFilter } from &#39;.&#x2F;actions.js&#39;\nimport rootReducer from &#39;.&#x2F;reducers.js&#39;\nconst store = createStore(rootReducer)\n\n&#x2F;&#x2F; 验证\nstore.subscribe(() =&gt; {\n    console.log(store.getState())\n})\n&#x2F;&#x2F; 打印初始状态\nconsole.log(&#39;初始状态&#39;, store.getState())\n\nstore.dispatch(addTodo(&#39;Learn Action&#39;))\nstore.dispatch(addTodo(&#39;Learn reducer&#39;))\nstore.dispatch(addTodo(&#39;Learn state&#39;))\nstore.dispatch(addTodo(&#39;Learn store&#39;))\nstore.dispatch(toggleTodo(0))\nstore.dispatch(toggleTodo(1))\nstore.dispatch(setVisibilityFilter(&#39;SHOW_COMPLETED&#39;))\n</code></pre>\n<h2 id=\"4、把代码跑起来\"><a href=\"#4、把代码跑起来\" class=\"headerlink\" title=\"4、把代码跑起来\"></a>4、把代码跑起来</h2><p>上面的样例代码包含3个文件: actions.js、reducers.js以及index.js。样例代码依赖于redux npm包，并使用了一些es6语法，想要把代码跑起来，我们使用webpack对这几个文件进行打包处理，让它成为浏览器可加载解析的文件。具体请参考<a href=\"https://github.com/Two-Ftry/react-essay/tree/master/redux-01\" target=\"_blank\" rel=\"noopener\">redux-01</a>，里面对构建步骤进行了详细的说明。</p>\n<p><img src=\"/2018/12/01/redux/result-20181213.png\" alt=\"result\"></p>\n","site":{"data":{}},"excerpt":"","more":"<p>redux是一个状态管理库。核心概念，包括：action、reducer和store。</p>\n<ol>\n<li>action： 是把数据从应用传到store的有效载荷。</li>\n<li>reducer: 指定了应用状态的变化如何相应action，并发送到store。</li>\n<li>store: 把action和reducer联系到一起的对象。</li>\n</ol>\n<p>但是单单了解这三个概念和它们的内在联系还是不足够的。我们还需要了解state的由来，以及如何获取state、更新state；state和store又是什么区别。</p>\n<p>下面，我们一步一步来深入学习这三个概念。</p>\n<blockquote><p>在文章中，我们会以”待办事项”为例子展开讲解redux。待办事项的需求如下：</p>\n<ol>\n<li>一个待办事项的列表(用todos数组存储)<br>todos数组中的元素为待办事项内容，包含两个字段:<pre><code>{\n text: &#39;待办事项1&#39;, &#x2F;&#x2F; string\n completed: false,&#x2F;&#x2F; boolean 是否完成的状态\n}</code></pre></li>\n<li>一个过滤条件filter，filter是一个字符串，标明目前需要将哪些待办事项展现出来<pre><code>SHOW_ALL: 展示全部待办事项\nSHOW_COMPLETED: 展示已完成的待办事项\nSHOW_ACTIVE: 展示未完成的待办事项\n</code></pre></li>\n</ol>\n</blockquote>\n<h2 id=\"1、-Action\"><a href=\"#1、-Action\" class=\"headerlink\" title=\"1、 Action\"></a>1、 Action</h2><p>Action 是把数据从应用传到store的有效载荷。Action本质上是一个普通的javascript对象。Action有一个约定，它必须包含 <strong>“type”</strong> 属性。</p>\n<pre><code>{\n    type: &#39;ADD_TODO&#39;,\n    text: &#39;something&#39;,\n}</code></pre>\n<p>在实际应用中，我们会编写生成Action的方法，即 <em>Action</em> 创建函数，方便传递Action。</p>\n<pre><code>&#x2F;&#x2F; actions.js\n&#x2F;&#x2F; 添加待办事项\nexport function addTodo(text) {\n  return { type: &#39;ADD_TODO&#39;, text }\n}\n&#x2F;&#x2F; 对index对应待办事项的状态进行取反操作\nexport function toggleTodo(index) {\n  return { type: &#39;TOGGLE_TODO&#39;, index }\n}\n&#x2F;&#x2F; 更改过滤条件\nexport function setVisibilityFilter(filter) {\n  return { type: &#39;SET_VISIBILITY_FILTER&#39;, filter }\n}</code></pre>\n<p>在actions.js中，定义了三个Action创建函数，addTodo将待办事项添加到应用状态中，toggleTodo函数会更改index对应的事项的状态（未完成／已完成），setVisibilityFilter设置过滤条件。</p>\n<h2 id=\"2、-Reducer\"><a href=\"#2、-Reducer\" class=\"headerlink\" title=\"2、 Reducer\"></a>2、 Reducer</h2><p>reducer会响应接收到的action，然后改变对应的应用状态。reducer实际上是一个函数，这个函数包含两个参数，第一个参数为state，第二个参数为action。</p>\n<pre><code>&#x2F;&#x2F; reducers.js\n&#x2F;&#x2F; 待办事项的过滤条件\nfunction visibilityFilter(state = &#39;SHOW_ALL&#39;, action) {\n  switch (action.type) {\n    case &#39;SET_VISIBILITY_FILTER&#39;:\n      return action.filter\n    default:\n      return state\n  }\n}</code></pre>\n<p>在这里，参数state=[]的写法为es6语法，表明将state初始化为一个空数组。reducer的返回值组成了应用的状态（即”总state”,下面写到”应用的状态”的时候指的就是”总state”）。每一次调用reducer，参数state(即”子state”，”子state”构成了”总state”)的值为对应reducer对应状态的上一个值，该reducer的返回值又将更新到应用的状态中。如果是第一次调用reducer，参数state则为初始值。参数action则是上面介绍的一个带有type属性的普通javascript对象。</p>\n<p>我们来细看visibilityFilter函数的逻辑，它使用switch语句，根据action.type来区分处理不同的action。如果action.type等于’SET_VISIBILITY_FILTER’,它将action.filter返回，作为这个”子state”的新值；如果action.type不等于’SET_VISIBILITY_FILTER’，则将state原样返回，不做处理。</p>\n<p>如果仅有一个reducer，那么这个reducer的返回值就是应用的状态。不过在一般的应用中，为了便于阅读和维护，都会有多个reducer。然后再通过redux提供的全局方法 combineReducers 将reducer组合起来，构成最终的应用状态。combineReducers函数接收一个Object对象参数，该对象的key值可以设置任意多个，key值对应的value值为一个reducer。</p>\n<pre><code>&#x2F;&#x2F; reducers.js\nimport { combineReducers } from &#39;redux&#39;\n&#x2F;&#x2F; 待办事项的过滤条件\nfunction visibilityFilter(state = &#39;SHOW_ALL&#39;, action) {\n    switch (action.type) {\n      case &#39;SET_VISIBILITY_FILTER&#39;:\n        return action.filter\n      default:\n        return state\n    }\n  }\n  &#x2F;&#x2F; 待办事项列表reducer\n  function todos(state = [], action) {\n      switch (action.type) {\n          &#x2F;&#x2F; 添加待办事项\n          case &#39;ADD_TODO&#39;:\n              return [...state, {\n                  text: action.text,\n                  completed: false,\n              }]\n          break\n          &#x2F;&#x2F; 对index对应待办事项的状态进行取反操作\n          case &#39;TOGGLE_TODO&#39;:\n              const data = state.map((todo, index) =&gt; {\n                  return {\n                      ...todo,\n                      completed: index === action.index ? !todo.completed : todo.completed\n                  }\n              })\n              return data\n          break\n          default:\n              return state\n      }\n  }\n  \n  const rootReducer = combineReducers({\n      visibilityFilter,\n      todos\n  })\n  \n  export default rootReducer</code></pre>\n<p>reducers.js中，最终导出的是一个合并的reducer(rootReducer)。rootReducer最终的结构(即应用状态的结构)如下：</p>\n<pre><code>{\n    visibilityFilter: &#39;SHOW_ALL&#39;,\n    todos: [],\n}</code></pre>\n<p>应用状态由reducers的返回值构成，但是在代码中我们不会直观地看到上面这个结构。这个结构需要我们结合各个reducer，根据它的第一个参数state或者返回值分析出来。在我们学习更高级框架(如dva)的时候，会看到如果应用的状态能够直接配置，那么我们对应用状态的维护将会变得更加简便和直观。</p>\n<p>reducer的触发时机，就是当使用redux提供的dispatch方法派发一个action时触发。但是dispatch方法不是redux的全局方法，它是store实例的方法，接下来我们就介绍store。</p>\n<h2 id=\"3、-Store\"><a href=\"#3、-Store\" class=\"headerlink\" title=\"3、 Store\"></a>3、 Store</h2><p>store是把action和reducer联系到一起的对象。这里我们要注意和state区别开来，state由reducer的返回值组成，是整个应用的状态。store则是由redux提供的createStore方法创建的一个实例，createStore的参数就是reducers。</p>\n<pre><code>&#x2F;&#x2F; index.js\nimport { createStore } from &#39;redux&#39;\nimport rootReducer from &#39;.&#x2F;reducers.js&#39;\nconst store = createStore(rootReducer)</code></pre>\n<p>store创建之后，获取应用状态信息、更新应用状态等操作都是通过store实例的方法来实现。</p>\n<ol>\n<li>获取应用状态：提供 getState() 方法获取 state；</li>\n<li>更新应用状态：提供 dispatch(action) 方法更新 state；</li>\n<li>订阅：通过 subscribe(listener) 注册监听器。</li>\n</ol>\n<p>以上，便介绍完了redux的几个重要概念。接下来，我们来验证一下。redux是一个状态管理库，它本身是不涉及UI，所以验证工作我们就通过console.log方法打印出state来验证。这可以通过subscribe方法来实现，当state方法变化时，subscribe方法的回调函数参数就会被调用。</p>\n<p>在index.js中补充验证代码，如下：</p>\n<pre><code>&#x2F;&#x2F; index.js\nimport { createStore } from &#39;redux&#39;\nimport { addTodo, toggleTodo, setVisibilityFilter } from &#39;.&#x2F;actions.js&#39;\nimport rootReducer from &#39;.&#x2F;reducers.js&#39;\nconst store = createStore(rootReducer)\n\n&#x2F;&#x2F; 验证\nstore.subscribe(() =&gt; {\n    console.log(store.getState())\n})\n&#x2F;&#x2F; 打印初始状态\nconsole.log(&#39;初始状态&#39;, store.getState())\n\nstore.dispatch(addTodo(&#39;Learn Action&#39;))\nstore.dispatch(addTodo(&#39;Learn reducer&#39;))\nstore.dispatch(addTodo(&#39;Learn state&#39;))\nstore.dispatch(addTodo(&#39;Learn store&#39;))\nstore.dispatch(toggleTodo(0))\nstore.dispatch(toggleTodo(1))\nstore.dispatch(setVisibilityFilter(&#39;SHOW_COMPLETED&#39;))\n</code></pre>\n<h2 id=\"4、把代码跑起来\"><a href=\"#4、把代码跑起来\" class=\"headerlink\" title=\"4、把代码跑起来\"></a>4、把代码跑起来</h2><p>上面的样例代码包含3个文件: actions.js、reducers.js以及index.js。样例代码依赖于redux npm包，并使用了一些es6语法，想要把代码跑起来，我们使用webpack对这几个文件进行打包处理，让它成为浏览器可加载解析的文件。具体请参考<a href=\"https://github.com/Two-Ftry/react-essay/tree/master/redux-01\" target=\"_blank\" rel=\"noopener\">redux-01</a>，里面对构建步骤进行了详细的说明。</p>\n<p><img src=\"/2018/12/01/redux/result-20181213.png\" alt=\"result\"></p>\n"},{"title":"redux(二)-待办事项项目UI实现","date":"2018-12-15T05:32:47.000Z","_content":"\n在前端学习的过程当中，很多文档里面都会以\"待办事项\"作为例子展开说明。在学习redux的过程中，我们也使用\"待办事项\"作为例子。在介绍\"redux搭配react\"之前，我们先来实现\"待办事项\"需求的UI界面。待办事项的具体需求如下：\n\n{% blockquote %}\n1. 一个待办事项的列表(用todos数组存储)\n   todos数组中的元素为待办事项内容，包含两个字段:\n   {% codeblock %}\n   {\n       text: '待办事项1', // string\n       completed: false,// boolean 是否完成的状态\n   }\n   {% endcodeblock %}\n2. 一个过滤条件filter，filter是一个字符串，标明目前需要将哪些待办事项展现出来\n   {% codeblock %}\n    SHOW_ALL: 展示全部待办事项\n    SHOW_COMPLETED: 展示已完成的待办事项\n    SHOW_ACTIVE: 展示未完成的待办事项\n   {% endcodeblock %}\n3. 添加待办事项\n{% endblockquote %}\n\n\n原本想把本文的相关内容和\"redux搭配react\"融在一起。但是在梳理章节的时候，发现需要比较多的前置知识，融合在一起，\"redux搭配react\"文章就太长了，不方便阅读。所以我们把\"'待办事项'项目UI实现\"独立出来，方便后面的文章举例说明。\n\n## 1、工程初始化\n\n既然是作为一个基础功能，我们就将项目名称命名为\"todo-base\"。在任何一个目录下创建\"todo-base\"目录，执行如下操作:\n\n{% codeblock %}\n> cd todo-base\n# 初始化工程，按照步骤一步步填写\n> npm init \n{% endcodeblock %}\n\nnpm init 执行完成了之后，目录下面就会有 package.json文件，该文件是什么？？\n我们的项目中，会有源代码文件，也会有编译出来的代码文件供发布线上。在项目根目录下创建\"src\"和\"dist\"两个目录，分别放置源代码文件和编译出来的代码文件。\n\n{% codeblock %}\n- dist\n- src\npackage.json\n{% endcodeblock %}\n\n接着，我们在src目录下创建我们的第一个js文件(index.js)，一个简单的npm项目架子就完成了。\n\n{% codeblock %}\n// index.js\ndocument.write('Hello World!')\n{% endcodeblock %}\n\n### 1.1 让项目跑起来\n既然说简单的项目已经成型，那怎样让\"Hello World!\"的字样能够在浏览器中显示呢？我们在dist目录下创建index.html文件，添加基础的html代码，然后引入\"index.js\"文件。\n\n{% codeblock %}\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\" />\n    <title>Document</title>\n</head>\n<body>\n    <script src=\"../src/index.js\"></script>\n</body>\n</html>\n{% endcodeblock %}\n\n我们用浏览器打开index.html，就可以看到\"Hello World!\"的字样啦。\n\n早先的web前端开发，就是这样的方式来进行的。只不过后来逐渐有了自动化打包的工具，这些步骤都通过打包实现了。后面将会看到我们是如何使用webpack将这个过程自动化的。\n\n## 2、+ webpack\n\n上一节中，我们在index.html中通过script标签，引入src/index.js，引入的是源文件。源文件直接引入到html当中，有几个方面的缺点：\n\n1. 需要自己通过script标签手动引入js文件，不太灵活;\n2. 这样引入的js文件，不能使用一些新的ES6、ES7特性，因为有些浏览器并不支持这些特性；\n3. script引入的js文件，还需要处理缓存的问题；\n4. 想要对js文件进行混淆压缩也不方便。\n\n一般来说，现在的前端开发都会使用像webpack、gulp等这些打包工具。本文我们使用webpack来处理js文件，并自动打包输出到dist目录中，并添加上混淆压缩的功能。\n\n### 2.1 webpack简单配置\n\nwebpack中有两个基本的概念：\"输入\"(entry)、\"输出\"(output)。webpack会根据入口的配置，逐步解析各个资源文件（包括js文件、css文件、图片等）形成一个依赖图。依赖图中的每个依赖项都会被处理，然后根据出口（output）的配置输出到对应的文件中。在我们的例子中，入口文件就是index.js，输出到\"dist\"目录下，所以webpack简单配置如下(在项目根目录下创建webpack.config.js文件)：\n\n{% codeblock %}\n// webpack.config.js\nconst path = require('path')\nmodule.exports = {\n    entry: {\n        app: './src/index', // \"app\"key值可以随便定义，输出的时候就可以取这个key值为输出文件命名\n    },\n    output: {\n        path: path.resolve(__dirname, './dist'),\n        filename: '[name].js', // 这里[name]就对应entry中的‘app’key值\n    }\n}\n{% endcodeblock %}\n\n当然我们要为项目添加webpack的npm包才能使用webpack来对文件进行打包处理。在命令行中输入：\n\n{% codeblock %}\n// 确保当前处于项目根目录下再输入如下命令\n> npm install -D webpack webpack-cli\n{% endcodeblock %}\n\n当依赖包安装完成之后，我们就可以使用webpack进行打包了，使用命令行工具，输入如下命令：\n\n{% codeblock %}\n// 确保当前处于项目根目录下再输入如下命令\n> webpack\n{% endcodeblock %}\n\n待webpack之行完成，我们会在dist目录下看到\"app.js\"文件对输出。\n\n到此我们来看看解决来本节开篇所列问题对几个？貌似一个都没有解决！我们只是使用webpack对入口文件进行了简单的打包输出。但是不要泄气，只要使用了webpack，我们再来添加一些配置，上面的问题就可以得到解决。\n\n### 2.2 使用webpack来解决问题\n\n（1） 避免手动引入js文件&解决缓存问题\n\n在前面的例子中js文件是通过script标签引入到html中使用的。而上一小节，我们通过webpack已经能将js文件打包输出。如果html文件也能通过webpack输出，那么是不是打包出来的js文件就能自动的引入到html文件中呢（毕竟webpack的输出配置是我们手动配置的）？答案是可以的。\n\n此时，我们需要了解webpack的另一个概念\"plugin\"。plugin是对webpack功能的增强，让webpack能够做更多的事情。要让webpack能够输出html文件，我们需要使用到\"html-webpack-plugin\"。\n\n首先，我们来安装“html-webpack-plugin”的npm依赖包。\n\n{% codeblock %}\n> npm install -D html-webpack-plugin\n{% endcodeblock %}\n\n接着修改webpack.config.js的配置：\n\n{% codeblock %}\n// webpack.config.js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = {\n    entry: {\n        app: './src/index', // \"app\"key值可以随便定义，输出的时候就可以取这个key值为输出文件命名\n    },\n    output: {\n        path: path.resolve(__dirname, './dist'),\n        filename: '[name].[chunkhash].js', // 这里[name]就对应entry中的‘app’key值\n    },\n    plugins: [\n        new HtmlWebpackPlugin()\n    ]\n}\n{% endcodeblock %}\n\n如上面的配置，除了添加plugins的配置外，还对output的filename配置改成了\"[name].[chunkhash].js\",这里chunkhash是基于内容的hash值，每当js源文件的内容发生改变时，chunkhash值也随之改变，这就可以解决引入js文件的缓存问题了。\n\n（2）支持es6、es7特性\n\n要让我们的代码支持es6、es7新特性。需要使用到webpack的loader功能，而能将es6、es7语法转换成浏览器支持的语法，就是\"babel-loader\"。要使用babel，我们需要先安装\n\n- babel : babel库\n- babel-loader：webpack用来加载babel的库\n- @babel/core：babel库的核心\n- @babel/preset-react：支持react的语法\n\n{% codeblock %}\n> npm insall -D babel babel-loader @babel/core @babel/preset-react\n{% endcodeblock %}\n\n在webpack.config.js中添加配置：\n\n{% codeblock %}\nmodule.exports = {\n    //...\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                use: 'babel-loader',\n            }\n        ]\n    }\n}\n{% endcodeblock%}\n\n这个配置告诉webpack，当加载js文件时，使用babel-loader进行转换。而babel-loader会调用babel来实现转换。\n\n不过上面的配置，仅仅使用了babel的核心功能，要让webpack支持更多的babel提供的功能，需要在项目根目录下创建babel的配置文件\".babelrc\"。然后往这个文件里面添加如下内容：\n\n{% codeblock %}\n// .babelrc\n{\n    \"presets\": [\"@babel/preset-react\"]\n}\n{% endcodeblock %}\n\n这个配置告诉babel调用“@babel/preset-react”来支持react的语法。\n\n### 2.3 开发环境支持\n\n接着2.1和2.2节的配置，我们已经使用上了webpack对文件进行打包处理。但是我们在代码中是会使用到ES6、ES7的一些特性，在开发的时候，需要babel实时对代码进行编译输出才能看到开发的功能是否有问题。并且我们也不可能，开发一会，想看效果了然后webpack编译一下再用浏览器看结果，这样效率就太低了。\n\n为了能实时能看到我们开发的功能，我们需要在本地起一个web服务，然后使用webpack监控文件的变化，当文件发生变化时立即执行webpack进行代码编译输出，发布到web服务上，这样我们在浏览器访问这个web服务的地址就能实时看到结果了。而这些，都可以通过webpack的devServer配置项来实现。看下面的配置：\n\n{% codeblock %}\n// webpack.config.js\nmodule.exports = {\n    // ...\n    devServer: {\n        contentBase: path.join(__dirname, 'dist'), // web服务的目录为 \"dist\" 目录\n        port: 9000 // web服务端口\n    }\n}\n{% endcodeblock %}\n\n配置好之后，如何启动devServer呢？首先，我们需要先安装\"webpack-dev-server\"这个npm包。\n\n{% codeblock %}\n// 确保当前处于项目根目录下再输入如下命令\n> npm install -D webpack-dev-server\n{% endcodeblock %}\n\n\"webpack-dev-server\"安装好之后，我们在命令行工具中输入\"webpack-dev-server\"即可启动服务了。\n\n{% codeblock %}\n// 确保当前处于项目根目录下再输入如下命令\n> webpack-dev-server\n{% endcodeblock %}\n\nweb服务启动之后，在浏览器打开 \"http://localhost:9000\" 就可以看到\"Hello World\"字样了。\n\n## 3、+ react\n\n在上一节，我们已经使用webpack将环境搭好了，接着我们就来添加react的代码。然后将\"待办事项\"的UI实现出来。我们先来安装react的依赖包。\n\n{% codeblock %}\n> npm install -D react react-dom\n{% endcodeblock %}\n\n在index.js中加入如下代码:\n\n{% codeblock %}\n// ./src/index.js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport App from './app'\n\nReactDOM.render(\n    <App />, \n    document.getElementsByTagName('BODY')[0],\n)\n{% endcodeblock %}\n\nindex.js是入口文件，会在body标签下渲染react组件<App />。组件App的代码如下（我们先搭一个架子）：\n\n{% codeblock %}\n// src/app.js\nimport React, { Component } from 'react';\nclass App extends Component {\n    render() {\n        return (\n            <div>{'todo app'}</div>\n        )\n    }\n}\nexport default App\n{% endcodeblock %}\n\n## 4、待办事项实现\n\n待办事项的UI分为三个部分：添加待办事项、待办事项列表、待办事项过滤条件。下面我们一个部分一个部分来实现，然后再组合起来。\n\n### 4.1 添加待办事项UI\n\n待办事项的添加，我们只需要一个input输入框和一个添加的按钮。我們使用react的函数定义组件来实现：\n\n{% codeblock %}\n// src/AddTodo.js\nimport React from 'react';\n\nconst AddTodo = () => {\n    return (\n        <div>\n            <input type=\"text\" />\n            <button type=\"button\">Add</button>\n        </div>\n    )\n}\n\nexport default AddTodo\n{% endcodeblock %}\n\n### 4.2 待办事项列表UI\n\n待办事项的列表，由列表项构成。所以这里拆分成Todo.js和TodoList.js两个文件。\n\n{% codeblock %}\n// src/Todo.js\nconst Todo = ({ onClick, completed, text }) => {\n    const style = {textDecoration: completed ? 'line-through' : 'none'}\n    return (\n    <li\n        onClick={onClick}\n        style={style}\n    >\n        {text}\n    </li>\n    )\n}\n{% endcodeblock %}\n\n{% codeblock %}\n// src/TodoList.js\nimport React from 'react'\n\nimport Todo from './Todo'\n\nconst TodoList = ({todos, onTodoClick}) => (\n    <ul>\n        {todos.map((todo, index) => (\n            <Todo key={index} {...todo} onClick={() => { onTodoClick(index) }}/>\n        ))}\n    </ul>\n)\nexport default TodoList\n{% endcodeblock %}\n\n### 4.3 待办事项列表过滤\n\n待办事项有\"完成\"、\"未完成\"两种状态，在显示待办事项列表的时候，默认显示所有的待办事项，也可以进行过滤。如果用户点击\"Active\"链接，则显示\"未完成\"状态的待办事项，如果用户点击\"Completed\"链接，则显示\"完成\"状态的待办事项。\n\n由于有三个链接，所以先定义链接的组件。\n\n{% codeblock %}\n// src/Link.js\nimport React from 'react'\n\nconst Link = ({ active, children, onClick }) => {\n    if (active) {\n      return <span>{children}</span>\n    }\n    return (\n      <a\n        href=\"\"\n        onClick={e => {\n          e.preventDefault()\n          onClick && onClick()\n        }}\n      >\n        {children}\n      </a>\n    )\n}\n\nexport default Link\n{% endcodeblock %}\n\n把三个链接组合起来，我们定义一个Footer.js文件。\n\n{% codeblock %}\nimport React from 'react';\nimport Link from './Link'\nconst Footer = () => (\n    <p>\n        Show:\n        <Link active={true}>ALL</Link>\n        &nbsp;&nbsp;\n        <Link active={false}>Active</Link>\n        &nbsp;&nbsp;\n        <Link active={false}>Completed</Link>\n    </p>\n)\nexport default Footer\n{% endcodeblock %}\n\n### 4.4 组合起来\n\n上面几个小节，把几个模块的UI组件都定义好了。我们来修改app.js文件，把各个模块组合起来。\n\n{% codeblock %}\n// src/app.js\nimport React, { Component } from 'react';\n\nimport AddTodo from './AddTodo'\nimport TodoList from './TodoList'\nimport Footer from './Footer'\n\n// 模拟数据\nconst data = [\n    {\n        text: '001',\n        completed: false,\n    },\n    {\n        text: '002',\n        completed: true,\n    },\n]\n\nclass App extends Component {\n    constructor (props) {\n        super(props)\n        this.onTodoClick = this.onTodoClick.bind(this)\n    }\n    onTodoClick (index) {\n        console.log('@@@@todo click', index)\n    }\n    render() {\n        return (\n            <div>\n                <AddTodo />\n                <TodoList todos={data} onTodoClick={this.onTodoClick}/>\n                <Footer />\n            </div>\n        )\n    }\n}\n\nexport default App\n{% endcodeblock %}\n\n具体的结构图如下：\n\n```mermaid\ngraph TD;\n    TodoApp-->AddTodo.js;\n    TodoApp-->TodoList.js;\n    TodoList.js-->Todo.js-1;\n    TodoList.js-->Todo.js...;\n    TodoApp-->Footer.js;\n    Footer.js-->Link.js-1;\n    Footer.js-->Link.js-2;\n    Footer.js-->Link.js-3;\n```\n\n# 5 结语\n\n本文具体的代码可查看 {% link 这里 https://github.com/Two-Ftry/react-essay/tree/master/redux-02 %}。\n\n现在的前端项目搭建，已经会涉及到很多知识。从本文可以看到，开发一个简单的UI，从项目搭建开始，我们使用到了npm来初始化项目，然后使用webpack来搭建环境，接着再组合react。而在webpack中，我们也会涉及到额外的npm包，如html-webpack-plugin、babel、babel-loader。丰富的工具让我们的开发变得简单高效，但是也增加了我们学习的成本。逐步积累，是不断进步的必经之路。","source":"_posts/redux2-todo ui-20181220.md","raw":"---\ntitle: redux(二)-待办事项项目UI实现\ndate: 2018-12-15 13:32:47\ntags: redux react\n---\n\n在前端学习的过程当中，很多文档里面都会以\"待办事项\"作为例子展开说明。在学习redux的过程中，我们也使用\"待办事项\"作为例子。在介绍\"redux搭配react\"之前，我们先来实现\"待办事项\"需求的UI界面。待办事项的具体需求如下：\n\n{% blockquote %}\n1. 一个待办事项的列表(用todos数组存储)\n   todos数组中的元素为待办事项内容，包含两个字段:\n   {% codeblock %}\n   {\n       text: '待办事项1', // string\n       completed: false,// boolean 是否完成的状态\n   }\n   {% endcodeblock %}\n2. 一个过滤条件filter，filter是一个字符串，标明目前需要将哪些待办事项展现出来\n   {% codeblock %}\n    SHOW_ALL: 展示全部待办事项\n    SHOW_COMPLETED: 展示已完成的待办事项\n    SHOW_ACTIVE: 展示未完成的待办事项\n   {% endcodeblock %}\n3. 添加待办事项\n{% endblockquote %}\n\n\n原本想把本文的相关内容和\"redux搭配react\"融在一起。但是在梳理章节的时候，发现需要比较多的前置知识，融合在一起，\"redux搭配react\"文章就太长了，不方便阅读。所以我们把\"'待办事项'项目UI实现\"独立出来，方便后面的文章举例说明。\n\n## 1、工程初始化\n\n既然是作为一个基础功能，我们就将项目名称命名为\"todo-base\"。在任何一个目录下创建\"todo-base\"目录，执行如下操作:\n\n{% codeblock %}\n> cd todo-base\n# 初始化工程，按照步骤一步步填写\n> npm init \n{% endcodeblock %}\n\nnpm init 执行完成了之后，目录下面就会有 package.json文件，该文件是什么？？\n我们的项目中，会有源代码文件，也会有编译出来的代码文件供发布线上。在项目根目录下创建\"src\"和\"dist\"两个目录，分别放置源代码文件和编译出来的代码文件。\n\n{% codeblock %}\n- dist\n- src\npackage.json\n{% endcodeblock %}\n\n接着，我们在src目录下创建我们的第一个js文件(index.js)，一个简单的npm项目架子就完成了。\n\n{% codeblock %}\n// index.js\ndocument.write('Hello World!')\n{% endcodeblock %}\n\n### 1.1 让项目跑起来\n既然说简单的项目已经成型，那怎样让\"Hello World!\"的字样能够在浏览器中显示呢？我们在dist目录下创建index.html文件，添加基础的html代码，然后引入\"index.js\"文件。\n\n{% codeblock %}\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\" />\n    <title>Document</title>\n</head>\n<body>\n    <script src=\"../src/index.js\"></script>\n</body>\n</html>\n{% endcodeblock %}\n\n我们用浏览器打开index.html，就可以看到\"Hello World!\"的字样啦。\n\n早先的web前端开发，就是这样的方式来进行的。只不过后来逐渐有了自动化打包的工具，这些步骤都通过打包实现了。后面将会看到我们是如何使用webpack将这个过程自动化的。\n\n## 2、+ webpack\n\n上一节中，我们在index.html中通过script标签，引入src/index.js，引入的是源文件。源文件直接引入到html当中，有几个方面的缺点：\n\n1. 需要自己通过script标签手动引入js文件，不太灵活;\n2. 这样引入的js文件，不能使用一些新的ES6、ES7特性，因为有些浏览器并不支持这些特性；\n3. script引入的js文件，还需要处理缓存的问题；\n4. 想要对js文件进行混淆压缩也不方便。\n\n一般来说，现在的前端开发都会使用像webpack、gulp等这些打包工具。本文我们使用webpack来处理js文件，并自动打包输出到dist目录中，并添加上混淆压缩的功能。\n\n### 2.1 webpack简单配置\n\nwebpack中有两个基本的概念：\"输入\"(entry)、\"输出\"(output)。webpack会根据入口的配置，逐步解析各个资源文件（包括js文件、css文件、图片等）形成一个依赖图。依赖图中的每个依赖项都会被处理，然后根据出口（output）的配置输出到对应的文件中。在我们的例子中，入口文件就是index.js，输出到\"dist\"目录下，所以webpack简单配置如下(在项目根目录下创建webpack.config.js文件)：\n\n{% codeblock %}\n// webpack.config.js\nconst path = require('path')\nmodule.exports = {\n    entry: {\n        app: './src/index', // \"app\"key值可以随便定义，输出的时候就可以取这个key值为输出文件命名\n    },\n    output: {\n        path: path.resolve(__dirname, './dist'),\n        filename: '[name].js', // 这里[name]就对应entry中的‘app’key值\n    }\n}\n{% endcodeblock %}\n\n当然我们要为项目添加webpack的npm包才能使用webpack来对文件进行打包处理。在命令行中输入：\n\n{% codeblock %}\n// 确保当前处于项目根目录下再输入如下命令\n> npm install -D webpack webpack-cli\n{% endcodeblock %}\n\n当依赖包安装完成之后，我们就可以使用webpack进行打包了，使用命令行工具，输入如下命令：\n\n{% codeblock %}\n// 确保当前处于项目根目录下再输入如下命令\n> webpack\n{% endcodeblock %}\n\n待webpack之行完成，我们会在dist目录下看到\"app.js\"文件对输出。\n\n到此我们来看看解决来本节开篇所列问题对几个？貌似一个都没有解决！我们只是使用webpack对入口文件进行了简单的打包输出。但是不要泄气，只要使用了webpack，我们再来添加一些配置，上面的问题就可以得到解决。\n\n### 2.2 使用webpack来解决问题\n\n（1） 避免手动引入js文件&解决缓存问题\n\n在前面的例子中js文件是通过script标签引入到html中使用的。而上一小节，我们通过webpack已经能将js文件打包输出。如果html文件也能通过webpack输出，那么是不是打包出来的js文件就能自动的引入到html文件中呢（毕竟webpack的输出配置是我们手动配置的）？答案是可以的。\n\n此时，我们需要了解webpack的另一个概念\"plugin\"。plugin是对webpack功能的增强，让webpack能够做更多的事情。要让webpack能够输出html文件，我们需要使用到\"html-webpack-plugin\"。\n\n首先，我们来安装“html-webpack-plugin”的npm依赖包。\n\n{% codeblock %}\n> npm install -D html-webpack-plugin\n{% endcodeblock %}\n\n接着修改webpack.config.js的配置：\n\n{% codeblock %}\n// webpack.config.js\nconst path = require('path')\nconst HtmlWebpackPlugin = require('html-webpack-plugin')\nmodule.exports = {\n    entry: {\n        app: './src/index', // \"app\"key值可以随便定义，输出的时候就可以取这个key值为输出文件命名\n    },\n    output: {\n        path: path.resolve(__dirname, './dist'),\n        filename: '[name].[chunkhash].js', // 这里[name]就对应entry中的‘app’key值\n    },\n    plugins: [\n        new HtmlWebpackPlugin()\n    ]\n}\n{% endcodeblock %}\n\n如上面的配置，除了添加plugins的配置外，还对output的filename配置改成了\"[name].[chunkhash].js\",这里chunkhash是基于内容的hash值，每当js源文件的内容发生改变时，chunkhash值也随之改变，这就可以解决引入js文件的缓存问题了。\n\n（2）支持es6、es7特性\n\n要让我们的代码支持es6、es7新特性。需要使用到webpack的loader功能，而能将es6、es7语法转换成浏览器支持的语法，就是\"babel-loader\"。要使用babel，我们需要先安装\n\n- babel : babel库\n- babel-loader：webpack用来加载babel的库\n- @babel/core：babel库的核心\n- @babel/preset-react：支持react的语法\n\n{% codeblock %}\n> npm insall -D babel babel-loader @babel/core @babel/preset-react\n{% endcodeblock %}\n\n在webpack.config.js中添加配置：\n\n{% codeblock %}\nmodule.exports = {\n    //...\n    module: {\n        rules: [\n            {\n                test: /\\.js$/,\n                use: 'babel-loader',\n            }\n        ]\n    }\n}\n{% endcodeblock%}\n\n这个配置告诉webpack，当加载js文件时，使用babel-loader进行转换。而babel-loader会调用babel来实现转换。\n\n不过上面的配置，仅仅使用了babel的核心功能，要让webpack支持更多的babel提供的功能，需要在项目根目录下创建babel的配置文件\".babelrc\"。然后往这个文件里面添加如下内容：\n\n{% codeblock %}\n// .babelrc\n{\n    \"presets\": [\"@babel/preset-react\"]\n}\n{% endcodeblock %}\n\n这个配置告诉babel调用“@babel/preset-react”来支持react的语法。\n\n### 2.3 开发环境支持\n\n接着2.1和2.2节的配置，我们已经使用上了webpack对文件进行打包处理。但是我们在代码中是会使用到ES6、ES7的一些特性，在开发的时候，需要babel实时对代码进行编译输出才能看到开发的功能是否有问题。并且我们也不可能，开发一会，想看效果了然后webpack编译一下再用浏览器看结果，这样效率就太低了。\n\n为了能实时能看到我们开发的功能，我们需要在本地起一个web服务，然后使用webpack监控文件的变化，当文件发生变化时立即执行webpack进行代码编译输出，发布到web服务上，这样我们在浏览器访问这个web服务的地址就能实时看到结果了。而这些，都可以通过webpack的devServer配置项来实现。看下面的配置：\n\n{% codeblock %}\n// webpack.config.js\nmodule.exports = {\n    // ...\n    devServer: {\n        contentBase: path.join(__dirname, 'dist'), // web服务的目录为 \"dist\" 目录\n        port: 9000 // web服务端口\n    }\n}\n{% endcodeblock %}\n\n配置好之后，如何启动devServer呢？首先，我们需要先安装\"webpack-dev-server\"这个npm包。\n\n{% codeblock %}\n// 确保当前处于项目根目录下再输入如下命令\n> npm install -D webpack-dev-server\n{% endcodeblock %}\n\n\"webpack-dev-server\"安装好之后，我们在命令行工具中输入\"webpack-dev-server\"即可启动服务了。\n\n{% codeblock %}\n// 确保当前处于项目根目录下再输入如下命令\n> webpack-dev-server\n{% endcodeblock %}\n\nweb服务启动之后，在浏览器打开 \"http://localhost:9000\" 就可以看到\"Hello World\"字样了。\n\n## 3、+ react\n\n在上一节，我们已经使用webpack将环境搭好了，接着我们就来添加react的代码。然后将\"待办事项\"的UI实现出来。我们先来安装react的依赖包。\n\n{% codeblock %}\n> npm install -D react react-dom\n{% endcodeblock %}\n\n在index.js中加入如下代码:\n\n{% codeblock %}\n// ./src/index.js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport App from './app'\n\nReactDOM.render(\n    <App />, \n    document.getElementsByTagName('BODY')[0],\n)\n{% endcodeblock %}\n\nindex.js是入口文件，会在body标签下渲染react组件<App />。组件App的代码如下（我们先搭一个架子）：\n\n{% codeblock %}\n// src/app.js\nimport React, { Component } from 'react';\nclass App extends Component {\n    render() {\n        return (\n            <div>{'todo app'}</div>\n        )\n    }\n}\nexport default App\n{% endcodeblock %}\n\n## 4、待办事项实现\n\n待办事项的UI分为三个部分：添加待办事项、待办事项列表、待办事项过滤条件。下面我们一个部分一个部分来实现，然后再组合起来。\n\n### 4.1 添加待办事项UI\n\n待办事项的添加，我们只需要一个input输入框和一个添加的按钮。我們使用react的函数定义组件来实现：\n\n{% codeblock %}\n// src/AddTodo.js\nimport React from 'react';\n\nconst AddTodo = () => {\n    return (\n        <div>\n            <input type=\"text\" />\n            <button type=\"button\">Add</button>\n        </div>\n    )\n}\n\nexport default AddTodo\n{% endcodeblock %}\n\n### 4.2 待办事项列表UI\n\n待办事项的列表，由列表项构成。所以这里拆分成Todo.js和TodoList.js两个文件。\n\n{% codeblock %}\n// src/Todo.js\nconst Todo = ({ onClick, completed, text }) => {\n    const style = {textDecoration: completed ? 'line-through' : 'none'}\n    return (\n    <li\n        onClick={onClick}\n        style={style}\n    >\n        {text}\n    </li>\n    )\n}\n{% endcodeblock %}\n\n{% codeblock %}\n// src/TodoList.js\nimport React from 'react'\n\nimport Todo from './Todo'\n\nconst TodoList = ({todos, onTodoClick}) => (\n    <ul>\n        {todos.map((todo, index) => (\n            <Todo key={index} {...todo} onClick={() => { onTodoClick(index) }}/>\n        ))}\n    </ul>\n)\nexport default TodoList\n{% endcodeblock %}\n\n### 4.3 待办事项列表过滤\n\n待办事项有\"完成\"、\"未完成\"两种状态，在显示待办事项列表的时候，默认显示所有的待办事项，也可以进行过滤。如果用户点击\"Active\"链接，则显示\"未完成\"状态的待办事项，如果用户点击\"Completed\"链接，则显示\"完成\"状态的待办事项。\n\n由于有三个链接，所以先定义链接的组件。\n\n{% codeblock %}\n// src/Link.js\nimport React from 'react'\n\nconst Link = ({ active, children, onClick }) => {\n    if (active) {\n      return <span>{children}</span>\n    }\n    return (\n      <a\n        href=\"\"\n        onClick={e => {\n          e.preventDefault()\n          onClick && onClick()\n        }}\n      >\n        {children}\n      </a>\n    )\n}\n\nexport default Link\n{% endcodeblock %}\n\n把三个链接组合起来，我们定义一个Footer.js文件。\n\n{% codeblock %}\nimport React from 'react';\nimport Link from './Link'\nconst Footer = () => (\n    <p>\n        Show:\n        <Link active={true}>ALL</Link>\n        &nbsp;&nbsp;\n        <Link active={false}>Active</Link>\n        &nbsp;&nbsp;\n        <Link active={false}>Completed</Link>\n    </p>\n)\nexport default Footer\n{% endcodeblock %}\n\n### 4.4 组合起来\n\n上面几个小节，把几个模块的UI组件都定义好了。我们来修改app.js文件，把各个模块组合起来。\n\n{% codeblock %}\n// src/app.js\nimport React, { Component } from 'react';\n\nimport AddTodo from './AddTodo'\nimport TodoList from './TodoList'\nimport Footer from './Footer'\n\n// 模拟数据\nconst data = [\n    {\n        text: '001',\n        completed: false,\n    },\n    {\n        text: '002',\n        completed: true,\n    },\n]\n\nclass App extends Component {\n    constructor (props) {\n        super(props)\n        this.onTodoClick = this.onTodoClick.bind(this)\n    }\n    onTodoClick (index) {\n        console.log('@@@@todo click', index)\n    }\n    render() {\n        return (\n            <div>\n                <AddTodo />\n                <TodoList todos={data} onTodoClick={this.onTodoClick}/>\n                <Footer />\n            </div>\n        )\n    }\n}\n\nexport default App\n{% endcodeblock %}\n\n具体的结构图如下：\n\n```mermaid\ngraph TD;\n    TodoApp-->AddTodo.js;\n    TodoApp-->TodoList.js;\n    TodoList.js-->Todo.js-1;\n    TodoList.js-->Todo.js...;\n    TodoApp-->Footer.js;\n    Footer.js-->Link.js-1;\n    Footer.js-->Link.js-2;\n    Footer.js-->Link.js-3;\n```\n\n# 5 结语\n\n本文具体的代码可查看 {% link 这里 https://github.com/Two-Ftry/react-essay/tree/master/redux-02 %}。\n\n现在的前端项目搭建，已经会涉及到很多知识。从本文可以看到，开发一个简单的UI，从项目搭建开始，我们使用到了npm来初始化项目，然后使用webpack来搭建环境，接着再组合react。而在webpack中，我们也会涉及到额外的npm包，如html-webpack-plugin、babel、babel-loader。丰富的工具让我们的开发变得简单高效，但是也增加了我们学习的成本。逐步积累，是不断进步的必经之路。","slug":"redux2-todo ui","published":1,"updated":"2019-01-10T02:59:41.783Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvoq1001j4c41yr6nkpz4","content":"<p>在前端学习的过程当中，很多文档里面都会以”待办事项”作为例子展开说明。在学习redux的过程中，我们也使用”待办事项”作为例子。在介绍”redux搭配react”之前，我们先来实现”待办事项”需求的UI界面。待办事项的具体需求如下：</p>\n<blockquote><ol>\n<li>一个待办事项的列表(用todos数组存储)<br>todos数组中的元素为待办事项内容，包含两个字段:<pre><code>{\n text: &#39;待办事项1&#39;, &#x2F;&#x2F; string\n completed: false,&#x2F;&#x2F; boolean 是否完成的状态\n}</code></pre></li>\n<li>一个过滤条件filter，filter是一个字符串，标明目前需要将哪些待办事项展现出来<pre><code>SHOW_ALL: 展示全部待办事项\nSHOW_COMPLETED: 展示已完成的待办事项\nSHOW_ACTIVE: 展示未完成的待办事项\n</code></pre></li>\n<li>添加待办事项</li>\n</ol>\n</blockquote>\n<p>原本想把本文的相关内容和”redux搭配react”融在一起。但是在梳理章节的时候，发现需要比较多的前置知识，融合在一起，”redux搭配react”文章就太长了，不方便阅读。所以我们把”‘待办事项’项目UI实现”独立出来，方便后面的文章举例说明。</p>\n<h2 id=\"1、工程初始化\"><a href=\"#1、工程初始化\" class=\"headerlink\" title=\"1、工程初始化\"></a>1、工程初始化</h2><p>既然是作为一个基础功能，我们就将项目名称命名为”todo-base”。在任何一个目录下创建”todo-base”目录，执行如下操作:</p>\n<pre><code>&gt; cd todo-base\n# 初始化工程，按照步骤一步步填写\n&gt; npm init </code></pre>\n<p>npm init 执行完成了之后，目录下面就会有 package.json文件，该文件是什么？？<br>我们的项目中，会有源代码文件，也会有编译出来的代码文件供发布线上。在项目根目录下创建”src”和”dist”两个目录，分别放置源代码文件和编译出来的代码文件。</p>\n<pre><code>- dist\n- src\npackage.json</code></pre>\n<p>接着，我们在src目录下创建我们的第一个js文件(index.js)，一个简单的npm项目架子就完成了。</p>\n<pre><code>&#x2F;&#x2F; index.js\ndocument.write(&#39;Hello World!&#39;)</code></pre>\n<h3 id=\"1-1-让项目跑起来\"><a href=\"#1-1-让项目跑起来\" class=\"headerlink\" title=\"1.1 让项目跑起来\"></a>1.1 让项目跑起来</h3><p>既然说简单的项目已经成型，那怎样让”Hello World!”的字样能够在浏览器中显示呢？我们在dist目录下创建index.html文件，添加基础的html代码，然后引入”index.js”文件。</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;script src=&quot;..&#x2F;src&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n<p>我们用浏览器打开index.html，就可以看到”Hello World!”的字样啦。</p>\n<p>早先的web前端开发，就是这样的方式来进行的。只不过后来逐渐有了自动化打包的工具，这些步骤都通过打包实现了。后面将会看到我们是如何使用webpack将这个过程自动化的。</p>\n<h2 id=\"2、-webpack\"><a href=\"#2、-webpack\" class=\"headerlink\" title=\"2、+ webpack\"></a>2、+ webpack</h2><p>上一节中，我们在index.html中通过script标签，引入src/index.js，引入的是源文件。源文件直接引入到html当中，有几个方面的缺点：</p>\n<ol>\n<li>需要自己通过script标签手动引入js文件，不太灵活;</li>\n<li>这样引入的js文件，不能使用一些新的ES6、ES7特性，因为有些浏览器并不支持这些特性；</li>\n<li>script引入的js文件，还需要处理缓存的问题；</li>\n<li>想要对js文件进行混淆压缩也不方便。</li>\n</ol>\n<p>一般来说，现在的前端开发都会使用像webpack、gulp等这些打包工具。本文我们使用webpack来处理js文件，并自动打包输出到dist目录中，并添加上混淆压缩的功能。</p>\n<h3 id=\"2-1-webpack简单配置\"><a href=\"#2-1-webpack简单配置\" class=\"headerlink\" title=\"2.1 webpack简单配置\"></a>2.1 webpack简单配置</h3><p>webpack中有两个基本的概念：”输入”(entry)、”输出”(output)。webpack会根据入口的配置，逐步解析各个资源文件（包括js文件、css文件、图片等）形成一个依赖图。依赖图中的每个依赖项都会被处理，然后根据出口（output）的配置输出到对应的文件中。在我们的例子中，入口文件就是index.js，输出到”dist”目录下，所以webpack简单配置如下(在项目根目录下创建webpack.config.js文件)：</p>\n<pre><code>&#x2F;&#x2F; webpack.config.js\nconst path = require(&#39;path&#39;)\nmodule.exports = {\n    entry: {\n        app: &#39;.&#x2F;src&#x2F;index&#39;, &#x2F;&#x2F; &quot;app&quot;key值可以随便定义，输出的时候就可以取这个key值为输出文件命名\n    },\n    output: {\n        path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;),\n        filename: &#39;[name].js&#39;, &#x2F;&#x2F; 这里[name]就对应entry中的‘app’key值\n    }\n}</code></pre>\n<p>当然我们要为项目添加webpack的npm包才能使用webpack来对文件进行打包处理。在命令行中输入：</p>\n<pre><code>&#x2F;&#x2F; 确保当前处于项目根目录下再输入如下命令\n&gt; npm install -D webpack webpack-cli</code></pre>\n<p>当依赖包安装完成之后，我们就可以使用webpack进行打包了，使用命令行工具，输入如下命令：</p>\n<pre><code>&#x2F;&#x2F; 确保当前处于项目根目录下再输入如下命令\n&gt; webpack</code></pre>\n<p>待webpack之行完成，我们会在dist目录下看到”app.js”文件对输出。</p>\n<p>到此我们来看看解决来本节开篇所列问题对几个？貌似一个都没有解决！我们只是使用webpack对入口文件进行了简单的打包输出。但是不要泄气，只要使用了webpack，我们再来添加一些配置，上面的问题就可以得到解决。</p>\n<h3 id=\"2-2-使用webpack来解决问题\"><a href=\"#2-2-使用webpack来解决问题\" class=\"headerlink\" title=\"2.2 使用webpack来解决问题\"></a>2.2 使用webpack来解决问题</h3><p>（1） 避免手动引入js文件&amp;解决缓存问题</p>\n<p>在前面的例子中js文件是通过script标签引入到html中使用的。而上一小节，我们通过webpack已经能将js文件打包输出。如果html文件也能通过webpack输出，那么是不是打包出来的js文件就能自动的引入到html文件中呢（毕竟webpack的输出配置是我们手动配置的）？答案是可以的。</p>\n<p>此时，我们需要了解webpack的另一个概念”plugin”。plugin是对webpack功能的增强，让webpack能够做更多的事情。要让webpack能够输出html文件，我们需要使用到”html-webpack-plugin”。</p>\n<p>首先，我们来安装“html-webpack-plugin”的npm依赖包。</p>\n<pre><code>&gt; npm install -D html-webpack-plugin</code></pre>\n<p>接着修改webpack.config.js的配置：</p>\n<pre><code>&#x2F;&#x2F; webpack.config.js\nconst path = require(&#39;path&#39;)\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nmodule.exports = {\n    entry: {\n        app: &#39;.&#x2F;src&#x2F;index&#39;, &#x2F;&#x2F; &quot;app&quot;key值可以随便定义，输出的时候就可以取这个key值为输出文件命名\n    },\n    output: {\n        path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;),\n        filename: &#39;[name].[chunkhash].js&#39;, &#x2F;&#x2F; 这里[name]就对应entry中的‘app’key值\n    },\n    plugins: [\n        new HtmlWebpackPlugin()\n    ]\n}</code></pre>\n<p>如上面的配置，除了添加plugins的配置外，还对output的filename配置改成了”[name].[chunkhash].js”,这里chunkhash是基于内容的hash值，每当js源文件的内容发生改变时，chunkhash值也随之改变，这就可以解决引入js文件的缓存问题了。</p>\n<p>（2）支持es6、es7特性</p>\n<p>要让我们的代码支持es6、es7新特性。需要使用到webpack的loader功能，而能将es6、es7语法转换成浏览器支持的语法，就是”babel-loader”。要使用babel，我们需要先安装</p>\n<ul>\n<li>babel : babel库</li>\n<li>babel-loader：webpack用来加载babel的库</li>\n<li>@babel/core：babel库的核心</li>\n<li>@babel/preset-react：支持react的语法</li>\n</ul>\n<pre><code>&gt; npm insall -D babel babel-loader @babel&#x2F;core @babel&#x2F;preset-react</code></pre>\n<p>在webpack.config.js中添加配置：</p>\n<pre><code>module.exports = {\n    &#x2F;&#x2F;...\n    module: {\n        rules: [\n            {\n                test: &#x2F;\\.js$&#x2F;,\n                use: &#39;babel-loader&#39;,\n            }\n        ]\n    }\n}</code></pre>\n<p>这个配置告诉webpack，当加载js文件时，使用babel-loader进行转换。而babel-loader会调用babel来实现转换。</p>\n<p>不过上面的配置，仅仅使用了babel的核心功能，要让webpack支持更多的babel提供的功能，需要在项目根目录下创建babel的配置文件”.babelrc”。然后往这个文件里面添加如下内容：</p>\n<pre><code>&#x2F;&#x2F; .babelrc\n{\n    &quot;presets&quot;: [&quot;@babel&#x2F;preset-react&quot;]\n}</code></pre>\n<p>这个配置告诉babel调用“@babel/preset-react”来支持react的语法。</p>\n<h3 id=\"2-3-开发环境支持\"><a href=\"#2-3-开发环境支持\" class=\"headerlink\" title=\"2.3 开发环境支持\"></a>2.3 开发环境支持</h3><p>接着2.1和2.2节的配置，我们已经使用上了webpack对文件进行打包处理。但是我们在代码中是会使用到ES6、ES7的一些特性，在开发的时候，需要babel实时对代码进行编译输出才能看到开发的功能是否有问题。并且我们也不可能，开发一会，想看效果了然后webpack编译一下再用浏览器看结果，这样效率就太低了。</p>\n<p>为了能实时能看到我们开发的功能，我们需要在本地起一个web服务，然后使用webpack监控文件的变化，当文件发生变化时立即执行webpack进行代码编译输出，发布到web服务上，这样我们在浏览器访问这个web服务的地址就能实时看到结果了。而这些，都可以通过webpack的devServer配置项来实现。看下面的配置：</p>\n<pre><code>&#x2F;&#x2F; webpack.config.js\nmodule.exports = {\n    &#x2F;&#x2F; ...\n    devServer: {\n        contentBase: path.join(__dirname, &#39;dist&#39;), &#x2F;&#x2F; web服务的目录为 &quot;dist&quot; 目录\n        port: 9000 &#x2F;&#x2F; web服务端口\n    }\n}</code></pre>\n<p>配置好之后，如何启动devServer呢？首先，我们需要先安装”webpack-dev-server”这个npm包。</p>\n<pre><code>&#x2F;&#x2F; 确保当前处于项目根目录下再输入如下命令\n&gt; npm install -D webpack-dev-server</code></pre>\n<p>“webpack-dev-server”安装好之后，我们在命令行工具中输入”webpack-dev-server”即可启动服务了。</p>\n<pre><code>&#x2F;&#x2F; 确保当前处于项目根目录下再输入如下命令\n&gt; webpack-dev-server</code></pre>\n<p>web服务启动之后，在浏览器打开 “<a href=\"http://localhost:9000&quot;\" target=\"_blank\" rel=\"noopener\">http://localhost:9000&quot;</a> 就可以看到”Hello World”字样了。</p>\n<h2 id=\"3、-react\"><a href=\"#3、-react\" class=\"headerlink\" title=\"3、+ react\"></a>3、+ react</h2><p>在上一节，我们已经使用webpack将环境搭好了，接着我们就来添加react的代码。然后将”待办事项”的UI实现出来。我们先来安装react的依赖包。</p>\n<pre><code>&gt; npm install -D react react-dom</code></pre>\n<p>在index.js中加入如下代码:</p>\n<pre><code>&#x2F;&#x2F; .&#x2F;src&#x2F;index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\n\nimport App from &#39;.&#x2F;app&#39;\n\nReactDOM.render(\n    &lt;App &#x2F;&gt;, \n    document.getElementsByTagName(&#39;BODY&#39;)[0],\n)</code></pre>\n<p>index.js是入口文件，会在body标签下渲染react组件<app>。组件App的代码如下（我们先搭一个架子）：</app></p>\n<pre><code>&#x2F;&#x2F; src&#x2F;app.js\nimport React, { Component } from &#39;react&#39;;\nclass App extends Component {\n    render() {\n        return (\n            &lt;div&gt;{&#39;todo app&#39;}&lt;&#x2F;div&gt;\n        )\n    }\n}\nexport default App</code></pre>\n<h2 id=\"4、待办事项实现\"><a href=\"#4、待办事项实现\" class=\"headerlink\" title=\"4、待办事项实现\"></a>4、待办事项实现</h2><p>待办事项的UI分为三个部分：添加待办事项、待办事项列表、待办事项过滤条件。下面我们一个部分一个部分来实现，然后再组合起来。</p>\n<h3 id=\"4-1-添加待办事项UI\"><a href=\"#4-1-添加待办事项UI\" class=\"headerlink\" title=\"4.1 添加待办事项UI\"></a>4.1 添加待办事项UI</h3><p>待办事项的添加，我们只需要一个input输入框和一个添加的按钮。我們使用react的函数定义组件来实现：</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;AddTodo.js\nimport React from &#39;react&#39;;\n\nconst AddTodo = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;input type=&quot;text&quot; &#x2F;&gt;\n            &lt;button type=&quot;button&quot;&gt;Add&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n}\n\nexport default AddTodo</code></pre>\n<h3 id=\"4-2-待办事项列表UI\"><a href=\"#4-2-待办事项列表UI\" class=\"headerlink\" title=\"4.2 待办事项列表UI\"></a>4.2 待办事项列表UI</h3><p>待办事项的列表，由列表项构成。所以这里拆分成Todo.js和TodoList.js两个文件。</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;Todo.js\nconst Todo = ({ onClick, completed, text }) =&gt; {\n    const style = {textDecoration: completed ? &#39;line-through&#39; : &#39;none&#39;}\n    return (\n    &lt;li\n        onClick={onClick}\n        style={style}\n    &gt;\n        {text}\n    &lt;&#x2F;li&gt;\n    )\n}</code></pre>\n<pre><code>&#x2F;&#x2F; src&#x2F;TodoList.js\nimport React from &#39;react&#39;\n\nimport Todo from &#39;.&#x2F;Todo&#39;\n\nconst TodoList = ({todos, onTodoClick}) =&gt; (\n    &lt;ul&gt;\n        {todos.map((todo, index) =&gt; (\n            &lt;Todo key={index} {...todo} onClick={() =&gt; { onTodoClick(index) }}&#x2F;&gt;\n        ))}\n    &lt;&#x2F;ul&gt;\n)\nexport default TodoList</code></pre>\n<h3 id=\"4-3-待办事项列表过滤\"><a href=\"#4-3-待办事项列表过滤\" class=\"headerlink\" title=\"4.3 待办事项列表过滤\"></a>4.3 待办事项列表过滤</h3><p>待办事项有”完成”、”未完成”两种状态，在显示待办事项列表的时候，默认显示所有的待办事项，也可以进行过滤。如果用户点击”Active”链接，则显示”未完成”状态的待办事项，如果用户点击”Completed”链接，则显示”完成”状态的待办事项。</p>\n<p>由于有三个链接，所以先定义链接的组件。</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;Link.js\nimport React from &#39;react&#39;\n\nconst Link = ({ active, children, onClick }) =&gt; {\n    if (active) {\n      return &lt;span&gt;{children}&lt;&#x2F;span&gt;\n    }\n    return (\n      &lt;a\n        href=&quot;&quot;\n        onClick={e =&gt; {\n          e.preventDefault()\n          onClick &amp;&amp; onClick()\n        }}\n      &gt;\n        {children}\n      &lt;&#x2F;a&gt;\n    )\n}\n\nexport default Link</code></pre>\n<p>把三个链接组合起来，我们定义一个Footer.js文件。</p>\n<pre><code>import React from &#39;react&#39;;\nimport Link from &#39;.&#x2F;Link&#39;\nconst Footer = () =&gt; (\n    &lt;p&gt;\n        Show:\n        &lt;Link active={true}&gt;ALL&lt;&#x2F;Link&gt;\n        &amp;nbsp;&amp;nbsp;\n        &lt;Link active={false}&gt;Active&lt;&#x2F;Link&gt;\n        &amp;nbsp;&amp;nbsp;\n        &lt;Link active={false}&gt;Completed&lt;&#x2F;Link&gt;\n    &lt;&#x2F;p&gt;\n)\nexport default Footer</code></pre>\n<h3 id=\"4-4-组合起来\"><a href=\"#4-4-组合起来\" class=\"headerlink\" title=\"4.4 组合起来\"></a>4.4 组合起来</h3><p>上面几个小节，把几个模块的UI组件都定义好了。我们来修改app.js文件，把各个模块组合起来。</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;app.js\nimport React, { Component } from &#39;react&#39;;\n\nimport AddTodo from &#39;.&#x2F;AddTodo&#39;\nimport TodoList from &#39;.&#x2F;TodoList&#39;\nimport Footer from &#39;.&#x2F;Footer&#39;\n\n&#x2F;&#x2F; 模拟数据\nconst data = [\n    {\n        text: &#39;001&#39;,\n        completed: false,\n    },\n    {\n        text: &#39;002&#39;,\n        completed: true,\n    },\n]\n\nclass App extends Component {\n    constructor (props) {\n        super(props)\n        this.onTodoClick = this.onTodoClick.bind(this)\n    }\n    onTodoClick (index) {\n        console.log(&#39;@@@@todo click&#39;, index)\n    }\n    render() {\n        return (\n            &lt;div&gt;\n                &lt;AddTodo &#x2F;&gt;\n                &lt;TodoList todos={data} onTodoClick={this.onTodoClick}&#x2F;&gt;\n                &lt;Footer &#x2F;&gt;\n            &lt;&#x2F;div&gt;\n        )\n    }\n}\n\nexport default App</code></pre>\n<p>具体的结构图如下：</p>\n<pre class=\"mermaid\">graph TD;\n    TodoApp-->AddTodo.js;\n    TodoApp-->TodoList.js;\n    TodoList.js-->Todo.js-1;\n    TodoList.js-->Todo.js...;\n    TodoApp-->Footer.js;\n    Footer.js-->Link.js-1;\n    Footer.js-->Link.js-2;\n    Footer.js-->Link.js-3;</pre>\n\n<h1 id=\"5-结语\"><a href=\"#5-结语\" class=\"headerlink\" title=\"5 结语\"></a>5 结语</h1><p>本文具体的代码可查看 <a href=\"https://github.com/Two-Ftry/react-essay/tree/master/redux-02\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<p>现在的前端项目搭建，已经会涉及到很多知识。从本文可以看到，开发一个简单的UI，从项目搭建开始，我们使用到了npm来初始化项目，然后使用webpack来搭建环境，接着再组合react。而在webpack中，我们也会涉及到额外的npm包，如html-webpack-plugin、babel、babel-loader。丰富的工具让我们的开发变得简单高效，但是也增加了我们学习的成本。逐步积累，是不断进步的必经之路。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在前端学习的过程当中，很多文档里面都会以”待办事项”作为例子展开说明。在学习redux的过程中，我们也使用”待办事项”作为例子。在介绍”redux搭配react”之前，我们先来实现”待办事项”需求的UI界面。待办事项的具体需求如下：</p>\n<blockquote><ol>\n<li>一个待办事项的列表(用todos数组存储)<br>todos数组中的元素为待办事项内容，包含两个字段:<pre><code>{\n text: &#39;待办事项1&#39;, &#x2F;&#x2F; string\n completed: false,&#x2F;&#x2F; boolean 是否完成的状态\n}</code></pre></li>\n<li>一个过滤条件filter，filter是一个字符串，标明目前需要将哪些待办事项展现出来<pre><code>SHOW_ALL: 展示全部待办事项\nSHOW_COMPLETED: 展示已完成的待办事项\nSHOW_ACTIVE: 展示未完成的待办事项\n</code></pre></li>\n<li>添加待办事项</li>\n</ol>\n</blockquote>\n<p>原本想把本文的相关内容和”redux搭配react”融在一起。但是在梳理章节的时候，发现需要比较多的前置知识，融合在一起，”redux搭配react”文章就太长了，不方便阅读。所以我们把”‘待办事项’项目UI实现”独立出来，方便后面的文章举例说明。</p>\n<h2 id=\"1、工程初始化\"><a href=\"#1、工程初始化\" class=\"headerlink\" title=\"1、工程初始化\"></a>1、工程初始化</h2><p>既然是作为一个基础功能，我们就将项目名称命名为”todo-base”。在任何一个目录下创建”todo-base”目录，执行如下操作:</p>\n<pre><code>&gt; cd todo-base\n# 初始化工程，按照步骤一步步填写\n&gt; npm init </code></pre>\n<p>npm init 执行完成了之后，目录下面就会有 package.json文件，该文件是什么？？<br>我们的项目中，会有源代码文件，也会有编译出来的代码文件供发布线上。在项目根目录下创建”src”和”dist”两个目录，分别放置源代码文件和编译出来的代码文件。</p>\n<pre><code>- dist\n- src\npackage.json</code></pre>\n<p>接着，我们在src目录下创建我们的第一个js文件(index.js)，一个简单的npm项目架子就完成了。</p>\n<pre><code>&#x2F;&#x2F; index.js\ndocument.write(&#39;Hello World!&#39;)</code></pre>\n<h3 id=\"1-1-让项目跑起来\"><a href=\"#1-1-让项目跑起来\" class=\"headerlink\" title=\"1.1 让项目跑起来\"></a>1.1 让项目跑起来</h3><p>既然说简单的项目已经成型，那怎样让”Hello World!”的字样能够在浏览器中显示呢？我们在dist目录下创建index.html文件，添加基础的html代码，然后引入”index.js”文件。</p>\n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html lang=&quot;en&quot;&gt;\n&lt;head&gt;\n    &lt;meta charset=&quot;UTF-8&quot; &#x2F;&gt;\n    &lt;title&gt;Document&lt;&#x2F;title&gt;\n&lt;&#x2F;head&gt;\n&lt;body&gt;\n    &lt;script src=&quot;..&#x2F;src&#x2F;index.js&quot;&gt;&lt;&#x2F;script&gt;\n&lt;&#x2F;body&gt;\n&lt;&#x2F;html&gt;</code></pre>\n<p>我们用浏览器打开index.html，就可以看到”Hello World!”的字样啦。</p>\n<p>早先的web前端开发，就是这样的方式来进行的。只不过后来逐渐有了自动化打包的工具，这些步骤都通过打包实现了。后面将会看到我们是如何使用webpack将这个过程自动化的。</p>\n<h2 id=\"2、-webpack\"><a href=\"#2、-webpack\" class=\"headerlink\" title=\"2、+ webpack\"></a>2、+ webpack</h2><p>上一节中，我们在index.html中通过script标签，引入src/index.js，引入的是源文件。源文件直接引入到html当中，有几个方面的缺点：</p>\n<ol>\n<li>需要自己通过script标签手动引入js文件，不太灵活;</li>\n<li>这样引入的js文件，不能使用一些新的ES6、ES7特性，因为有些浏览器并不支持这些特性；</li>\n<li>script引入的js文件，还需要处理缓存的问题；</li>\n<li>想要对js文件进行混淆压缩也不方便。</li>\n</ol>\n<p>一般来说，现在的前端开发都会使用像webpack、gulp等这些打包工具。本文我们使用webpack来处理js文件，并自动打包输出到dist目录中，并添加上混淆压缩的功能。</p>\n<h3 id=\"2-1-webpack简单配置\"><a href=\"#2-1-webpack简单配置\" class=\"headerlink\" title=\"2.1 webpack简单配置\"></a>2.1 webpack简单配置</h3><p>webpack中有两个基本的概念：”输入”(entry)、”输出”(output)。webpack会根据入口的配置，逐步解析各个资源文件（包括js文件、css文件、图片等）形成一个依赖图。依赖图中的每个依赖项都会被处理，然后根据出口（output）的配置输出到对应的文件中。在我们的例子中，入口文件就是index.js，输出到”dist”目录下，所以webpack简单配置如下(在项目根目录下创建webpack.config.js文件)：</p>\n<pre><code>&#x2F;&#x2F; webpack.config.js\nconst path = require(&#39;path&#39;)\nmodule.exports = {\n    entry: {\n        app: &#39;.&#x2F;src&#x2F;index&#39;, &#x2F;&#x2F; &quot;app&quot;key值可以随便定义，输出的时候就可以取这个key值为输出文件命名\n    },\n    output: {\n        path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;),\n        filename: &#39;[name].js&#39;, &#x2F;&#x2F; 这里[name]就对应entry中的‘app’key值\n    }\n}</code></pre>\n<p>当然我们要为项目添加webpack的npm包才能使用webpack来对文件进行打包处理。在命令行中输入：</p>\n<pre><code>&#x2F;&#x2F; 确保当前处于项目根目录下再输入如下命令\n&gt; npm install -D webpack webpack-cli</code></pre>\n<p>当依赖包安装完成之后，我们就可以使用webpack进行打包了，使用命令行工具，输入如下命令：</p>\n<pre><code>&#x2F;&#x2F; 确保当前处于项目根目录下再输入如下命令\n&gt; webpack</code></pre>\n<p>待webpack之行完成，我们会在dist目录下看到”app.js”文件对输出。</p>\n<p>到此我们来看看解决来本节开篇所列问题对几个？貌似一个都没有解决！我们只是使用webpack对入口文件进行了简单的打包输出。但是不要泄气，只要使用了webpack，我们再来添加一些配置，上面的问题就可以得到解决。</p>\n<h3 id=\"2-2-使用webpack来解决问题\"><a href=\"#2-2-使用webpack来解决问题\" class=\"headerlink\" title=\"2.2 使用webpack来解决问题\"></a>2.2 使用webpack来解决问题</h3><p>（1） 避免手动引入js文件&amp;解决缓存问题</p>\n<p>在前面的例子中js文件是通过script标签引入到html中使用的。而上一小节，我们通过webpack已经能将js文件打包输出。如果html文件也能通过webpack输出，那么是不是打包出来的js文件就能自动的引入到html文件中呢（毕竟webpack的输出配置是我们手动配置的）？答案是可以的。</p>\n<p>此时，我们需要了解webpack的另一个概念”plugin”。plugin是对webpack功能的增强，让webpack能够做更多的事情。要让webpack能够输出html文件，我们需要使用到”html-webpack-plugin”。</p>\n<p>首先，我们来安装“html-webpack-plugin”的npm依赖包。</p>\n<pre><code>&gt; npm install -D html-webpack-plugin</code></pre>\n<p>接着修改webpack.config.js的配置：</p>\n<pre><code>&#x2F;&#x2F; webpack.config.js\nconst path = require(&#39;path&#39;)\nconst HtmlWebpackPlugin = require(&#39;html-webpack-plugin&#39;)\nmodule.exports = {\n    entry: {\n        app: &#39;.&#x2F;src&#x2F;index&#39;, &#x2F;&#x2F; &quot;app&quot;key值可以随便定义，输出的时候就可以取这个key值为输出文件命名\n    },\n    output: {\n        path: path.resolve(__dirname, &#39;.&#x2F;dist&#39;),\n        filename: &#39;[name].[chunkhash].js&#39;, &#x2F;&#x2F; 这里[name]就对应entry中的‘app’key值\n    },\n    plugins: [\n        new HtmlWebpackPlugin()\n    ]\n}</code></pre>\n<p>如上面的配置，除了添加plugins的配置外，还对output的filename配置改成了”[name].[chunkhash].js”,这里chunkhash是基于内容的hash值，每当js源文件的内容发生改变时，chunkhash值也随之改变，这就可以解决引入js文件的缓存问题了。</p>\n<p>（2）支持es6、es7特性</p>\n<p>要让我们的代码支持es6、es7新特性。需要使用到webpack的loader功能，而能将es6、es7语法转换成浏览器支持的语法，就是”babel-loader”。要使用babel，我们需要先安装</p>\n<ul>\n<li>babel : babel库</li>\n<li>babel-loader：webpack用来加载babel的库</li>\n<li>@babel/core：babel库的核心</li>\n<li>@babel/preset-react：支持react的语法</li>\n</ul>\n<pre><code>&gt; npm insall -D babel babel-loader @babel&#x2F;core @babel&#x2F;preset-react</code></pre>\n<p>在webpack.config.js中添加配置：</p>\n<pre><code>module.exports = {\n    &#x2F;&#x2F;...\n    module: {\n        rules: [\n            {\n                test: &#x2F;\\.js$&#x2F;,\n                use: &#39;babel-loader&#39;,\n            }\n        ]\n    }\n}</code></pre>\n<p>这个配置告诉webpack，当加载js文件时，使用babel-loader进行转换。而babel-loader会调用babel来实现转换。</p>\n<p>不过上面的配置，仅仅使用了babel的核心功能，要让webpack支持更多的babel提供的功能，需要在项目根目录下创建babel的配置文件”.babelrc”。然后往这个文件里面添加如下内容：</p>\n<pre><code>&#x2F;&#x2F; .babelrc\n{\n    &quot;presets&quot;: [&quot;@babel&#x2F;preset-react&quot;]\n}</code></pre>\n<p>这个配置告诉babel调用“@babel/preset-react”来支持react的语法。</p>\n<h3 id=\"2-3-开发环境支持\"><a href=\"#2-3-开发环境支持\" class=\"headerlink\" title=\"2.3 开发环境支持\"></a>2.3 开发环境支持</h3><p>接着2.1和2.2节的配置，我们已经使用上了webpack对文件进行打包处理。但是我们在代码中是会使用到ES6、ES7的一些特性，在开发的时候，需要babel实时对代码进行编译输出才能看到开发的功能是否有问题。并且我们也不可能，开发一会，想看效果了然后webpack编译一下再用浏览器看结果，这样效率就太低了。</p>\n<p>为了能实时能看到我们开发的功能，我们需要在本地起一个web服务，然后使用webpack监控文件的变化，当文件发生变化时立即执行webpack进行代码编译输出，发布到web服务上，这样我们在浏览器访问这个web服务的地址就能实时看到结果了。而这些，都可以通过webpack的devServer配置项来实现。看下面的配置：</p>\n<pre><code>&#x2F;&#x2F; webpack.config.js\nmodule.exports = {\n    &#x2F;&#x2F; ...\n    devServer: {\n        contentBase: path.join(__dirname, &#39;dist&#39;), &#x2F;&#x2F; web服务的目录为 &quot;dist&quot; 目录\n        port: 9000 &#x2F;&#x2F; web服务端口\n    }\n}</code></pre>\n<p>配置好之后，如何启动devServer呢？首先，我们需要先安装”webpack-dev-server”这个npm包。</p>\n<pre><code>&#x2F;&#x2F; 确保当前处于项目根目录下再输入如下命令\n&gt; npm install -D webpack-dev-server</code></pre>\n<p>“webpack-dev-server”安装好之后，我们在命令行工具中输入”webpack-dev-server”即可启动服务了。</p>\n<pre><code>&#x2F;&#x2F; 确保当前处于项目根目录下再输入如下命令\n&gt; webpack-dev-server</code></pre>\n<p>web服务启动之后，在浏览器打开 “<a href=\"http://localhost:9000&quot;\" target=\"_blank\" rel=\"noopener\">http://localhost:9000&quot;</a> 就可以看到”Hello World”字样了。</p>\n<h2 id=\"3、-react\"><a href=\"#3、-react\" class=\"headerlink\" title=\"3、+ react\"></a>3、+ react</h2><p>在上一节，我们已经使用webpack将环境搭好了，接着我们就来添加react的代码。然后将”待办事项”的UI实现出来。我们先来安装react的依赖包。</p>\n<pre><code>&gt; npm install -D react react-dom</code></pre>\n<p>在index.js中加入如下代码:</p>\n<pre><code>&#x2F;&#x2F; .&#x2F;src&#x2F;index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\n\nimport App from &#39;.&#x2F;app&#39;\n\nReactDOM.render(\n    &lt;App &#x2F;&gt;, \n    document.getElementsByTagName(&#39;BODY&#39;)[0],\n)</code></pre>\n<p>index.js是入口文件，会在body标签下渲染react组件<app>。组件App的代码如下（我们先搭一个架子）：</app></p>\n<pre><code>&#x2F;&#x2F; src&#x2F;app.js\nimport React, { Component } from &#39;react&#39;;\nclass App extends Component {\n    render() {\n        return (\n            &lt;div&gt;{&#39;todo app&#39;}&lt;&#x2F;div&gt;\n        )\n    }\n}\nexport default App</code></pre>\n<h2 id=\"4、待办事项实现\"><a href=\"#4、待办事项实现\" class=\"headerlink\" title=\"4、待办事项实现\"></a>4、待办事项实现</h2><p>待办事项的UI分为三个部分：添加待办事项、待办事项列表、待办事项过滤条件。下面我们一个部分一个部分来实现，然后再组合起来。</p>\n<h3 id=\"4-1-添加待办事项UI\"><a href=\"#4-1-添加待办事项UI\" class=\"headerlink\" title=\"4.1 添加待办事项UI\"></a>4.1 添加待办事项UI</h3><p>待办事项的添加，我们只需要一个input输入框和一个添加的按钮。我們使用react的函数定义组件来实现：</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;AddTodo.js\nimport React from &#39;react&#39;;\n\nconst AddTodo = () =&gt; {\n    return (\n        &lt;div&gt;\n            &lt;input type=&quot;text&quot; &#x2F;&gt;\n            &lt;button type=&quot;button&quot;&gt;Add&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n}\n\nexport default AddTodo</code></pre>\n<h3 id=\"4-2-待办事项列表UI\"><a href=\"#4-2-待办事项列表UI\" class=\"headerlink\" title=\"4.2 待办事项列表UI\"></a>4.2 待办事项列表UI</h3><p>待办事项的列表，由列表项构成。所以这里拆分成Todo.js和TodoList.js两个文件。</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;Todo.js\nconst Todo = ({ onClick, completed, text }) =&gt; {\n    const style = {textDecoration: completed ? &#39;line-through&#39; : &#39;none&#39;}\n    return (\n    &lt;li\n        onClick={onClick}\n        style={style}\n    &gt;\n        {text}\n    &lt;&#x2F;li&gt;\n    )\n}</code></pre>\n<pre><code>&#x2F;&#x2F; src&#x2F;TodoList.js\nimport React from &#39;react&#39;\n\nimport Todo from &#39;.&#x2F;Todo&#39;\n\nconst TodoList = ({todos, onTodoClick}) =&gt; (\n    &lt;ul&gt;\n        {todos.map((todo, index) =&gt; (\n            &lt;Todo key={index} {...todo} onClick={() =&gt; { onTodoClick(index) }}&#x2F;&gt;\n        ))}\n    &lt;&#x2F;ul&gt;\n)\nexport default TodoList</code></pre>\n<h3 id=\"4-3-待办事项列表过滤\"><a href=\"#4-3-待办事项列表过滤\" class=\"headerlink\" title=\"4.3 待办事项列表过滤\"></a>4.3 待办事项列表过滤</h3><p>待办事项有”完成”、”未完成”两种状态，在显示待办事项列表的时候，默认显示所有的待办事项，也可以进行过滤。如果用户点击”Active”链接，则显示”未完成”状态的待办事项，如果用户点击”Completed”链接，则显示”完成”状态的待办事项。</p>\n<p>由于有三个链接，所以先定义链接的组件。</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;Link.js\nimport React from &#39;react&#39;\n\nconst Link = ({ active, children, onClick }) =&gt; {\n    if (active) {\n      return &lt;span&gt;{children}&lt;&#x2F;span&gt;\n    }\n    return (\n      &lt;a\n        href=&quot;&quot;\n        onClick={e =&gt; {\n          e.preventDefault()\n          onClick &amp;&amp; onClick()\n        }}\n      &gt;\n        {children}\n      &lt;&#x2F;a&gt;\n    )\n}\n\nexport default Link</code></pre>\n<p>把三个链接组合起来，我们定义一个Footer.js文件。</p>\n<pre><code>import React from &#39;react&#39;;\nimport Link from &#39;.&#x2F;Link&#39;\nconst Footer = () =&gt; (\n    &lt;p&gt;\n        Show:\n        &lt;Link active={true}&gt;ALL&lt;&#x2F;Link&gt;\n        &amp;nbsp;&amp;nbsp;\n        &lt;Link active={false}&gt;Active&lt;&#x2F;Link&gt;\n        &amp;nbsp;&amp;nbsp;\n        &lt;Link active={false}&gt;Completed&lt;&#x2F;Link&gt;\n    &lt;&#x2F;p&gt;\n)\nexport default Footer</code></pre>\n<h3 id=\"4-4-组合起来\"><a href=\"#4-4-组合起来\" class=\"headerlink\" title=\"4.4 组合起来\"></a>4.4 组合起来</h3><p>上面几个小节，把几个模块的UI组件都定义好了。我们来修改app.js文件，把各个模块组合起来。</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;app.js\nimport React, { Component } from &#39;react&#39;;\n\nimport AddTodo from &#39;.&#x2F;AddTodo&#39;\nimport TodoList from &#39;.&#x2F;TodoList&#39;\nimport Footer from &#39;.&#x2F;Footer&#39;\n\n&#x2F;&#x2F; 模拟数据\nconst data = [\n    {\n        text: &#39;001&#39;,\n        completed: false,\n    },\n    {\n        text: &#39;002&#39;,\n        completed: true,\n    },\n]\n\nclass App extends Component {\n    constructor (props) {\n        super(props)\n        this.onTodoClick = this.onTodoClick.bind(this)\n    }\n    onTodoClick (index) {\n        console.log(&#39;@@@@todo click&#39;, index)\n    }\n    render() {\n        return (\n            &lt;div&gt;\n                &lt;AddTodo &#x2F;&gt;\n                &lt;TodoList todos={data} onTodoClick={this.onTodoClick}&#x2F;&gt;\n                &lt;Footer &#x2F;&gt;\n            &lt;&#x2F;div&gt;\n        )\n    }\n}\n\nexport default App</code></pre>\n<p>具体的结构图如下：</p>\n<pre class=\"mermaid\">graph TD;\n    TodoApp-->AddTodo.js;\n    TodoApp-->TodoList.js;\n    TodoList.js-->Todo.js-1;\n    TodoList.js-->Todo.js...;\n    TodoApp-->Footer.js;\n    Footer.js-->Link.js-1;\n    Footer.js-->Link.js-2;\n    Footer.js-->Link.js-3;</pre>\n\n<h1 id=\"5-结语\"><a href=\"#5-结语\" class=\"headerlink\" title=\"5 结语\"></a>5 结语</h1><p>本文具体的代码可查看 <a href=\"https://github.com/Two-Ftry/react-essay/tree/master/redux-02\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<p>现在的前端项目搭建，已经会涉及到很多知识。从本文可以看到，开发一个简单的UI，从项目搭建开始，我们使用到了npm来初始化项目，然后使用webpack来搭建环境，接着再组合react。而在webpack中，我们也会涉及到额外的npm包，如html-webpack-plugin、babel、babel-loader。丰富的工具让我们的开发变得简单高效，但是也增加了我们学习的成本。逐步积累，是不断进步的必经之路。</p>\n"},{"title":"redux(四)-异步Action","date":"2018-12-29T17:48:02.000Z","_content":"\n使用js做前端开发，异步是我们经常会遇到的场景。最常见的，就是我们在调取后台数据的时候发送的异步请求。我们使用原生js来温习一下。\n\n{% codeblock %}\nconst xhr = new XMLHttpRequest()\n\nxhr.onreadystatechange = function () {\n    if (xhr.readyState === 4) {\n        if (xhr.status >= 200 && xhr.status <= 300 || xhr.status === 304) {\n            console.log(xhr.responseText)\n        } else {\n            console.log(`Request was unsuccessful: ${xhr.responseText}`)\n        }\n    }\n}\n\nxhr.open('get', 'url', true)\nxhr.send(null)\n\n{% endcodeblock %}\n\n在这一小段代码里面，我们先创建一个XMLHttpRequest对象，然后使用onreadystatechange属性的回调函数来监听状态变化。接着使用open()函数建立链接，最后使用send()函数发送数据到url对应的地址。这是一段异步代码，当send()函数执行之后，代码会继续往下执行，等到url对应地址的响应数据返回之后，才会执行onreadystatechange回调函数。\n\n针对这个场景，有三个关键的时刻：发起请求、接收到响应（成功或者失败，也可能会超时）。在不考虑太多的情况下，我们只需要在接收到成功响应的情况下，把返回的数据通过dispatch()传递到redux的state中，这样就把数据保存了起来。我们把ajax请求单独写在services.js文件中，所以代码看起来会是这样的：\n\n{% codeblock %}\n// services.js\nexport const getTodos = () => {\n    return new Promise((resolve, reject) => {\n        const xhr = new XMLHttpRequest()\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState === 4) {\n                if (xhr.status >= 200 && xhr.status <= 300 || xhr.status === 304) {\n                    console.log(xhr.responseText)\n                    resolve(JSON.parse(xhr.responseText))\n                } else {\n                    console.log(`Request was unsuccessful: ${xhr.responseText}`)\n                    reject(xhr.responseText)\n                }\n            }\n        }\n        xhr.open('get', '/getTodos', true)\n        xhr.send(null)\n    })\n}\n{% endcodeblock %}\n再在请求回来后dispatch到redux中。\n{% codeblock %}\n// 使用示意\nconst { getTodos } from './services.js'\ngetTodos().then((data) => {\n    dispatch(initTodos(data.list))\n}, (err) => {\n    console.log('@@@fail', err)\n})\n{% endcodeblock %}\n\n我们的案例是以\"待办事项\"为例子，并没有后台接口与之对应，所以在继续往下学习之前，我们需要考虑如何通过接口来拿到数据。正常的项目开发中，会有后台的小伙伴给我们提供接口。现在我们没有后台的小伙伴那该怎么办？这个场景，就要考虑到mockjs了。\n\n# 1、 mockjs\n\nmockjs的{% link 官网 http://mockjs.com %}的介绍很简单——\"生成随机数据，拦截Ajax请求\"。但是这个中文介绍的前后顺序貌似有点问题，正常的顺序应该是\"拦截Ajax请求，生产随机数据\"。也就是说，使用mockjs可以拦截我们写的ajax请求，然后生成随机的数据返回给ajax。\n\n在mockjs中，可以使用Mock.mock()这个方法来设置拦截哪个url，以及设置返回什么数据。\n\n当然我们先要使用命令行来安装mockjs依赖包。\n{% codeblock %}\n> npm install -D mockjs\n{% endcodeblock %}\n\n接着添加如下代码：\n\n{% codeblock %}\n// mock.js\nimport Mock from 'mockjs'\n\nMock.mock('/getTodos', {\n    'list|1-5': [{\n        'text': 'todo-item',\n        'completed|1': true,\n    }]\n})\n{% endcodeblock %}\n\n上述代码，Mock.mock()方法会拦截\"/getTodos\"请求，然后返回一个object对象，object对象包含一个list属性，list数组包含5个元素，每个元素的text属性为“todo-item”，completed属性为随机的boolean值。\n\n{% codeblock %}\n{\n    list: [\n        {\n            text: 'todo-item',\n            completed: true,\n        },\n        // ...\n    ]\n}\n{% endcodeblock %}\n\n最后别忘了在入口文件(index.js)中引入mock.js\n\n{% codeblock %}\n// src/index.js\n// ...\nimport './mock'\n// ...\n{% endcodeblock %}\n\n# 2、添加完整代码\n\n我们要处理一个不一样的action，那么有两个步骤需要完成：\n\n1. 添加action\n2. 添加reducer\n\n在actions.js文件中添加type为'INIT_TODOS'的action。\n\n{% codeblock %}\n// actions.js\n// 初始化todos\nexport function initTodos (list) {\n  return {\n    type: 'INIT_TODOS',\n    list,\n  }\n}\n{% endcodeblock %}\n\n然后在reducers.js文件中处理这个action，对应用状态的todos进行初始化。\n\n{% codeblock %}\n// 待办事项列表reducer\nfunction todos(state = [], action) {\n    switch (action.type) {\n        // ...\n        // 初始化 todos\n        case 'INIT_TODOS':\n            return [...state, ...action.list]\n        break\n        // ...\n    }\n}\n{% endcodeblock %}\n\n到此我们就处理了异步加载数据并将数据添加到redux的场景。这和普通的action没有任何区别。\n\n# 3、加一个loading\n\n假如要在请求发送到请求返回的这个时间段，添加一个loading效果。常规的做法，在执行getTodos()之前，先dispatch一个类型为'LOADING'的action到redux中（如设置loading为true），到请求返回后，处理将返回数据添加到redux，同时也需要将loading的标记设置为false。\n\n{% codeblock %}\n// 示意代码\ndispatch({\n    type: 'LOADING',\n    loading: true,\n})\ngetTodos().then((data) => {\n    dispatch(initTodos(data.list))\n    dispatch({\n        type: 'LOADING',\n        loading: false,\n    })\n}, (err) => {\n    console.log('@@@fail', err)\n    dispatch({\n        type: 'LOADING',\n        loading: false,\n    })\n})\n{% endcodeblock %}\n\n这是完全可行的。但是这段属于redux的代码写到业务组件里面，代码就耦合了。解耦的方式，可以这段代码都整合到actions.js中来进行。简单的，我们进行代码抽取就可以实现。我们抽取一个dispatchInitTodos()方法来实现。\n\n{% codeblock %}\n// actions.js\nimport { getTodos } from './services.js'\n// ...\nexport function setLoading(loading) {\n  return {\n    type: 'SET_LOADING',\n    loading,\n  }\n}\n\n// 初始化todos\nexport function initTodos(list) {\n  return {\n    type: 'INIT_TODOS',\n    list,\n  }\n}\n\nexport function dispatchInitTodos(dispatch) {\n  dispatch(setLoading(true))\n  getTodos().then((data) => {\n    dispatch(initTodos(data.list))\n    dispatch(setLoading(false))\n  }, (err) => {\n    console.log('@@@fail', err)\n    dispatch(setLoading(false))\n  })\n}\n{% endcodeblock %}\n\n然后app.js中引入dispatchInitTodos()来执行。\n\n{% codeblock %}\nimport { toggleTodo, initTodos, dispatchInitTodos } from './actions'\n\nclass App extends Component {\n    // ...\n    componentDidMount () {\n        const { dispatch } = this.props\n        dispatchInitTodos(dispatch)\n    }\n    // ...\n}\n{% endcodeblock %}\n\n对此，我们还需要在reducers里面添加一个loading属性。\n\n{% codeblock %}\n// reducers.js\n// ...\nfunction loading (state=false, action) {\n    switch(action.type) {\n        case 'SET_LOADING':\n            return !!action.loading\n        break\n        default:\n            return state\n    }\n}\n\nconst rootReducer = combineReducers({\n    visibilityFilter,\n    todos,\n    loading,\n})\n// ...\n{% endcodeblock %}\n\n上面只是一些代码的片段，并不完整。完整代码请查看 {% link redux-04 https://github.com/Two-Ftry/react-essay/tree/master/redux-04 %}。\n\n针对异步的场景，我们上面做了简单的封装。实际上，redux针对异步的场景有很多中间件(即middleware)可以使用，不需要我们手动来封装。\n\n# 4、redux-thunk中间件\n\nredux的dispatch()方法自身的功能极其简单，它只能dispatch一个Object对象。但是redux提供的中间件方式，可以极大的扩展dispatch的功能。redux-chunk就是一个可以dispatch()一个function的中间件。redux提供了applyMiddleware(...middlewares)方法来添加中间件。\n\n使用命令行，先添加redux-thunk依赖包。\n{% codeblock %}\n> npm install -D redux-thunk\n{% endcodeblock %}\n\n然后在createStore的时候将中间件redux-thunk加入到redux中。\n{% codeblock %}\n// index.js\n// ...\nimport { createStore, applyMiddleware } from 'redux'\nimport reduxThunk from 'redux-thunk'\nimport rootReducer from './reducers.js'\nconst store = createStore(rootReducer, applyMiddleware(reduxThunk))\n\n// ...\n{% endcodeblock %}\n\n使用redux-thunk可以dispatch一个function，这个function接收一个dispatch参数(由redux-thunk传入)。所以修改action如下。\n\n{% codeblock %}\n// actions.js\n// ...\nexport function dispatchInitTodos() {\n  return (dispatch) => {\n    dispatch(setLoading(true))\n    getTodos().then((data) => {\n      dispatch(initTodos(data.list))\n      dispatch(setLoading(false))\n    }, (err) => {\n      console.log('@@@fail', err)\n      dispatch(setLoading(false))\n    })\n  }\n}\n{% endcodeblock %}\n\n在app.js中使用。\n\n{% codeblock %}\n// app.js\n// ...\nimport { toggleTodo, initTodos, dispatchInitTodos } from './actions'\n\nclass App extends Component {\n    // ...\n    componentDidMount () {\n        const { dispatch } = this.props\n        dispatch(dispatchInitTodos())\n    }\n    // ...\n}\n// ...\n{% endcodeblock %}\n\n如此，redux-thunk就使用起来了。\n\n除了redux-thunk，还有其他的处理异步场景的中间件。\n\n1. redux-promise:  dispatch Promise。\n2. redux-saga：创建更加复杂的异步 action。\n3. ...\n\n这些中间件要不要学习？感觉一口气学完会蛮吃力的，是不是我会redux-thunk就可以了？现在搭建出来的项目一般不会单纯地使用redux-thunk这种简单的中间件，所以是要掌握的。不过redux-promise可以放一放，因为这个中间件是FSA兼容redux的一个中间件。redux-saga得花些时间去掌握。本章篇幅有限，先到此打住了。\n\n本章完整的代码请查看 {% link redux-05 https://github.com/Two-Ftry/react-essay/tree/master/redux-05 %} 。","source":"_posts/redux4-asyncAction-20181230.md","raw":"---\ntitle: redux(四)-异步Action\ndate: 2018-12-30 01:48:02\ntags: redux mockjs\n---\n\n使用js做前端开发，异步是我们经常会遇到的场景。最常见的，就是我们在调取后台数据的时候发送的异步请求。我们使用原生js来温习一下。\n\n{% codeblock %}\nconst xhr = new XMLHttpRequest()\n\nxhr.onreadystatechange = function () {\n    if (xhr.readyState === 4) {\n        if (xhr.status >= 200 && xhr.status <= 300 || xhr.status === 304) {\n            console.log(xhr.responseText)\n        } else {\n            console.log(`Request was unsuccessful: ${xhr.responseText}`)\n        }\n    }\n}\n\nxhr.open('get', 'url', true)\nxhr.send(null)\n\n{% endcodeblock %}\n\n在这一小段代码里面，我们先创建一个XMLHttpRequest对象，然后使用onreadystatechange属性的回调函数来监听状态变化。接着使用open()函数建立链接，最后使用send()函数发送数据到url对应的地址。这是一段异步代码，当send()函数执行之后，代码会继续往下执行，等到url对应地址的响应数据返回之后，才会执行onreadystatechange回调函数。\n\n针对这个场景，有三个关键的时刻：发起请求、接收到响应（成功或者失败，也可能会超时）。在不考虑太多的情况下，我们只需要在接收到成功响应的情况下，把返回的数据通过dispatch()传递到redux的state中，这样就把数据保存了起来。我们把ajax请求单独写在services.js文件中，所以代码看起来会是这样的：\n\n{% codeblock %}\n// services.js\nexport const getTodos = () => {\n    return new Promise((resolve, reject) => {\n        const xhr = new XMLHttpRequest()\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState === 4) {\n                if (xhr.status >= 200 && xhr.status <= 300 || xhr.status === 304) {\n                    console.log(xhr.responseText)\n                    resolve(JSON.parse(xhr.responseText))\n                } else {\n                    console.log(`Request was unsuccessful: ${xhr.responseText}`)\n                    reject(xhr.responseText)\n                }\n            }\n        }\n        xhr.open('get', '/getTodos', true)\n        xhr.send(null)\n    })\n}\n{% endcodeblock %}\n再在请求回来后dispatch到redux中。\n{% codeblock %}\n// 使用示意\nconst { getTodos } from './services.js'\ngetTodos().then((data) => {\n    dispatch(initTodos(data.list))\n}, (err) => {\n    console.log('@@@fail', err)\n})\n{% endcodeblock %}\n\n我们的案例是以\"待办事项\"为例子，并没有后台接口与之对应，所以在继续往下学习之前，我们需要考虑如何通过接口来拿到数据。正常的项目开发中，会有后台的小伙伴给我们提供接口。现在我们没有后台的小伙伴那该怎么办？这个场景，就要考虑到mockjs了。\n\n# 1、 mockjs\n\nmockjs的{% link 官网 http://mockjs.com %}的介绍很简单——\"生成随机数据，拦截Ajax请求\"。但是这个中文介绍的前后顺序貌似有点问题，正常的顺序应该是\"拦截Ajax请求，生产随机数据\"。也就是说，使用mockjs可以拦截我们写的ajax请求，然后生成随机的数据返回给ajax。\n\n在mockjs中，可以使用Mock.mock()这个方法来设置拦截哪个url，以及设置返回什么数据。\n\n当然我们先要使用命令行来安装mockjs依赖包。\n{% codeblock %}\n> npm install -D mockjs\n{% endcodeblock %}\n\n接着添加如下代码：\n\n{% codeblock %}\n// mock.js\nimport Mock from 'mockjs'\n\nMock.mock('/getTodos', {\n    'list|1-5': [{\n        'text': 'todo-item',\n        'completed|1': true,\n    }]\n})\n{% endcodeblock %}\n\n上述代码，Mock.mock()方法会拦截\"/getTodos\"请求，然后返回一个object对象，object对象包含一个list属性，list数组包含5个元素，每个元素的text属性为“todo-item”，completed属性为随机的boolean值。\n\n{% codeblock %}\n{\n    list: [\n        {\n            text: 'todo-item',\n            completed: true,\n        },\n        // ...\n    ]\n}\n{% endcodeblock %}\n\n最后别忘了在入口文件(index.js)中引入mock.js\n\n{% codeblock %}\n// src/index.js\n// ...\nimport './mock'\n// ...\n{% endcodeblock %}\n\n# 2、添加完整代码\n\n我们要处理一个不一样的action，那么有两个步骤需要完成：\n\n1. 添加action\n2. 添加reducer\n\n在actions.js文件中添加type为'INIT_TODOS'的action。\n\n{% codeblock %}\n// actions.js\n// 初始化todos\nexport function initTodos (list) {\n  return {\n    type: 'INIT_TODOS',\n    list,\n  }\n}\n{% endcodeblock %}\n\n然后在reducers.js文件中处理这个action，对应用状态的todos进行初始化。\n\n{% codeblock %}\n// 待办事项列表reducer\nfunction todos(state = [], action) {\n    switch (action.type) {\n        // ...\n        // 初始化 todos\n        case 'INIT_TODOS':\n            return [...state, ...action.list]\n        break\n        // ...\n    }\n}\n{% endcodeblock %}\n\n到此我们就处理了异步加载数据并将数据添加到redux的场景。这和普通的action没有任何区别。\n\n# 3、加一个loading\n\n假如要在请求发送到请求返回的这个时间段，添加一个loading效果。常规的做法，在执行getTodos()之前，先dispatch一个类型为'LOADING'的action到redux中（如设置loading为true），到请求返回后，处理将返回数据添加到redux，同时也需要将loading的标记设置为false。\n\n{% codeblock %}\n// 示意代码\ndispatch({\n    type: 'LOADING',\n    loading: true,\n})\ngetTodos().then((data) => {\n    dispatch(initTodos(data.list))\n    dispatch({\n        type: 'LOADING',\n        loading: false,\n    })\n}, (err) => {\n    console.log('@@@fail', err)\n    dispatch({\n        type: 'LOADING',\n        loading: false,\n    })\n})\n{% endcodeblock %}\n\n这是完全可行的。但是这段属于redux的代码写到业务组件里面，代码就耦合了。解耦的方式，可以这段代码都整合到actions.js中来进行。简单的，我们进行代码抽取就可以实现。我们抽取一个dispatchInitTodos()方法来实现。\n\n{% codeblock %}\n// actions.js\nimport { getTodos } from './services.js'\n// ...\nexport function setLoading(loading) {\n  return {\n    type: 'SET_LOADING',\n    loading,\n  }\n}\n\n// 初始化todos\nexport function initTodos(list) {\n  return {\n    type: 'INIT_TODOS',\n    list,\n  }\n}\n\nexport function dispatchInitTodos(dispatch) {\n  dispatch(setLoading(true))\n  getTodos().then((data) => {\n    dispatch(initTodos(data.list))\n    dispatch(setLoading(false))\n  }, (err) => {\n    console.log('@@@fail', err)\n    dispatch(setLoading(false))\n  })\n}\n{% endcodeblock %}\n\n然后app.js中引入dispatchInitTodos()来执行。\n\n{% codeblock %}\nimport { toggleTodo, initTodos, dispatchInitTodos } from './actions'\n\nclass App extends Component {\n    // ...\n    componentDidMount () {\n        const { dispatch } = this.props\n        dispatchInitTodos(dispatch)\n    }\n    // ...\n}\n{% endcodeblock %}\n\n对此，我们还需要在reducers里面添加一个loading属性。\n\n{% codeblock %}\n// reducers.js\n// ...\nfunction loading (state=false, action) {\n    switch(action.type) {\n        case 'SET_LOADING':\n            return !!action.loading\n        break\n        default:\n            return state\n    }\n}\n\nconst rootReducer = combineReducers({\n    visibilityFilter,\n    todos,\n    loading,\n})\n// ...\n{% endcodeblock %}\n\n上面只是一些代码的片段，并不完整。完整代码请查看 {% link redux-04 https://github.com/Two-Ftry/react-essay/tree/master/redux-04 %}。\n\n针对异步的场景，我们上面做了简单的封装。实际上，redux针对异步的场景有很多中间件(即middleware)可以使用，不需要我们手动来封装。\n\n# 4、redux-thunk中间件\n\nredux的dispatch()方法自身的功能极其简单，它只能dispatch一个Object对象。但是redux提供的中间件方式，可以极大的扩展dispatch的功能。redux-chunk就是一个可以dispatch()一个function的中间件。redux提供了applyMiddleware(...middlewares)方法来添加中间件。\n\n使用命令行，先添加redux-thunk依赖包。\n{% codeblock %}\n> npm install -D redux-thunk\n{% endcodeblock %}\n\n然后在createStore的时候将中间件redux-thunk加入到redux中。\n{% codeblock %}\n// index.js\n// ...\nimport { createStore, applyMiddleware } from 'redux'\nimport reduxThunk from 'redux-thunk'\nimport rootReducer from './reducers.js'\nconst store = createStore(rootReducer, applyMiddleware(reduxThunk))\n\n// ...\n{% endcodeblock %}\n\n使用redux-thunk可以dispatch一个function，这个function接收一个dispatch参数(由redux-thunk传入)。所以修改action如下。\n\n{% codeblock %}\n// actions.js\n// ...\nexport function dispatchInitTodos() {\n  return (dispatch) => {\n    dispatch(setLoading(true))\n    getTodos().then((data) => {\n      dispatch(initTodos(data.list))\n      dispatch(setLoading(false))\n    }, (err) => {\n      console.log('@@@fail', err)\n      dispatch(setLoading(false))\n    })\n  }\n}\n{% endcodeblock %}\n\n在app.js中使用。\n\n{% codeblock %}\n// app.js\n// ...\nimport { toggleTodo, initTodos, dispatchInitTodos } from './actions'\n\nclass App extends Component {\n    // ...\n    componentDidMount () {\n        const { dispatch } = this.props\n        dispatch(dispatchInitTodos())\n    }\n    // ...\n}\n// ...\n{% endcodeblock %}\n\n如此，redux-thunk就使用起来了。\n\n除了redux-thunk，还有其他的处理异步场景的中间件。\n\n1. redux-promise:  dispatch Promise。\n2. redux-saga：创建更加复杂的异步 action。\n3. ...\n\n这些中间件要不要学习？感觉一口气学完会蛮吃力的，是不是我会redux-thunk就可以了？现在搭建出来的项目一般不会单纯地使用redux-thunk这种简单的中间件，所以是要掌握的。不过redux-promise可以放一放，因为这个中间件是FSA兼容redux的一个中间件。redux-saga得花些时间去掌握。本章篇幅有限，先到此打住了。\n\n本章完整的代码请查看 {% link redux-05 https://github.com/Two-Ftry/react-essay/tree/master/redux-05 %} 。","slug":"redux4-asyncAction","published":1,"updated":"2019-01-10T02:58:56.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvoq3001m4c41hc2rz1c1","content":"<p>使用js做前端开发，异步是我们经常会遇到的场景。最常见的，就是我们在调取后台数据的时候发送的异步请求。我们使用原生js来温习一下。</p>\n<pre><code>const xhr = new XMLHttpRequest()\n\nxhr.onreadystatechange = function () {\n    if (xhr.readyState === 4) {\n        if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;= 300 || xhr.status === 304) {\n            console.log(xhr.responseText)\n        } else {\n            console.log(`Request was unsuccessful: ${xhr.responseText}`)\n        }\n    }\n}\n\nxhr.open(&#39;get&#39;, &#39;url&#39;, true)\nxhr.send(null)\n</code></pre>\n<p>在这一小段代码里面，我们先创建一个XMLHttpRequest对象，然后使用onreadystatechange属性的回调函数来监听状态变化。接着使用open()函数建立链接，最后使用send()函数发送数据到url对应的地址。这是一段异步代码，当send()函数执行之后，代码会继续往下执行，等到url对应地址的响应数据返回之后，才会执行onreadystatechange回调函数。</p>\n<p>针对这个场景，有三个关键的时刻：发起请求、接收到响应（成功或者失败，也可能会超时）。在不考虑太多的情况下，我们只需要在接收到成功响应的情况下，把返回的数据通过dispatch()传递到redux的state中，这样就把数据保存了起来。我们把ajax请求单独写在services.js文件中，所以代码看起来会是这样的：</p>\n<pre><code>&#x2F;&#x2F; services.js\nexport const getTodos = () =&gt; {\n    return new Promise((resolve, reject) =&gt; {\n        const xhr = new XMLHttpRequest()\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState === 4) {\n                if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;= 300 || xhr.status === 304) {\n                    console.log(xhr.responseText)\n                    resolve(JSON.parse(xhr.responseText))\n                } else {\n                    console.log(`Request was unsuccessful: ${xhr.responseText}`)\n                    reject(xhr.responseText)\n                }\n            }\n        }\n        xhr.open(&#39;get&#39;, &#39;&#x2F;getTodos&#39;, true)\n        xhr.send(null)\n    })\n}</code></pre>\n<p>再在请求回来后dispatch到redux中。<br><pre><code>&#x2F;&#x2F; 使用示意\nconst { getTodos } from &#39;.&#x2F;services.js&#39;\ngetTodos().then((data) =&gt; {\n    dispatch(initTodos(data.list))\n}, (err) =&gt; {\n    console.log(&#39;@@@fail&#39;, err)\n})</code></pre></p>\n<p>我们的案例是以”待办事项”为例子，并没有后台接口与之对应，所以在继续往下学习之前，我们需要考虑如何通过接口来拿到数据。正常的项目开发中，会有后台的小伙伴给我们提供接口。现在我们没有后台的小伙伴那该怎么办？这个场景，就要考虑到mockjs了。</p>\n<h1 id=\"1、-mockjs\"><a href=\"#1、-mockjs\" class=\"headerlink\" title=\"1、 mockjs\"></a>1、 mockjs</h1><p>mockjs的<a href=\"http://mockjs.com\" target=\"_blank\" rel=\"noopener\">官网</a>的介绍很简单——“生成随机数据，拦截Ajax请求”。但是这个中文介绍的前后顺序貌似有点问题，正常的顺序应该是”拦截Ajax请求，生产随机数据”。也就是说，使用mockjs可以拦截我们写的ajax请求，然后生成随机的数据返回给ajax。</p>\n<p>在mockjs中，可以使用Mock.mock()这个方法来设置拦截哪个url，以及设置返回什么数据。</p>\n<p>当然我们先要使用命令行来安装mockjs依赖包。<br><pre><code>&gt; npm install -D mockjs</code></pre></p>\n<p>接着添加如下代码：</p>\n<pre><code>&#x2F;&#x2F; mock.js\nimport Mock from &#39;mockjs&#39;\n\nMock.mock(&#39;&#x2F;getTodos&#39;, {\n    &#39;list|1-5&#39;: [{\n        &#39;text&#39;: &#39;todo-item&#39;,\n        &#39;completed|1&#39;: true,\n    }]\n})</code></pre>\n<p>上述代码，Mock.mock()方法会拦截”/getTodos”请求，然后返回一个object对象，object对象包含一个list属性，list数组包含5个元素，每个元素的text属性为“todo-item”，completed属性为随机的boolean值。</p>\n<pre><code>{\n    list: [\n        {\n            text: &#39;todo-item&#39;,\n            completed: true,\n        },\n        &#x2F;&#x2F; ...\n    ]\n}</code></pre>\n<p>最后别忘了在入口文件(index.js)中引入mock.js</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;index.js\n&#x2F;&#x2F; ...\nimport &#39;.&#x2F;mock&#39;\n&#x2F;&#x2F; ...</code></pre>\n<h1 id=\"2、添加完整代码\"><a href=\"#2、添加完整代码\" class=\"headerlink\" title=\"2、添加完整代码\"></a>2、添加完整代码</h1><p>我们要处理一个不一样的action，那么有两个步骤需要完成：</p>\n<ol>\n<li>添加action</li>\n<li>添加reducer</li>\n</ol>\n<p>在actions.js文件中添加type为’INIT_TODOS’的action。</p>\n<pre><code>&#x2F;&#x2F; actions.js\n&#x2F;&#x2F; 初始化todos\nexport function initTodos (list) {\n  return {\n    type: &#39;INIT_TODOS&#39;,\n    list,\n  }\n}</code></pre>\n<p>然后在reducers.js文件中处理这个action，对应用状态的todos进行初始化。</p>\n<pre><code>&#x2F;&#x2F; 待办事项列表reducer\nfunction todos(state = [], action) {\n    switch (action.type) {\n        &#x2F;&#x2F; ...\n        &#x2F;&#x2F; 初始化 todos\n        case &#39;INIT_TODOS&#39;:\n            return [...state, ...action.list]\n        break\n        &#x2F;&#x2F; ...\n    }\n}</code></pre>\n<p>到此我们就处理了异步加载数据并将数据添加到redux的场景。这和普通的action没有任何区别。</p>\n<h1 id=\"3、加一个loading\"><a href=\"#3、加一个loading\" class=\"headerlink\" title=\"3、加一个loading\"></a>3、加一个loading</h1><p>假如要在请求发送到请求返回的这个时间段，添加一个loading效果。常规的做法，在执行getTodos()之前，先dispatch一个类型为’LOADING’的action到redux中（如设置loading为true），到请求返回后，处理将返回数据添加到redux，同时也需要将loading的标记设置为false。</p>\n<pre><code>&#x2F;&#x2F; 示意代码\ndispatch({\n    type: &#39;LOADING&#39;,\n    loading: true,\n})\ngetTodos().then((data) =&gt; {\n    dispatch(initTodos(data.list))\n    dispatch({\n        type: &#39;LOADING&#39;,\n        loading: false,\n    })\n}, (err) =&gt; {\n    console.log(&#39;@@@fail&#39;, err)\n    dispatch({\n        type: &#39;LOADING&#39;,\n        loading: false,\n    })\n})</code></pre>\n<p>这是完全可行的。但是这段属于redux的代码写到业务组件里面，代码就耦合了。解耦的方式，可以这段代码都整合到actions.js中来进行。简单的，我们进行代码抽取就可以实现。我们抽取一个dispatchInitTodos()方法来实现。</p>\n<pre><code>&#x2F;&#x2F; actions.js\nimport { getTodos } from &#39;.&#x2F;services.js&#39;\n&#x2F;&#x2F; ...\nexport function setLoading(loading) {\n  return {\n    type: &#39;SET_LOADING&#39;,\n    loading,\n  }\n}\n\n&#x2F;&#x2F; 初始化todos\nexport function initTodos(list) {\n  return {\n    type: &#39;INIT_TODOS&#39;,\n    list,\n  }\n}\n\nexport function dispatchInitTodos(dispatch) {\n  dispatch(setLoading(true))\n  getTodos().then((data) =&gt; {\n    dispatch(initTodos(data.list))\n    dispatch(setLoading(false))\n  }, (err) =&gt; {\n    console.log(&#39;@@@fail&#39;, err)\n    dispatch(setLoading(false))\n  })\n}</code></pre>\n<p>然后app.js中引入dispatchInitTodos()来执行。</p>\n<pre><code>import { toggleTodo, initTodos, dispatchInitTodos } from &#39;.&#x2F;actions&#39;\n\nclass App extends Component {\n    &#x2F;&#x2F; ...\n    componentDidMount () {\n        const { dispatch } = this.props\n        dispatchInitTodos(dispatch)\n    }\n    &#x2F;&#x2F; ...\n}</code></pre>\n<p>对此，我们还需要在reducers里面添加一个loading属性。</p>\n<pre><code>&#x2F;&#x2F; reducers.js\n&#x2F;&#x2F; ...\nfunction loading (state=false, action) {\n    switch(action.type) {\n        case &#39;SET_LOADING&#39;:\n            return !!action.loading\n        break\n        default:\n            return state\n    }\n}\n\nconst rootReducer = combineReducers({\n    visibilityFilter,\n    todos,\n    loading,\n})\n&#x2F;&#x2F; ...</code></pre>\n<p>上面只是一些代码的片段，并不完整。完整代码请查看 <a href=\"https://github.com/Two-Ftry/react-essay/tree/master/redux-04\" target=\"_blank\" rel=\"noopener\">redux-04</a>。</p>\n<p>针对异步的场景，我们上面做了简单的封装。实际上，redux针对异步的场景有很多中间件(即middleware)可以使用，不需要我们手动来封装。</p>\n<h1 id=\"4、redux-thunk中间件\"><a href=\"#4、redux-thunk中间件\" class=\"headerlink\" title=\"4、redux-thunk中间件\"></a>4、redux-thunk中间件</h1><p>redux的dispatch()方法自身的功能极其简单，它只能dispatch一个Object对象。但是redux提供的中间件方式，可以极大的扩展dispatch的功能。redux-chunk就是一个可以dispatch()一个function的中间件。redux提供了applyMiddleware(…middlewares)方法来添加中间件。</p>\n<p>使用命令行，先添加redux-thunk依赖包。<br><pre><code>&gt; npm install -D redux-thunk</code></pre></p>\n<p>然后在createStore的时候将中间件redux-thunk加入到redux中。<br><pre><code>&#x2F;&#x2F; index.js\n&#x2F;&#x2F; ...\nimport { createStore, applyMiddleware } from &#39;redux&#39;\nimport reduxThunk from &#39;redux-thunk&#39;\nimport rootReducer from &#39;.&#x2F;reducers.js&#39;\nconst store = createStore(rootReducer, applyMiddleware(reduxThunk))\n\n&#x2F;&#x2F; ...</code></pre></p>\n<p>使用redux-thunk可以dispatch一个function，这个function接收一个dispatch参数(由redux-thunk传入)。所以修改action如下。</p>\n<pre><code>&#x2F;&#x2F; actions.js\n&#x2F;&#x2F; ...\nexport function dispatchInitTodos() {\n  return (dispatch) =&gt; {\n    dispatch(setLoading(true))\n    getTodos().then((data) =&gt; {\n      dispatch(initTodos(data.list))\n      dispatch(setLoading(false))\n    }, (err) =&gt; {\n      console.log(&#39;@@@fail&#39;, err)\n      dispatch(setLoading(false))\n    })\n  }\n}</code></pre>\n<p>在app.js中使用。</p>\n<pre><code>&#x2F;&#x2F; app.js\n&#x2F;&#x2F; ...\nimport { toggleTodo, initTodos, dispatchInitTodos } from &#39;.&#x2F;actions&#39;\n\nclass App extends Component {\n    &#x2F;&#x2F; ...\n    componentDidMount () {\n        const { dispatch } = this.props\n        dispatch(dispatchInitTodos())\n    }\n    &#x2F;&#x2F; ...\n}\n&#x2F;&#x2F; ...</code></pre>\n<p>如此，redux-thunk就使用起来了。</p>\n<p>除了redux-thunk，还有其他的处理异步场景的中间件。</p>\n<ol>\n<li>redux-promise:  dispatch Promise。</li>\n<li>redux-saga：创建更加复杂的异步 action。</li>\n<li>…</li>\n</ol>\n<p>这些中间件要不要学习？感觉一口气学完会蛮吃力的，是不是我会redux-thunk就可以了？现在搭建出来的项目一般不会单纯地使用redux-thunk这种简单的中间件，所以是要掌握的。不过redux-promise可以放一放，因为这个中间件是FSA兼容redux的一个中间件。redux-saga得花些时间去掌握。本章篇幅有限，先到此打住了。</p>\n<p>本章完整的代码请查看 <a href=\"https://github.com/Two-Ftry/react-essay/tree/master/redux-05\" target=\"_blank\" rel=\"noopener\">redux-05</a> 。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>使用js做前端开发，异步是我们经常会遇到的场景。最常见的，就是我们在调取后台数据的时候发送的异步请求。我们使用原生js来温习一下。</p>\n<pre><code>const xhr = new XMLHttpRequest()\n\nxhr.onreadystatechange = function () {\n    if (xhr.readyState === 4) {\n        if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;= 300 || xhr.status === 304) {\n            console.log(xhr.responseText)\n        } else {\n            console.log(`Request was unsuccessful: ${xhr.responseText}`)\n        }\n    }\n}\n\nxhr.open(&#39;get&#39;, &#39;url&#39;, true)\nxhr.send(null)\n</code></pre>\n<p>在这一小段代码里面，我们先创建一个XMLHttpRequest对象，然后使用onreadystatechange属性的回调函数来监听状态变化。接着使用open()函数建立链接，最后使用send()函数发送数据到url对应的地址。这是一段异步代码，当send()函数执行之后，代码会继续往下执行，等到url对应地址的响应数据返回之后，才会执行onreadystatechange回调函数。</p>\n<p>针对这个场景，有三个关键的时刻：发起请求、接收到响应（成功或者失败，也可能会超时）。在不考虑太多的情况下，我们只需要在接收到成功响应的情况下，把返回的数据通过dispatch()传递到redux的state中，这样就把数据保存了起来。我们把ajax请求单独写在services.js文件中，所以代码看起来会是这样的：</p>\n<pre><code>&#x2F;&#x2F; services.js\nexport const getTodos = () =&gt; {\n    return new Promise((resolve, reject) =&gt; {\n        const xhr = new XMLHttpRequest()\n        xhr.onreadystatechange = function () {\n            if (xhr.readyState === 4) {\n                if (xhr.status &gt;= 200 &amp;&amp; xhr.status &lt;= 300 || xhr.status === 304) {\n                    console.log(xhr.responseText)\n                    resolve(JSON.parse(xhr.responseText))\n                } else {\n                    console.log(`Request was unsuccessful: ${xhr.responseText}`)\n                    reject(xhr.responseText)\n                }\n            }\n        }\n        xhr.open(&#39;get&#39;, &#39;&#x2F;getTodos&#39;, true)\n        xhr.send(null)\n    })\n}</code></pre>\n<p>再在请求回来后dispatch到redux中。<br><pre><code>&#x2F;&#x2F; 使用示意\nconst { getTodos } from &#39;.&#x2F;services.js&#39;\ngetTodos().then((data) =&gt; {\n    dispatch(initTodos(data.list))\n}, (err) =&gt; {\n    console.log(&#39;@@@fail&#39;, err)\n})</code></pre></p>\n<p>我们的案例是以”待办事项”为例子，并没有后台接口与之对应，所以在继续往下学习之前，我们需要考虑如何通过接口来拿到数据。正常的项目开发中，会有后台的小伙伴给我们提供接口。现在我们没有后台的小伙伴那该怎么办？这个场景，就要考虑到mockjs了。</p>\n<h1 id=\"1、-mockjs\"><a href=\"#1、-mockjs\" class=\"headerlink\" title=\"1、 mockjs\"></a>1、 mockjs</h1><p>mockjs的<a href=\"http://mockjs.com\" target=\"_blank\" rel=\"noopener\">官网</a>的介绍很简单——“生成随机数据，拦截Ajax请求”。但是这个中文介绍的前后顺序貌似有点问题，正常的顺序应该是”拦截Ajax请求，生产随机数据”。也就是说，使用mockjs可以拦截我们写的ajax请求，然后生成随机的数据返回给ajax。</p>\n<p>在mockjs中，可以使用Mock.mock()这个方法来设置拦截哪个url，以及设置返回什么数据。</p>\n<p>当然我们先要使用命令行来安装mockjs依赖包。<br><pre><code>&gt; npm install -D mockjs</code></pre></p>\n<p>接着添加如下代码：</p>\n<pre><code>&#x2F;&#x2F; mock.js\nimport Mock from &#39;mockjs&#39;\n\nMock.mock(&#39;&#x2F;getTodos&#39;, {\n    &#39;list|1-5&#39;: [{\n        &#39;text&#39;: &#39;todo-item&#39;,\n        &#39;completed|1&#39;: true,\n    }]\n})</code></pre>\n<p>上述代码，Mock.mock()方法会拦截”/getTodos”请求，然后返回一个object对象，object对象包含一个list属性，list数组包含5个元素，每个元素的text属性为“todo-item”，completed属性为随机的boolean值。</p>\n<pre><code>{\n    list: [\n        {\n            text: &#39;todo-item&#39;,\n            completed: true,\n        },\n        &#x2F;&#x2F; ...\n    ]\n}</code></pre>\n<p>最后别忘了在入口文件(index.js)中引入mock.js</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;index.js\n&#x2F;&#x2F; ...\nimport &#39;.&#x2F;mock&#39;\n&#x2F;&#x2F; ...</code></pre>\n<h1 id=\"2、添加完整代码\"><a href=\"#2、添加完整代码\" class=\"headerlink\" title=\"2、添加完整代码\"></a>2、添加完整代码</h1><p>我们要处理一个不一样的action，那么有两个步骤需要完成：</p>\n<ol>\n<li>添加action</li>\n<li>添加reducer</li>\n</ol>\n<p>在actions.js文件中添加type为’INIT_TODOS’的action。</p>\n<pre><code>&#x2F;&#x2F; actions.js\n&#x2F;&#x2F; 初始化todos\nexport function initTodos (list) {\n  return {\n    type: &#39;INIT_TODOS&#39;,\n    list,\n  }\n}</code></pre>\n<p>然后在reducers.js文件中处理这个action，对应用状态的todos进行初始化。</p>\n<pre><code>&#x2F;&#x2F; 待办事项列表reducer\nfunction todos(state = [], action) {\n    switch (action.type) {\n        &#x2F;&#x2F; ...\n        &#x2F;&#x2F; 初始化 todos\n        case &#39;INIT_TODOS&#39;:\n            return [...state, ...action.list]\n        break\n        &#x2F;&#x2F; ...\n    }\n}</code></pre>\n<p>到此我们就处理了异步加载数据并将数据添加到redux的场景。这和普通的action没有任何区别。</p>\n<h1 id=\"3、加一个loading\"><a href=\"#3、加一个loading\" class=\"headerlink\" title=\"3、加一个loading\"></a>3、加一个loading</h1><p>假如要在请求发送到请求返回的这个时间段，添加一个loading效果。常规的做法，在执行getTodos()之前，先dispatch一个类型为’LOADING’的action到redux中（如设置loading为true），到请求返回后，处理将返回数据添加到redux，同时也需要将loading的标记设置为false。</p>\n<pre><code>&#x2F;&#x2F; 示意代码\ndispatch({\n    type: &#39;LOADING&#39;,\n    loading: true,\n})\ngetTodos().then((data) =&gt; {\n    dispatch(initTodos(data.list))\n    dispatch({\n        type: &#39;LOADING&#39;,\n        loading: false,\n    })\n}, (err) =&gt; {\n    console.log(&#39;@@@fail&#39;, err)\n    dispatch({\n        type: &#39;LOADING&#39;,\n        loading: false,\n    })\n})</code></pre>\n<p>这是完全可行的。但是这段属于redux的代码写到业务组件里面，代码就耦合了。解耦的方式，可以这段代码都整合到actions.js中来进行。简单的，我们进行代码抽取就可以实现。我们抽取一个dispatchInitTodos()方法来实现。</p>\n<pre><code>&#x2F;&#x2F; actions.js\nimport { getTodos } from &#39;.&#x2F;services.js&#39;\n&#x2F;&#x2F; ...\nexport function setLoading(loading) {\n  return {\n    type: &#39;SET_LOADING&#39;,\n    loading,\n  }\n}\n\n&#x2F;&#x2F; 初始化todos\nexport function initTodos(list) {\n  return {\n    type: &#39;INIT_TODOS&#39;,\n    list,\n  }\n}\n\nexport function dispatchInitTodos(dispatch) {\n  dispatch(setLoading(true))\n  getTodos().then((data) =&gt; {\n    dispatch(initTodos(data.list))\n    dispatch(setLoading(false))\n  }, (err) =&gt; {\n    console.log(&#39;@@@fail&#39;, err)\n    dispatch(setLoading(false))\n  })\n}</code></pre>\n<p>然后app.js中引入dispatchInitTodos()来执行。</p>\n<pre><code>import { toggleTodo, initTodos, dispatchInitTodos } from &#39;.&#x2F;actions&#39;\n\nclass App extends Component {\n    &#x2F;&#x2F; ...\n    componentDidMount () {\n        const { dispatch } = this.props\n        dispatchInitTodos(dispatch)\n    }\n    &#x2F;&#x2F; ...\n}</code></pre>\n<p>对此，我们还需要在reducers里面添加一个loading属性。</p>\n<pre><code>&#x2F;&#x2F; reducers.js\n&#x2F;&#x2F; ...\nfunction loading (state=false, action) {\n    switch(action.type) {\n        case &#39;SET_LOADING&#39;:\n            return !!action.loading\n        break\n        default:\n            return state\n    }\n}\n\nconst rootReducer = combineReducers({\n    visibilityFilter,\n    todos,\n    loading,\n})\n&#x2F;&#x2F; ...</code></pre>\n<p>上面只是一些代码的片段，并不完整。完整代码请查看 <a href=\"https://github.com/Two-Ftry/react-essay/tree/master/redux-04\" target=\"_blank\" rel=\"noopener\">redux-04</a>。</p>\n<p>针对异步的场景，我们上面做了简单的封装。实际上，redux针对异步的场景有很多中间件(即middleware)可以使用，不需要我们手动来封装。</p>\n<h1 id=\"4、redux-thunk中间件\"><a href=\"#4、redux-thunk中间件\" class=\"headerlink\" title=\"4、redux-thunk中间件\"></a>4、redux-thunk中间件</h1><p>redux的dispatch()方法自身的功能极其简单，它只能dispatch一个Object对象。但是redux提供的中间件方式，可以极大的扩展dispatch的功能。redux-chunk就是一个可以dispatch()一个function的中间件。redux提供了applyMiddleware(…middlewares)方法来添加中间件。</p>\n<p>使用命令行，先添加redux-thunk依赖包。<br><pre><code>&gt; npm install -D redux-thunk</code></pre></p>\n<p>然后在createStore的时候将中间件redux-thunk加入到redux中。<br><pre><code>&#x2F;&#x2F; index.js\n&#x2F;&#x2F; ...\nimport { createStore, applyMiddleware } from &#39;redux&#39;\nimport reduxThunk from &#39;redux-thunk&#39;\nimport rootReducer from &#39;.&#x2F;reducers.js&#39;\nconst store = createStore(rootReducer, applyMiddleware(reduxThunk))\n\n&#x2F;&#x2F; ...</code></pre></p>\n<p>使用redux-thunk可以dispatch一个function，这个function接收一个dispatch参数(由redux-thunk传入)。所以修改action如下。</p>\n<pre><code>&#x2F;&#x2F; actions.js\n&#x2F;&#x2F; ...\nexport function dispatchInitTodos() {\n  return (dispatch) =&gt; {\n    dispatch(setLoading(true))\n    getTodos().then((data) =&gt; {\n      dispatch(initTodos(data.list))\n      dispatch(setLoading(false))\n    }, (err) =&gt; {\n      console.log(&#39;@@@fail&#39;, err)\n      dispatch(setLoading(false))\n    })\n  }\n}</code></pre>\n<p>在app.js中使用。</p>\n<pre><code>&#x2F;&#x2F; app.js\n&#x2F;&#x2F; ...\nimport { toggleTodo, initTodos, dispatchInitTodos } from &#39;.&#x2F;actions&#39;\n\nclass App extends Component {\n    &#x2F;&#x2F; ...\n    componentDidMount () {\n        const { dispatch } = this.props\n        dispatch(dispatchInitTodos())\n    }\n    &#x2F;&#x2F; ...\n}\n&#x2F;&#x2F; ...</code></pre>\n<p>如此，redux-thunk就使用起来了。</p>\n<p>除了redux-thunk，还有其他的处理异步场景的中间件。</p>\n<ol>\n<li>redux-promise:  dispatch Promise。</li>\n<li>redux-saga：创建更加复杂的异步 action。</li>\n<li>…</li>\n</ol>\n<p>这些中间件要不要学习？感觉一口气学完会蛮吃力的，是不是我会redux-thunk就可以了？现在搭建出来的项目一般不会单纯地使用redux-thunk这种简单的中间件，所以是要掌握的。不过redux-promise可以放一放，因为这个中间件是FSA兼容redux的一个中间件。redux-saga得花些时间去掌握。本章篇幅有限，先到此打住了。</p>\n<p>本章完整的代码请查看 <a href=\"https://github.com/Two-Ftry/react-essay/tree/master/redux-05\" target=\"_blank\" rel=\"noopener\">redux-05</a> 。</p>\n"},{"title":"redux(三)-redux搭配react","date":"2018-12-16T04:34:36.000Z","_content":"\nRedux 支持 React、Vue、Angular、Ember、jQuery 甚至纯 JavaScript。Redux其实和React之间没有关系。但是在实际使用中，redux更多的时候是和react搭配使用。所以这片文章，我们先来让redux和react搭配起来使用。\n\n本文在 {% link 待办事项项目UI实现 https://suifengfengye.github.io/2018/12/20/react-todo-ui/ %} 和 {% link 初识redux https://suifengfengye.github.io/2018/12/01/%E5%88%9D%E8%AF%86redux/ %} 这两篇文章的基础上来展开。\n\n## 1、组合起来\n\n在\"初始redux\"里面，我们完成了actions、reducers的编写，并且基于reducers创建了store。那么我们怎么样把redux和react搭配起来呢？\n\nredux作为一个状态管理库，那么它提供出去的接口自然包括：\n\n1. 获取应用状态信息，即state;\n2. 更新应用状态：提供一个接口让外部能够触发action来更新应用状态。\n\n而这两个接口对应的就是store实力的getState()和dispatch()方法。所以我们只要把store实例提供给react即可。简单地，我们自然可以在需要使用应用状态信息或者更新应用状态的react组件中引入store即可，但是这种方式有一个问题，就是使用起来太麻烦。而在react里面，有一种在组件之间共享类型的方式即\"Context\"，这种方式不必通过组件树的每个层级都通过props传递数据。基于这个原理，为了更好地把redux和react搭配起来，社区里面提供了\"react-redux\"这个工具把它们串联起来。\n\n\"react-redux\"为应用状态能够在组件树中共享，提供了<Provider /\\>这个高级组件。<Provider /\\>接收redux的store作为属性来为react提供信息。在react的子组件中需要使用到应用状态的相关信息时，可以调用\"react-redux\"提供的connect方法。\n\n{% codeblock %}\nconnect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])\nmapStateToProps \nmapStateToProps是一个函数，它接收应用状态state作为第一个参数，\n将传递到组件的props作为第二个参数，而它的返回值将会通过props的方式传递到组件中。\n具体形如：\nmapStateToProps(state, [ownProps]): stateProps\nconnect的四个参数都是可选参数，其他三个参数还没用到，暂时不做介绍。\n{% endcodeblock %}\n\nconnect方法返回一个高阶组件。这个高阶组件接收组件作为参数返回一个包含redux相关信息的新组件。新的组件除了上面提到mapStateToProps的返回值作为props外，redux的dispatch()方法也会通过props传递进来。通过dispatch()方法我们就可以在组件中通过触发action来更改应用的状态了。\n\n所以我们结合上两篇文章的代码，然后修改入口文件src/index.js,具体如下：\n\n{% codeblock %}\n// src/index.js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport { createStore } from 'redux'\nimport { Provider } from 'react-redux'\nimport rootReducer from './reducers.js'\nconst store = createStore(rootReducer)\n\nimport App from './app'\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>, \n    document.getElementsByTagName('BODY')[0],\n)\n{% endcodeblock %}\n\n## 2、添加待办事项组合（AddTodo.js）\n\nAddTodo.js文件的功能就是往状态管理库添加待办事项，但它并没有使用应用状态的信息。所以我们简单地使用\"react-redux\"提供的connect()方法来包装它，组件中就会有redux的dispatch()方法作为props传递进来。当点击添加待办事项的按钮时，我们就通过dispatch()方法触发\"ADD_TODO\"action即可。\n\n{% codeblock %}\nimport React from 'react';\nimport { connect } from 'react-redux'\nimport { addTodo } from './actions'\n\nconst AddTodo = ({ dispatch }) => {\n    let input = null\n    return (\n        <div>\n            <input type=\"text\"\n                ref={node => {\n                    input = node\n                }} />\n            <button type=\"button\"\n                onClick={() => {\n                    dispatch(addTodo(input && input.value))\n                }}\n            >Add</button>\n        </div>\n    )\n}\n\nexport default connect()(AddTodo)\n{% endcodeblock %}\n\n## 3、展示Todo列表信息\n\n我们是在app.js中接收Todo列表的，所以使用connect将App组件和redux连接起来，然后通过connect的mapStateToProps参数来获取todos的信息。当接收到Todo列表项的点击事件的时候通过dispatch()方法更改Todo事项的状态。\n\n{% codeblock %}\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux'\n\nimport AddTodo from './AddTodo'\nimport TodoList from './TodoList'\nimport Footer from './Footer'\nimport { toggleTodo } from './actions'\n\nclass App extends Component {\n\n    constructor (props) {\n        super(props)\n        this.onTodoClick = this.onTodoClick.bind(this)\n    }\n\n    onTodoClick (index) {\n        const { dispatch } = this.props\n        dispatch(toggleTodo(index))\n    }\n\n    render() {\n        const { todos } = this.props\n        return (\n            <div>\n                <AddTodo />\n                <TodoList todos={todos} onTodoClick={this.onTodoClick}/>\n                <Footer />\n            </div>\n        )\n    }\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        todos: state.todos,\n    }\n}\n\nexport default connect(mapStateToProps)(App)\n{% endcodeblock %}\n\n## 4、过滤条件\n\n在Footer.js文件中，我们有\"ALL\"、\"Active\"、\"Completed\"三个链接，它们对todos列表的过滤如下：\n\n- ALL： 显示全部\n- Active: 显示未完成的todo\n- Completed：显示完成的todo\n\n我们为三个链接添加点击事件，每当点击链接时，dispatch()触发action更改应用状态的\"visibilityFilter\"。\n\n{% codeblock %}\n// src/Footer.js\nimport React from 'react';\nimport { connect } from 'react-redux'\n\nimport Link from './Link'\nimport { setVisibilityFilter } from './actions'\n\nconst Footer = ({ dispatch, visibilityFilter }) => (\n    <p>\n        Show:\n        <Link active={visibilityFilter === 'SHOW_ALL'}\n            onClick={() => {\n                dispatch(setVisibilityFilter('SHOW_ALL'))\n            }}>ALL</Link>\n        &nbsp;&nbsp;\n        <Link active={visibilityFilter === 'SHOW_ACTIVE'}\n            onClick={() => {\n                dispatch(setVisibilityFilter('SHOW_ACTIVE'))\n            }}>Active</Link>\n        &nbsp;&nbsp;\n        <Link active={visibilityFilter === 'SHOW_COMPLETED'}\n            onClick={() => {\n                dispatch(setVisibilityFilter('SHOW_COMPLETED'))\n            }}>Completed</Link>\n    </p>\n)\nconst mapStateToProps = (state) => {\n    return {\n        visibilityFilter: state.visibilityFilter,\n    }\n}\nexport default connect(mapStateToProps)(Footer)\n{% endcodeblock %}\n\nvisibilityFilter是用来对todos列表进行过滤的，所以在todos列表展现之前，我们要根据visibilityFilter这个条件对todos列表进行处理。我们修改app.js中的mapStateToProps方法即可。\n\n{% codeblock %}\n// src/app.js\n// ...\nconst mapStateToProps = (state) => {\n    return {\n        todos: state.todos.filter((todo) => {\n            if (state.visibilityFilter === 'SHOW_ACTIVE') {\n                return !todo.completed\n            } else if (state.visibilityFilter === 'SHOW_COMPLETED') {\n                return todo.completed\n            } else {\n                // SHOW_ALL\n                return true\n            }\n        }),\n    }\n}\n// ...\n{% endcodeblock %}\n\nmapStateToProps里面，我们使用filter()函数对原始的todos列表进行过滤，如果visibilityFilter为'SHOW_ALL',我们都返回ture，那么返回的就是整个todos列表；如果visibilityFilter为'SHOW_ACTIVE'，我们就将completed属性为false的列表项返回true，filter()函数返回的结果就是所有\"未完成\"的待办事项；对于\"SHOW_COMPLETED\"也是同理。\n\n# 5、结语\n\n到此，redux就和react搭配了起来。基于这两个技术，我们就可以开发一些简单的react应用了。","source":"_posts/redux3-redux+react-20181216.md","raw":"---\ntitle: redux(三)-redux搭配react\ndate: 2018-12-16 12:34:36\ntags: redux react\n---\n\nRedux 支持 React、Vue、Angular、Ember、jQuery 甚至纯 JavaScript。Redux其实和React之间没有关系。但是在实际使用中，redux更多的时候是和react搭配使用。所以这片文章，我们先来让redux和react搭配起来使用。\n\n本文在 {% link 待办事项项目UI实现 https://suifengfengye.github.io/2018/12/20/react-todo-ui/ %} 和 {% link 初识redux https://suifengfengye.github.io/2018/12/01/%E5%88%9D%E8%AF%86redux/ %} 这两篇文章的基础上来展开。\n\n## 1、组合起来\n\n在\"初始redux\"里面，我们完成了actions、reducers的编写，并且基于reducers创建了store。那么我们怎么样把redux和react搭配起来呢？\n\nredux作为一个状态管理库，那么它提供出去的接口自然包括：\n\n1. 获取应用状态信息，即state;\n2. 更新应用状态：提供一个接口让外部能够触发action来更新应用状态。\n\n而这两个接口对应的就是store实力的getState()和dispatch()方法。所以我们只要把store实例提供给react即可。简单地，我们自然可以在需要使用应用状态信息或者更新应用状态的react组件中引入store即可，但是这种方式有一个问题，就是使用起来太麻烦。而在react里面，有一种在组件之间共享类型的方式即\"Context\"，这种方式不必通过组件树的每个层级都通过props传递数据。基于这个原理，为了更好地把redux和react搭配起来，社区里面提供了\"react-redux\"这个工具把它们串联起来。\n\n\"react-redux\"为应用状态能够在组件树中共享，提供了<Provider /\\>这个高级组件。<Provider /\\>接收redux的store作为属性来为react提供信息。在react的子组件中需要使用到应用状态的相关信息时，可以调用\"react-redux\"提供的connect方法。\n\n{% codeblock %}\nconnect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])\nmapStateToProps \nmapStateToProps是一个函数，它接收应用状态state作为第一个参数，\n将传递到组件的props作为第二个参数，而它的返回值将会通过props的方式传递到组件中。\n具体形如：\nmapStateToProps(state, [ownProps]): stateProps\nconnect的四个参数都是可选参数，其他三个参数还没用到，暂时不做介绍。\n{% endcodeblock %}\n\nconnect方法返回一个高阶组件。这个高阶组件接收组件作为参数返回一个包含redux相关信息的新组件。新的组件除了上面提到mapStateToProps的返回值作为props外，redux的dispatch()方法也会通过props传递进来。通过dispatch()方法我们就可以在组件中通过触发action来更改应用的状态了。\n\n所以我们结合上两篇文章的代码，然后修改入口文件src/index.js,具体如下：\n\n{% codeblock %}\n// src/index.js\nimport React from 'react'\nimport ReactDOM from 'react-dom'\n\nimport { createStore } from 'redux'\nimport { Provider } from 'react-redux'\nimport rootReducer from './reducers.js'\nconst store = createStore(rootReducer)\n\nimport App from './app'\n\nReactDOM.render(\n    <Provider store={store}>\n        <App />\n    </Provider>, \n    document.getElementsByTagName('BODY')[0],\n)\n{% endcodeblock %}\n\n## 2、添加待办事项组合（AddTodo.js）\n\nAddTodo.js文件的功能就是往状态管理库添加待办事项，但它并没有使用应用状态的信息。所以我们简单地使用\"react-redux\"提供的connect()方法来包装它，组件中就会有redux的dispatch()方法作为props传递进来。当点击添加待办事项的按钮时，我们就通过dispatch()方法触发\"ADD_TODO\"action即可。\n\n{% codeblock %}\nimport React from 'react';\nimport { connect } from 'react-redux'\nimport { addTodo } from './actions'\n\nconst AddTodo = ({ dispatch }) => {\n    let input = null\n    return (\n        <div>\n            <input type=\"text\"\n                ref={node => {\n                    input = node\n                }} />\n            <button type=\"button\"\n                onClick={() => {\n                    dispatch(addTodo(input && input.value))\n                }}\n            >Add</button>\n        </div>\n    )\n}\n\nexport default connect()(AddTodo)\n{% endcodeblock %}\n\n## 3、展示Todo列表信息\n\n我们是在app.js中接收Todo列表的，所以使用connect将App组件和redux连接起来，然后通过connect的mapStateToProps参数来获取todos的信息。当接收到Todo列表项的点击事件的时候通过dispatch()方法更改Todo事项的状态。\n\n{% codeblock %}\nimport React, { Component } from 'react';\nimport { connect } from 'react-redux'\n\nimport AddTodo from './AddTodo'\nimport TodoList from './TodoList'\nimport Footer from './Footer'\nimport { toggleTodo } from './actions'\n\nclass App extends Component {\n\n    constructor (props) {\n        super(props)\n        this.onTodoClick = this.onTodoClick.bind(this)\n    }\n\n    onTodoClick (index) {\n        const { dispatch } = this.props\n        dispatch(toggleTodo(index))\n    }\n\n    render() {\n        const { todos } = this.props\n        return (\n            <div>\n                <AddTodo />\n                <TodoList todos={todos} onTodoClick={this.onTodoClick}/>\n                <Footer />\n            </div>\n        )\n    }\n}\n\nconst mapStateToProps = (state) => {\n    return {\n        todos: state.todos,\n    }\n}\n\nexport default connect(mapStateToProps)(App)\n{% endcodeblock %}\n\n## 4、过滤条件\n\n在Footer.js文件中，我们有\"ALL\"、\"Active\"、\"Completed\"三个链接，它们对todos列表的过滤如下：\n\n- ALL： 显示全部\n- Active: 显示未完成的todo\n- Completed：显示完成的todo\n\n我们为三个链接添加点击事件，每当点击链接时，dispatch()触发action更改应用状态的\"visibilityFilter\"。\n\n{% codeblock %}\n// src/Footer.js\nimport React from 'react';\nimport { connect } from 'react-redux'\n\nimport Link from './Link'\nimport { setVisibilityFilter } from './actions'\n\nconst Footer = ({ dispatch, visibilityFilter }) => (\n    <p>\n        Show:\n        <Link active={visibilityFilter === 'SHOW_ALL'}\n            onClick={() => {\n                dispatch(setVisibilityFilter('SHOW_ALL'))\n            }}>ALL</Link>\n        &nbsp;&nbsp;\n        <Link active={visibilityFilter === 'SHOW_ACTIVE'}\n            onClick={() => {\n                dispatch(setVisibilityFilter('SHOW_ACTIVE'))\n            }}>Active</Link>\n        &nbsp;&nbsp;\n        <Link active={visibilityFilter === 'SHOW_COMPLETED'}\n            onClick={() => {\n                dispatch(setVisibilityFilter('SHOW_COMPLETED'))\n            }}>Completed</Link>\n    </p>\n)\nconst mapStateToProps = (state) => {\n    return {\n        visibilityFilter: state.visibilityFilter,\n    }\n}\nexport default connect(mapStateToProps)(Footer)\n{% endcodeblock %}\n\nvisibilityFilter是用来对todos列表进行过滤的，所以在todos列表展现之前，我们要根据visibilityFilter这个条件对todos列表进行处理。我们修改app.js中的mapStateToProps方法即可。\n\n{% codeblock %}\n// src/app.js\n// ...\nconst mapStateToProps = (state) => {\n    return {\n        todos: state.todos.filter((todo) => {\n            if (state.visibilityFilter === 'SHOW_ACTIVE') {\n                return !todo.completed\n            } else if (state.visibilityFilter === 'SHOW_COMPLETED') {\n                return todo.completed\n            } else {\n                // SHOW_ALL\n                return true\n            }\n        }),\n    }\n}\n// ...\n{% endcodeblock %}\n\nmapStateToProps里面，我们使用filter()函数对原始的todos列表进行过滤，如果visibilityFilter为'SHOW_ALL',我们都返回ture，那么返回的就是整个todos列表；如果visibilityFilter为'SHOW_ACTIVE'，我们就将completed属性为false的列表项返回true，filter()函数返回的结果就是所有\"未完成\"的待办事项；对于\"SHOW_COMPLETED\"也是同理。\n\n# 5、结语\n\n到此，redux就和react搭配了起来。基于这两个技术，我们就可以开发一些简单的react应用了。","slug":"redux3-redux+react","published":1,"updated":"2019-01-10T02:58:42.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjypcvoq8001o4c417pb3mtyj","content":"<p>Redux 支持 React、Vue、Angular、Ember、jQuery 甚至纯 JavaScript。Redux其实和React之间没有关系。但是在实际使用中，redux更多的时候是和react搭配使用。所以这片文章，我们先来让redux和react搭配起来使用。</p>\n<p>本文在 <a href=\"https://suifengfengye.github.io/2018/12/20/react-todo-ui/\" target=\"_blank\" rel=\"noopener\">待办事项项目UI实现</a> 和 <a href=\"https://suifengfengye.github.io/2018/12/01/%E5%88%9D%E8%AF%86redux/\" target=\"_blank\" rel=\"noopener\">初识redux</a> 这两篇文章的基础上来展开。</p>\n<h2 id=\"1、组合起来\"><a href=\"#1、组合起来\" class=\"headerlink\" title=\"1、组合起来\"></a>1、组合起来</h2><p>在”初始redux”里面，我们完成了actions、reducers的编写，并且基于reducers创建了store。那么我们怎么样把redux和react搭配起来呢？</p>\n<p>redux作为一个状态管理库，那么它提供出去的接口自然包括：</p>\n<ol>\n<li>获取应用状态信息，即state;</li>\n<li>更新应用状态：提供一个接口让外部能够触发action来更新应用状态。</li>\n</ol>\n<p>而这两个接口对应的就是store实力的getState()和dispatch()方法。所以我们只要把store实例提供给react即可。简单地，我们自然可以在需要使用应用状态信息或者更新应用状态的react组件中引入store即可，但是这种方式有一个问题，就是使用起来太麻烦。而在react里面，有一种在组件之间共享类型的方式即”Context”，这种方式不必通过组件树的每个层级都通过props传递数据。基于这个原理，为了更好地把redux和react搭配起来，社区里面提供了”react-redux”这个工具把它们串联起来。</p>\n<p>“react-redux”为应用状态能够在组件树中共享，提供了&lt;Provider />这个高级组件。&lt;Provider />接收redux的store作为属性来为react提供信息。在react的子组件中需要使用到应用状态的相关信息时，可以调用”react-redux”提供的connect方法。</p>\n<pre><code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])\nmapStateToProps \nmapStateToProps是一个函数，它接收应用状态state作为第一个参数，\n将传递到组件的props作为第二个参数，而它的返回值将会通过props的方式传递到组件中。\n具体形如：\nmapStateToProps(state, [ownProps]): stateProps\nconnect的四个参数都是可选参数，其他三个参数还没用到，暂时不做介绍。</code></pre>\n<p>connect方法返回一个高阶组件。这个高阶组件接收组件作为参数返回一个包含redux相关信息的新组件。新的组件除了上面提到mapStateToProps的返回值作为props外，redux的dispatch()方法也会通过props传递进来。通过dispatch()方法我们就可以在组件中通过触发action来更改应用的状态了。</p>\n<p>所以我们结合上两篇文章的代码，然后修改入口文件src/index.js,具体如下：</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\n\nimport { createStore } from &#39;redux&#39;\nimport { Provider } from &#39;react-redux&#39;\nimport rootReducer from &#39;.&#x2F;reducers.js&#39;\nconst store = createStore(rootReducer)\n\nimport App from &#39;.&#x2F;app&#39;\n\nReactDOM.render(\n    &lt;Provider store={store}&gt;\n        &lt;App &#x2F;&gt;\n    &lt;&#x2F;Provider&gt;, \n    document.getElementsByTagName(&#39;BODY&#39;)[0],\n)</code></pre>\n<h2 id=\"2、添加待办事项组合（AddTodo-js）\"><a href=\"#2、添加待办事项组合（AddTodo-js）\" class=\"headerlink\" title=\"2、添加待办事项组合（AddTodo.js）\"></a>2、添加待办事项组合（AddTodo.js）</h2><p>AddTodo.js文件的功能就是往状态管理库添加待办事项，但它并没有使用应用状态的信息。所以我们简单地使用”react-redux”提供的connect()方法来包装它，组件中就会有redux的dispatch()方法作为props传递进来。当点击添加待办事项的按钮时，我们就通过dispatch()方法触发”ADD_TODO”action即可。</p>\n<pre><code>import React from &#39;react&#39;;\nimport { connect } from &#39;react-redux&#39;\nimport { addTodo } from &#39;.&#x2F;actions&#39;\n\nconst AddTodo = ({ dispatch }) =&gt; {\n    let input = null\n    return (\n        &lt;div&gt;\n            &lt;input type=&quot;text&quot;\n                ref={node =&gt; {\n                    input = node\n                }} &#x2F;&gt;\n            &lt;button type=&quot;button&quot;\n                onClick={() =&gt; {\n                    dispatch(addTodo(input &amp;&amp; input.value))\n                }}\n            &gt;Add&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n}\n\nexport default connect()(AddTodo)</code></pre>\n<h2 id=\"3、展示Todo列表信息\"><a href=\"#3、展示Todo列表信息\" class=\"headerlink\" title=\"3、展示Todo列表信息\"></a>3、展示Todo列表信息</h2><p>我们是在app.js中接收Todo列表的，所以使用connect将App组件和redux连接起来，然后通过connect的mapStateToProps参数来获取todos的信息。当接收到Todo列表项的点击事件的时候通过dispatch()方法更改Todo事项的状态。</p>\n<pre><code>import React, { Component } from &#39;react&#39;;\nimport { connect } from &#39;react-redux&#39;\n\nimport AddTodo from &#39;.&#x2F;AddTodo&#39;\nimport TodoList from &#39;.&#x2F;TodoList&#39;\nimport Footer from &#39;.&#x2F;Footer&#39;\nimport { toggleTodo } from &#39;.&#x2F;actions&#39;\n\nclass App extends Component {\n\n    constructor (props) {\n        super(props)\n        this.onTodoClick = this.onTodoClick.bind(this)\n    }\n\n    onTodoClick (index) {\n        const { dispatch } = this.props\n        dispatch(toggleTodo(index))\n    }\n\n    render() {\n        const { todos } = this.props\n        return (\n            &lt;div&gt;\n                &lt;AddTodo &#x2F;&gt;\n                &lt;TodoList todos={todos} onTodoClick={this.onTodoClick}&#x2F;&gt;\n                &lt;Footer &#x2F;&gt;\n            &lt;&#x2F;div&gt;\n        )\n    }\n}\n\nconst mapStateToProps = (state) =&gt; {\n    return {\n        todos: state.todos,\n    }\n}\n\nexport default connect(mapStateToProps)(App)</code></pre>\n<h2 id=\"4、过滤条件\"><a href=\"#4、过滤条件\" class=\"headerlink\" title=\"4、过滤条件\"></a>4、过滤条件</h2><p>在Footer.js文件中，我们有”ALL”、”Active”、”Completed”三个链接，它们对todos列表的过滤如下：</p>\n<ul>\n<li>ALL： 显示全部</li>\n<li>Active: 显示未完成的todo</li>\n<li>Completed：显示完成的todo</li>\n</ul>\n<p>我们为三个链接添加点击事件，每当点击链接时，dispatch()触发action更改应用状态的”visibilityFilter”。</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;Footer.js\nimport React from &#39;react&#39;;\nimport { connect } from &#39;react-redux&#39;\n\nimport Link from &#39;.&#x2F;Link&#39;\nimport { setVisibilityFilter } from &#39;.&#x2F;actions&#39;\n\nconst Footer = ({ dispatch, visibilityFilter }) =&gt; (\n    &lt;p&gt;\n        Show:\n        &lt;Link active={visibilityFilter === &#39;SHOW_ALL&#39;}\n            onClick={() =&gt; {\n                dispatch(setVisibilityFilter(&#39;SHOW_ALL&#39;))\n            }}&gt;ALL&lt;&#x2F;Link&gt;\n        &amp;nbsp;&amp;nbsp;\n        &lt;Link active={visibilityFilter === &#39;SHOW_ACTIVE&#39;}\n            onClick={() =&gt; {\n                dispatch(setVisibilityFilter(&#39;SHOW_ACTIVE&#39;))\n            }}&gt;Active&lt;&#x2F;Link&gt;\n        &amp;nbsp;&amp;nbsp;\n        &lt;Link active={visibilityFilter === &#39;SHOW_COMPLETED&#39;}\n            onClick={() =&gt; {\n                dispatch(setVisibilityFilter(&#39;SHOW_COMPLETED&#39;))\n            }}&gt;Completed&lt;&#x2F;Link&gt;\n    &lt;&#x2F;p&gt;\n)\nconst mapStateToProps = (state) =&gt; {\n    return {\n        visibilityFilter: state.visibilityFilter,\n    }\n}\nexport default connect(mapStateToProps)(Footer)</code></pre>\n<p>visibilityFilter是用来对todos列表进行过滤的，所以在todos列表展现之前，我们要根据visibilityFilter这个条件对todos列表进行处理。我们修改app.js中的mapStateToProps方法即可。</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;app.js\n&#x2F;&#x2F; ...\nconst mapStateToProps = (state) =&gt; {\n    return {\n        todos: state.todos.filter((todo) =&gt; {\n            if (state.visibilityFilter === &#39;SHOW_ACTIVE&#39;) {\n                return !todo.completed\n            } else if (state.visibilityFilter === &#39;SHOW_COMPLETED&#39;) {\n                return todo.completed\n            } else {\n                &#x2F;&#x2F; SHOW_ALL\n                return true\n            }\n        }),\n    }\n}\n&#x2F;&#x2F; ...</code></pre>\n<p>mapStateToProps里面，我们使用filter()函数对原始的todos列表进行过滤，如果visibilityFilter为’SHOW_ALL’,我们都返回ture，那么返回的就是整个todos列表；如果visibilityFilter为’SHOW_ACTIVE’，我们就将completed属性为false的列表项返回true，filter()函数返回的结果就是所有”未完成”的待办事项；对于”SHOW_COMPLETED”也是同理。</p>\n<h1 id=\"5、结语\"><a href=\"#5、结语\" class=\"headerlink\" title=\"5、结语\"></a>5、结语</h1><p>到此，redux就和react搭配了起来。基于这两个技术，我们就可以开发一些简单的react应用了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>Redux 支持 React、Vue、Angular、Ember、jQuery 甚至纯 JavaScript。Redux其实和React之间没有关系。但是在实际使用中，redux更多的时候是和react搭配使用。所以这片文章，我们先来让redux和react搭配起来使用。</p>\n<p>本文在 <a href=\"https://suifengfengye.github.io/2018/12/20/react-todo-ui/\" target=\"_blank\" rel=\"noopener\">待办事项项目UI实现</a> 和 <a href=\"https://suifengfengye.github.io/2018/12/01/%E5%88%9D%E8%AF%86redux/\" target=\"_blank\" rel=\"noopener\">初识redux</a> 这两篇文章的基础上来展开。</p>\n<h2 id=\"1、组合起来\"><a href=\"#1、组合起来\" class=\"headerlink\" title=\"1、组合起来\"></a>1、组合起来</h2><p>在”初始redux”里面，我们完成了actions、reducers的编写，并且基于reducers创建了store。那么我们怎么样把redux和react搭配起来呢？</p>\n<p>redux作为一个状态管理库，那么它提供出去的接口自然包括：</p>\n<ol>\n<li>获取应用状态信息，即state;</li>\n<li>更新应用状态：提供一个接口让外部能够触发action来更新应用状态。</li>\n</ol>\n<p>而这两个接口对应的就是store实力的getState()和dispatch()方法。所以我们只要把store实例提供给react即可。简单地，我们自然可以在需要使用应用状态信息或者更新应用状态的react组件中引入store即可，但是这种方式有一个问题，就是使用起来太麻烦。而在react里面，有一种在组件之间共享类型的方式即”Context”，这种方式不必通过组件树的每个层级都通过props传递数据。基于这个原理，为了更好地把redux和react搭配起来，社区里面提供了”react-redux”这个工具把它们串联起来。</p>\n<p>“react-redux”为应用状态能够在组件树中共享，提供了&lt;Provider />这个高级组件。&lt;Provider />接收redux的store作为属性来为react提供信息。在react的子组件中需要使用到应用状态的相关信息时，可以调用”react-redux”提供的connect方法。</p>\n<pre><code>connect([mapStateToProps], [mapDispatchToProps], [mergeProps], [options])\nmapStateToProps \nmapStateToProps是一个函数，它接收应用状态state作为第一个参数，\n将传递到组件的props作为第二个参数，而它的返回值将会通过props的方式传递到组件中。\n具体形如：\nmapStateToProps(state, [ownProps]): stateProps\nconnect的四个参数都是可选参数，其他三个参数还没用到，暂时不做介绍。</code></pre>\n<p>connect方法返回一个高阶组件。这个高阶组件接收组件作为参数返回一个包含redux相关信息的新组件。新的组件除了上面提到mapStateToProps的返回值作为props外，redux的dispatch()方法也会通过props传递进来。通过dispatch()方法我们就可以在组件中通过触发action来更改应用的状态了。</p>\n<p>所以我们结合上两篇文章的代码，然后修改入口文件src/index.js,具体如下：</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;index.js\nimport React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\n\nimport { createStore } from &#39;redux&#39;\nimport { Provider } from &#39;react-redux&#39;\nimport rootReducer from &#39;.&#x2F;reducers.js&#39;\nconst store = createStore(rootReducer)\n\nimport App from &#39;.&#x2F;app&#39;\n\nReactDOM.render(\n    &lt;Provider store={store}&gt;\n        &lt;App &#x2F;&gt;\n    &lt;&#x2F;Provider&gt;, \n    document.getElementsByTagName(&#39;BODY&#39;)[0],\n)</code></pre>\n<h2 id=\"2、添加待办事项组合（AddTodo-js）\"><a href=\"#2、添加待办事项组合（AddTodo-js）\" class=\"headerlink\" title=\"2、添加待办事项组合（AddTodo.js）\"></a>2、添加待办事项组合（AddTodo.js）</h2><p>AddTodo.js文件的功能就是往状态管理库添加待办事项，但它并没有使用应用状态的信息。所以我们简单地使用”react-redux”提供的connect()方法来包装它，组件中就会有redux的dispatch()方法作为props传递进来。当点击添加待办事项的按钮时，我们就通过dispatch()方法触发”ADD_TODO”action即可。</p>\n<pre><code>import React from &#39;react&#39;;\nimport { connect } from &#39;react-redux&#39;\nimport { addTodo } from &#39;.&#x2F;actions&#39;\n\nconst AddTodo = ({ dispatch }) =&gt; {\n    let input = null\n    return (\n        &lt;div&gt;\n            &lt;input type=&quot;text&quot;\n                ref={node =&gt; {\n                    input = node\n                }} &#x2F;&gt;\n            &lt;button type=&quot;button&quot;\n                onClick={() =&gt; {\n                    dispatch(addTodo(input &amp;&amp; input.value))\n                }}\n            &gt;Add&lt;&#x2F;button&gt;\n        &lt;&#x2F;div&gt;\n    )\n}\n\nexport default connect()(AddTodo)</code></pre>\n<h2 id=\"3、展示Todo列表信息\"><a href=\"#3、展示Todo列表信息\" class=\"headerlink\" title=\"3、展示Todo列表信息\"></a>3、展示Todo列表信息</h2><p>我们是在app.js中接收Todo列表的，所以使用connect将App组件和redux连接起来，然后通过connect的mapStateToProps参数来获取todos的信息。当接收到Todo列表项的点击事件的时候通过dispatch()方法更改Todo事项的状态。</p>\n<pre><code>import React, { Component } from &#39;react&#39;;\nimport { connect } from &#39;react-redux&#39;\n\nimport AddTodo from &#39;.&#x2F;AddTodo&#39;\nimport TodoList from &#39;.&#x2F;TodoList&#39;\nimport Footer from &#39;.&#x2F;Footer&#39;\nimport { toggleTodo } from &#39;.&#x2F;actions&#39;\n\nclass App extends Component {\n\n    constructor (props) {\n        super(props)\n        this.onTodoClick = this.onTodoClick.bind(this)\n    }\n\n    onTodoClick (index) {\n        const { dispatch } = this.props\n        dispatch(toggleTodo(index))\n    }\n\n    render() {\n        const { todos } = this.props\n        return (\n            &lt;div&gt;\n                &lt;AddTodo &#x2F;&gt;\n                &lt;TodoList todos={todos} onTodoClick={this.onTodoClick}&#x2F;&gt;\n                &lt;Footer &#x2F;&gt;\n            &lt;&#x2F;div&gt;\n        )\n    }\n}\n\nconst mapStateToProps = (state) =&gt; {\n    return {\n        todos: state.todos,\n    }\n}\n\nexport default connect(mapStateToProps)(App)</code></pre>\n<h2 id=\"4、过滤条件\"><a href=\"#4、过滤条件\" class=\"headerlink\" title=\"4、过滤条件\"></a>4、过滤条件</h2><p>在Footer.js文件中，我们有”ALL”、”Active”、”Completed”三个链接，它们对todos列表的过滤如下：</p>\n<ul>\n<li>ALL： 显示全部</li>\n<li>Active: 显示未完成的todo</li>\n<li>Completed：显示完成的todo</li>\n</ul>\n<p>我们为三个链接添加点击事件，每当点击链接时，dispatch()触发action更改应用状态的”visibilityFilter”。</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;Footer.js\nimport React from &#39;react&#39;;\nimport { connect } from &#39;react-redux&#39;\n\nimport Link from &#39;.&#x2F;Link&#39;\nimport { setVisibilityFilter } from &#39;.&#x2F;actions&#39;\n\nconst Footer = ({ dispatch, visibilityFilter }) =&gt; (\n    &lt;p&gt;\n        Show:\n        &lt;Link active={visibilityFilter === &#39;SHOW_ALL&#39;}\n            onClick={() =&gt; {\n                dispatch(setVisibilityFilter(&#39;SHOW_ALL&#39;))\n            }}&gt;ALL&lt;&#x2F;Link&gt;\n        &amp;nbsp;&amp;nbsp;\n        &lt;Link active={visibilityFilter === &#39;SHOW_ACTIVE&#39;}\n            onClick={() =&gt; {\n                dispatch(setVisibilityFilter(&#39;SHOW_ACTIVE&#39;))\n            }}&gt;Active&lt;&#x2F;Link&gt;\n        &amp;nbsp;&amp;nbsp;\n        &lt;Link active={visibilityFilter === &#39;SHOW_COMPLETED&#39;}\n            onClick={() =&gt; {\n                dispatch(setVisibilityFilter(&#39;SHOW_COMPLETED&#39;))\n            }}&gt;Completed&lt;&#x2F;Link&gt;\n    &lt;&#x2F;p&gt;\n)\nconst mapStateToProps = (state) =&gt; {\n    return {\n        visibilityFilter: state.visibilityFilter,\n    }\n}\nexport default connect(mapStateToProps)(Footer)</code></pre>\n<p>visibilityFilter是用来对todos列表进行过滤的，所以在todos列表展现之前，我们要根据visibilityFilter这个条件对todos列表进行处理。我们修改app.js中的mapStateToProps方法即可。</p>\n<pre><code>&#x2F;&#x2F; src&#x2F;app.js\n&#x2F;&#x2F; ...\nconst mapStateToProps = (state) =&gt; {\n    return {\n        todos: state.todos.filter((todo) =&gt; {\n            if (state.visibilityFilter === &#39;SHOW_ACTIVE&#39;) {\n                return !todo.completed\n            } else if (state.visibilityFilter === &#39;SHOW_COMPLETED&#39;) {\n                return todo.completed\n            } else {\n                &#x2F;&#x2F; SHOW_ALL\n                return true\n            }\n        }),\n    }\n}\n&#x2F;&#x2F; ...</code></pre>\n<p>mapStateToProps里面，我们使用filter()函数对原始的todos列表进行过滤，如果visibilityFilter为’SHOW_ALL’,我们都返回ture，那么返回的就是整个todos列表；如果visibilityFilter为’SHOW_ACTIVE’，我们就将completed属性为false的列表项返回true，filter()函数返回的结果就是所有”未完成”的待办事项；对于”SHOW_COMPLETED”也是同理。</p>\n<h1 id=\"5、结语\"><a href=\"#5、结语\" class=\"headerlink\" title=\"5、结语\"></a>5、结语</h1><p>到此，redux就和react搭配了起来。基于这两个技术，我们就可以开发一些简单的react应用了。</p>\n"}],"PostAsset":[{"_id":"source/_posts/react-ace-placeholder-20190329/react-ace-placeholder-01.gif","slug":"react-ace-placeholder-01.gif","post":"cjypcvop6000k4c41z7cc792j","modified":1,"renderable":0},{"_id":"source/_posts/reactRouter2-skills-20190320/router-children.gif","slug":"router-children.gif","post":"cjypcvopc000p4c41a24v7341","modified":1,"renderable":0},{"_id":"source/_posts/reactRouter2-skills-20190320/router-404.gif","slug":"router-404.gif","post":"cjypcvopc000p4c41a24v7341","modified":1,"renderable":0},{"_id":"source/_posts/redux5-middleware-20190110/redux-middleware.png","post":"cjypcvopf000t4c4189hhs2vu","slug":"redux-middleware.png","modified":1,"renderable":1},{"_id":"source/_posts/react-ace-placeholder-20190329/react-ace-02.gif","slug":"react-ace-02.gif","post":"cjypcvop6000k4c41z7cc792j","modified":1,"renderable":0},{"_id":"source/_posts/react-ace-placeholder-20190329/react-ace-cursor.png","post":"cjypcvop6000k4c41z7cc792j","slug":"react-ace-cursor.png","modified":1,"renderable":1},{"_id":"source/_posts/python3-nginx-uwsgi-20190727/django-success.png","post":"cjypcvop2000i4c41tv0q8jtk","slug":"django-success.png","modified":1,"renderable":1},{"_id":"source/_posts/python3-nginx-uwsgi-20190727/python3-success.png","post":"cjypcvop2000i4c41tv0q8jtk","slug":"python3-success.png","modified":1,"renderable":1},{"_id":"source/_posts/python3-nginx-uwsgi-20190727/sqlite3-01.png","post":"cjypcvop2000i4c41tv0q8jtk","slug":"sqlite3-01.png","modified":1,"renderable":1},{"_id":"source/_posts/python3-nginx-uwsgi-20190727/sqlite3.png","post":"cjypcvop2000i4c41tv0q8jtk","slug":"sqlite3.png","modified":1,"renderable":1},{"_id":"source/_posts/redux/result-20181213.png","post":"cjypcvoq0001i4c41kwmkfpb6","slug":"result-20181213.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjypcvopo00104c41jd2180i4","category_id":"cjypcvopr00134c4170ppnc7t","_id":"cjypcvopv001c4c41ovq2h9ac"},{"post_id":"cjypcvopo00104c41jd2180i4","category_id":"cjypcvopt00184c41irdzh8cj","_id":"cjypcvopv001e4c41rcg7tshu"},{"post_id":"cjypcvoq0001i4c41kwmkfpb6","category_id":"cjypcvoq2001k4c41grm2uzmr","_id":"cjypcvoq9001r4c41ic8c66fq"}],"PostTag":[{"post_id":"cjypcvooa00004c41saj091f6","tag_id":"cjypcvoog00024c413mq46kzp","_id":"cjypcvoon00074c41lui71rch"},{"post_id":"cjypcvool00054c41rltpt5ar","tag_id":"cjypcvoog00024c413mq46kzp","_id":"cjypcvoop00094c41dc6xezo7"},{"post_id":"cjypcvooe00014c41f8mmvls9","tag_id":"cjypcvoog00024c413mq46kzp","_id":"cjypcvoor000c4c410jqrocqp"},{"post_id":"cjypcvooo00084c41qcm73d7n","tag_id":"cjypcvoor000b4c41erwbr9n4","_id":"cjypcvoos000f4c419bh8z5m9"},{"post_id":"cjypcvooo00084c41qcm73d7n","tag_id":"cjypcvoos000d4c41i4pqjeyc","_id":"cjypcvoot000g4c4167k5ssd9"},{"post_id":"cjypcvoop000a4c410ym7xs62","tag_id":"cjypcvoos000e4c41sbql1wpt","_id":"cjypcvoot000h4c41jfdvix91"},{"post_id":"cjypcvop2000i4c41tv0q8jtk","tag_id":"cjypcvop9000m4c41pndldexj","_id":"cjypcvopf000s4c4121py05kn"},{"post_id":"cjypcvop6000k4c41z7cc792j","tag_id":"cjypcvope000r4c41ixv7xloi","_id":"cjypcvopl000x4c413k7k6oqi"},{"post_id":"cjypcvop9000n4c41byz0t6sr","tag_id":"cjypcvopk000v4c41cdo9nepb","_id":"cjypcvopp00114c41ntg956dr"},{"post_id":"cjypcvopc000p4c41a24v7341","tag_id":"cjypcvopn000z4c41hpeoz7ic","_id":"cjypcvops00154c411yszdvxv"},{"post_id":"cjypcvopf000t4c4189hhs2vu","tag_id":"cjypcvopr00144c419vbiz32j","_id":"cjypcvopt00174c412vtrhl66"},{"post_id":"cjypcvopi000u4c41t5pjgldo","tag_id":"cjypcvops00164c417pnx1lcr","_id":"cjypcvopu001a4c410wl66hog"},{"post_id":"cjypcvopm000y4c41dia00msx","tag_id":"cjypcvopt00194c41909ubupd","_id":"cjypcvopv001d4c414cpqex1d"},{"post_id":"cjypcvopo00104c41jd2180i4","tag_id":"cjypcvopu001b4c41l39s18nz","_id":"cjypcvopw001g4c41h0xauv8s"},{"post_id":"cjypcvopp00124c41m1acbbj9","tag_id":"cjypcvopw001f4c413q0qn9ew","_id":"cjypcvopw001h4c41laxvfmzf"},{"post_id":"cjypcvoq0001i4c41kwmkfpb6","tag_id":"cjypcvoog00024c413mq46kzp","_id":"cjypcvoq3001l4c41kozk2dgm"},{"post_id":"cjypcvoq1001j4c41yr6nkpz4","tag_id":"cjypcvoq7001n4c411lo9msjx","_id":"cjypcvoq9001q4c41vfo29m74"},{"post_id":"cjypcvoq3001m4c41hc2rz1c1","tag_id":"cjypcvoq9001p4c41cllh0oom","_id":"cjypcvoqa001t4c41rebhhq7a"},{"post_id":"cjypcvoq8001o4c417pb3mtyj","tag_id":"cjypcvoq7001n4c411lo9msjx","_id":"cjypcvoqb001u4c417pqmk048"}],"Tag":[{"name":"redux","_id":"cjypcvoog00024c413mq46kzp"},{"name":"d3","_id":"cjypcvoor000b4c41erwbr9n4"},{"name":"charts","_id":"cjypcvoos000d4c41i4pqjeyc"},{"name":"hexo","_id":"cjypcvoos000e4c41sbql1wpt"},{"name":"python, nginx, uwsgi, django","_id":"cjypcvop9000m4c41pndldexj"},{"name":"react ace placeholder 内容清空 光标 错位","_id":"cjypcvope000r4c41ixv7xloi"},{"name":"react-router","_id":"cjypcvopk000v4c41cdo9nepb"},{"name":"react router","_id":"cjypcvopn000z4c41hpeoz7ic"},{"name":"redux middleware","_id":"cjypcvopr00144c419vbiz32j"},{"name":"redux vuex","_id":"cjypcvops00164c417pnx1lcr"},{"name":"redux vue","_id":"cjypcvopt00194c41909ubupd"},{"name":"AI","_id":"cjypcvopu001b4c41l39s18nz"},{"name":"redux jest react","_id":"cjypcvopw001f4c413q0qn9ew"},{"name":"redux react","_id":"cjypcvoq7001n4c411lo9msjx"},{"name":"redux mockjs","_id":"cjypcvoq9001p4c41cllh0oom"}]}}